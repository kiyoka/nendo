;;-*- mode: nendo; syntax: scheme -*-;;
;; -----------------
(enable-idebug)
(disable-idebug)

(debug-print-length)
(debug-print-length 2000)




;; ------------------------------ my-or --------------------------
(define-syntax or
  (er-macro-transformer
   (lambda (expr rename compare)
     (cond ((null? (cdr expr)) #f)
           ((null? (cddr expr)) (cadr expr))
           (else
            (list (rename 'let) (list (list (rename 'tmp) (cadr expr)))
                  (list (rename 'if) (rename 'tmp)
                        (rename 'tmp)
                        (cons (rename 'or) (cddr expr)))))))))

(macroexpand
 '(or #f #f 1 3))

(or #f #f 1 3)

;; ------------------------------ my-and --------------------------
(define-syntax and
  (er-macro-transformer
   (lambda (expr rename compare)
     #?="my-and"
     (cond ((null? #?=(cdr expr)))
           ((null? #?=(cddr expr)) (cadr expr))
           (else (list (rename 'if) (cadr expr)
                       (cons (rename 'and) (cddr expr))
                       #f))))))

(macroexpand
 '(and 1 2 3 4))

(and 1 2 3 4)


;; ------------------------------ syntax-rules --------------------------

(define-syntax syntax-rules
  (er-macro-transformer
   (lambda (expr rename compare)
     (let ((ellipse-specified? (identifier? (cadr expr)))
           (count 0)
           (_er-macro-transformer (rename 'er-macro-transformer))
           (_lambda (rename 'lambda))      (_let (rename 'let))
           (_begin (rename 'begin))        (_if (rename 'if))
           (_and (rename 'and))            (_or (rename 'or))
           (_eq? (rename 'eq?))            (_equal? (rename 'equal?))
           (_car (rename 'car))            (_cdr (rename 'cdr))
           (_cons (rename 'cons))          (_pair? (rename 'pair?))
           (_null? (rename 'null?))        (_expr (rename 'expr))
           (_rename (rename 'rename))      (_compare (rename 'compare))
           (_quote (rename 'syntax-quote)) (_apply (rename 'apply))
           (_append (rename 'append))      (_map (rename 'map))
           (_vector? (rename 'vector?))    (_list? (rename 'list?))
           (_lp (rename 'lp))              (_reverse (rename 'reverse))
           (_len (rename'len))             (_length (rename 'length))
           (_- (rename '-))   (_>= (rename '>=))   (_error (rename 'error))
           (_ls (rename 'ls)) (_res (rename 'res)) (_i (rename 'i))
           (_vector->list (rename 'vector->list))
           (_list->vector (rename 'list->vector)))
       (define ellipse (rename (if #?=ellipse-specified? (cadr expr) '...)))
       (define lits (if ellipse-specified? (caddr expr) (cadr expr)))
       (define forms (if ellipse-specified? (cdddr expr) (cddr expr)))
       (define (next-v)
         (set! count (+ count 1))
         (rename (string->symbol (string-append "v__" (number->string count)))))
       (define (expand-pattern pat tmpl)
         (let lp ((p (cdr pat))
                  (x (list _cdr _expr))
                  (dim 0)
                  (vars '())
                  (k (lambda (vars)
                       (or (expand-template tmpl vars)
                           (list _begin #f)))))
           (let ((v (next-v)))
             (list
              _let (list (list v x))
              (cond
               ((identifier? p)
                (if (find (lambda (l) (compare p l)) lits)
                    (list _and (list _compare v (list _quote p)) (k vars))
                    (list _let (list (list p v)) (k (cons (cons p dim) vars)))))
               ((ellipse? p)
                (cond
                 ((not (null? (cddr p)))
                  (cond
                   ((not (list? (cddr p)))
                    (error "dotted ellipse" p))
                   ((find (lambda (x) (and (identifier? x) (compare x ellipse)))
                         (cddr p))
                    (error "multiple ellipses" p))
                   (else
                    (let ((len (length (cdr (cdr p)))))
                      `(,_let ((,_len (,_length ,v)))
                         (,_and (,_>= ,_len ,len)
                                (,_let ,_lp ((,_ls ,v)
                                             (,_i (,_- ,_len ,len))
                                             (,_res (,_quote ())))
                                  (,_if (,_>= 0 ,_i)
                                      ,(lp `(,@(cdr (cdr p)) ,(car p) ,(car (cdr p)))
                                           `(,_append ,_ls (,_reverse ,_res))
                                           dim
                                           vars
                                           k)
                                      (,_lp (,_cdr ,_ls)
                                            (,_- ,_i 1)
                                            (,_cons (,_car ,_ls) ,_res))))))))))
                 ((identifier? (car p))
                  (list _and (list _list? v)
                        (list _let (list (list (car p) v))
                              (k (cons (cons (car p) (+ 1 dim)) vars)))))
                 (else
                  (let* ((w (next-v))
                         (new-vars (all-vars (car p) (+ dim 1)))
                         (ls-vars (map (lambda (x)
                                         (rename
                                          (string->symbol
                                           (string-append
                                            (symbol->string
                                             (identifier->symbol (car x)))
                                            "-ls"))))
                                       new-vars))
                         (once
                          (lp (car p) (list _car w) (+ dim 1) '()
                              (lambda (_)
                                (cons
                                 _lp
                                 (cons
                                  (list _cdr w)
                                  (map (lambda (x l)
                                         (list _cons (car x) l))
                                       new-vars
                                       ls-vars)))))))
                    (list
                     _let
                     _lp (cons (list w v)
                               (map (lambda (x) (list x '())) ls-vars))
                     (list _if (list _null? w)
                           (list _let (map (lambda (x l)
                                             (list (car x) (list _reverse l)))
                                           new-vars
                                           ls-vars)
                                 (k (append new-vars vars)))
                           (list _and (list _pair? w) once)))))))
               ((pair? p)
                (list _and (list _pair? v)
                      (lp (car p)
                          (list _car v)
                          dim
                          vars
                          (lambda (vars)
                            (lp (cdr p) (list _cdr v) dim vars k)))))
               ((vector? p)
                (list _and
                      (list _vector? v)
                      (lp (vector->list p) (list _vector->list v) dim vars k)))
               ((null? p) (list _and (list _null? v) (k vars)))
               (else (list _and (list _equal? v p) (k vars))))))))
       (define (ellipse-escape? x) (and (pair? x) (compare ellipse (car x))))
       (define (ellipse? x)
         (and (pair? x) (pair? (cdr x)) (compare ellipse (cadr x))))
       (define (ellipse-depth x)
         (if (ellipse? x)
             (+ 1 (ellipse-depth (cdr x)))
             0))
       (define (ellipse-tail x)
         (if (ellipse? x)
             (ellipse-tail (cdr x))
             (cdr x)))
       (define (all-vars x dim)
         (let lp ((x x) (dim dim) (vars '()))
           (cond ((identifier? x)
                  (if (find (lambda (lit) (compare x lit)) lits)
                      vars
                      (cons (cons x dim) vars)))
                 ((ellipse? x) (lp (car x) (+ dim 1) vars))
                 ((pair? x) (lp (car x) dim (lp (cdr x) dim vars)))
                 ((vector? x) (lp (vector->list x) dim vars))
                 (else vars))))
       (define (free-vars x vars dim)
         (let lp ((x x) (free '()))
           (cond
            ((identifier? x)
             (if (and (not (memq x free))
                      (cond ((assq x vars) => (lambda (cell) (>= (cdr cell) dim)))
                            (else #f)))
                 (cons x free)
                 free))
            ((pair? x) (lp (car x) (lp (cdr x) free)))
            ((vector? x) (lp (vector->list x) free))
            (else free))))
       (define (expand-template tmpl vars)
         (let lp ((t #?=tmpl) (dim 0))
           (cond
            ((identifier? #?=t)
             (cond
              ((find (lambda (v) (compare t (car v))) #?=vars)
               => (lambda (cell)
                    (if (<= (cdr #?=cell) dim)
                        t
                        (error "too few ...'s"))))
              (else
               (list _rename (list _quote t)))))
            ((pair? t)
             (cond
              ((ellipse-escape? t)
               (if (pair? (cdr t))
                   (if (pair? (cddr t)) (cddr t) (cadr t))
                   (cdr t)))
              ((ellipse? t)
               (let* ((depth (ellipse-depth t))
                      (ell-dim (+ dim depth))
                      (ell-vars (free-vars (car t) vars ell-dim)))
                 (if (null? ell-vars)
                     (error "too many ...'s")
                     (let* ((once (lp (car t) ell-dim))
                            (nest (if (and (null? (cdr ell-vars))
                                           (identifier? once)
                                           (eq? once (car vars)))
                                      once ;; shortcut
                                      (cons _map
                                            (cons (list _lambda ell-vars once)
                                                  ell-vars))))
                            (many (do ((d depth (- d 1))
                                       (many nest
                                             (list _apply _append many)))
                                      ((= d 1) many))))
                       (if (null? (ellipse-tail t))
                           many ;; shortcut
                           (list _append many (lp (ellipse-tail t) dim)))))))
              (else (list _cons (lp (car t) dim) (lp (cdr t) dim)))))
            ((vector? t) (list _list->vector (lp (vector->list t) dim)))
            ((null? t) (list _quote '()))
            (else t))))
       (list
        _er-macro-transformer
        (list _lambda (list _expr _rename _compare)
              (cons
               _or
               (append
                (map
                 (lambda (clause) (expand-pattern (car clause) (cadr clause)))
                 forms)
                (list (list _error "no expansion for"
                            (list (rename 'strip-syntactic-closures) _expr)))))))))))


(macroexpand-1
 '(%cut #f () () print <>))


;; ------------------------------ cut ---------------------------
(define-syntax %cut
  (syntax-rules (<> <...>)
    ((%cut e? params args)
     (lambda params args))
    ((%cut e? (params ...) (args ...) <> . rest)
     (%cut e? (params ... tmp) (args ... tmp) . rest))
    ((%cut e? (params ...) (args ...) <...>)
     (%cut e? (params ... . tmp) (apply args ... tmp)))
    ((%cut e? (params ...) (args ...) <...> . rest)
     (error "cut: non-terminal <...>"))
    ((%cut #t (params ...) (args ...) x . rest)
     (let ((tmp x)) (%cut #t (params ...) (args ... tmp) . rest)))
    ((%cut #f (params ...) (args ...) x . rest)
     (%cut #t (params ...) (args ... x) . rest))))

(pretty-print
 (disasm '%cut 'expanded))

(define-syntax cut
  (syntax-rules () ((cut args ...) (%cut #f () () args ...))))
(define-syntax cute
  (syntax-rules () ((cute args ...) (%cut #t () () args ...))))

(pretty-print
 (disasm 'cut 'expanded))

(macroexpand
 '(map (cut + 1 <>) '(1 2 3 4)))

(map (cut + 1 <>) '(1 2 3 4))

(macroexpand-1
 '(%cut #f () () print <>))

(%cut #f () () print <>)

(macroexpand-1
 (macroexpand-1
  '((cut print <>) 1)))

(cut print <>)


;; ------------------------------ nil! ---------------------------

(define-syntax nil!
  (syntax-rules ()
    ((_ x)
     (set! x '()))))

(pretty-print
 (disasm 'nil! 'expanded))

(define a 1)
(macroexpand '(nil! a))

;; ------------------------------ my-when ---------------------------
(define-syntax my-when
  (syntax-rules ()
    ((_ pred b1 ...)
     (if pred (begin b1 ...)))))

(pretty-print
 (disasm 'my-when 'expanded))


(macroexpand
 '(my-when #t
    (display 1)
    (newline)))


(macroexpand
 '(let ((i 0))
    (my-when (= i 0)
             (display "i == 0")
             (newline))))

;; ------------------------------ and-let (chibi-scheme)---------------------------
(define-syntax and-let*
  (syntax-rules ()
    ((and-let* () . body)
     (begin . body))
    ((and-let* ((var expr) . rest) . body)
     (let ((var expr))
       (and var (and-let* rest . body))))
    ((and-let* ((expr) . rest) . body)
     (let ((tmp expr))
       (and tmp (and-let* rest . body))))))


(and-let* ((num 1)
           (2)
           ("abc"))
  num)


;; ------------------------------ cond-list (Gauche-0.9.1) ---------------------------
(define-syntax cond-list
  (syntax-rules (=> @)
    ((_) '())
    ((_ (test) . rest)
     (let* ((tmp test)
            (r (cond-list . rest)))
       (if tmp (cons tmp r) r)))
    ((_ (test => proc) . rest)
     (let* ((tmp test)
            (r (cond-list . rest)))
       (if tmp (cons (proc tmp) r) r)))
    ((_ (test => @ proc) . rest)
     (let* ((tmp test)
            (r (cond-list . rest)))
       (if tmp (append (proc tmp) r) r)))
    ((_ (test @ . expr) . rest)
     (let* ((tmp test)
            (r (cond-list . rest)))
       (if tmp (append (begin . expr) r) r)))
    ((_ (test . expr) . rest)
     (let* ((tmp test)
            (r (cond-list . rest)))
       (if tmp (cons (begin . expr) r) r)))
    ))

 	
(let ((alist '((x 3) (y -1) (z 6))))
 (cond-list ((assoc 'x alist) 'have-x)
            ((assoc 'w alist) 'have-w)
            ((assoc 'z alist) => cadr)))
;; (have-x 6)

(let ((x 2) (y #f) (z 5))
  (cond-list (x @ `(:x ,x))
             (y @ `(:y ,y))
             (z @ `(:z ,z))))
;; (:x 2 :z 5)







