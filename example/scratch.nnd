;;-*- mode: nendo; syntax: scheme -*-;;
;; -----------------
(enable-idebug)
(disable-idebug)
(exit)

(debug-print-length)
(debug-print-length 2000)

(error "Error: (error) func test 1")
(error "Error: (error) func test 1" '(r a i s e))


;; :optional feature from Gauche-0.9.1 .
(define define
  (macro (arg . body)
    (if (not (pair? arg))
        ;; (define var body)
        (cons 'define
              (cons arg
                    body))
        (%expand-define-form-lambda arg body))))

(define %expand-define-form
  (lambda (arg-and-body)
    (let ((arg  (car arg-and-body))
          (body (cdr arg-and-body)))
      ;; (define (func arg...) body)
      (if (not (pair? arg))
          ;; (define var body)
          (cons 'define
                (cons arg
                      body))
          (%expand-define-form-lambda arg body)))))


(define %expand-define-form-lambda
  (lambda (arg body-list)
    ;; (define (func arg...) body)
    (if (pair? (cdr arg))
        (if (pair? (car (cdr arg)))
            (error "Error: define syntax error.")))
    (cons 'define
          (cons (car arg)
                (%transform-optional-arguments arg body-list)))))


  (define (%transform-optional-arguments arg body-list)
    (if-let1 rest-of-opts #?=(memq :optional arg)
             (let([opts         '()]
                  [rest-of-opts (cdr rest-of-opts)])
               (let loop ((arg arg))
                 (if (eq? :optional (car arg))
                     arg
                     (begin
                       (set! opts (cons (car arg) opts))
                       (loop (cdr arg)))))
               (let1 new-arg (apply list* (append (reverse opts) (list '___rest)))
                 (list 'lambda
                       new-arg
                       `(let
                            ,rest-of-opts
                          ,@(map
                             (lambda (k n)
                               `(when (< ,n (length __rest))
                                  (set! ,(car k) (nth ,n ___rest))))
                             rest-of-opts
                             (range (length rest-of-opts)))
                          ,body-list))))
             (list 'lambda arg body-list)))


(%transform-optional-arguments '(arg1 arg2)
                               '(begin 1 2))
(pretty-print
 (%transform-optional-arguments '(arg1 arg2 :optional (arg3 #f))
                                '(begin 1 2)))

(pretty-print
 (%transform-optional-arguments '(arg1 arg2 :optional (arg3 #f) (arg4 #t))
                                '(begin 1 2)))


(macroexpand
 '(define (a arg1 arg2 :optional arg3)
    (begin
      1
      2)))
   
