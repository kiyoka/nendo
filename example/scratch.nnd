;;-*- mode: nendo; syntax: scheme -*-;;
;; -----------------
(enable-idebug)
(disable-idebug)
(define debug-print-length 256)

(define (exist-tail-call? sexp)
  (cond
   ((not (list? sexp))
    (error "exist-tail-call? expected a list argument."))
   (else
    (let1 last (last-pair sexp)
      (cond
       ((pair? last)
        (if (procedure? (car last))
            
       (else
        ;; noting to do
        sexp))))))


(define (setup-tail-call-mark sexp)
  (if (exist-tail-call? sexp)
      (mark-tail-call sexp)
      (traverse-tail-call sexp)))

(define (traverse-tail-call sexp)
  (cond
   ((null? sexp)
    '())
   ((list? sexp)
    (case (car sexp)
      ('if
       (setup-tail-call-mark (second sexp))
       (setup-tail-call-mark (third sexp)))))
   (else
    sexp)))


(setup-tail-call-mark
 )


(macroexpand
 '(if #t
      1
      2))

(macroexpand
 '(or
   1
   2
   ))

(macroexpand
 '(cond
   (1
    (print "1"))
   (2
    (print "2"))
   (else
    (print "else"))))




;; named let supporting
(define let
  (macro lst
    (if (symbol? (car lst))
        ;; named let
        (let1 arg-list ,(map
                         (lambda (x)
                           (first x))
                         (second lst))

          `(letrec ((,(first lst)
                     (lambda (,arg-list)
                       (begin
                         (%with-tco-entry ,(first lst) ,arg-list)
                         ,(third lst)))))
             (,(first lst)
              ,@(map
                 (lambda (x)
                   (second x))
                 (second lst)))))
           
        ;; don't touch
        `(let ,@lst))))







;; normal source
(define (sample x)
  1
  2
  3
  (sample 4))

;;
;; 1. ( macro expand phase )
;;    macro `define` and `lambda` and `if` and other  macro generates these %possible-xxxxx mark.
;; 
(define (sample x)
  (%possible-tco-entry (sample x)
                   1
                   2
                   3
                   (%possible-tco (sample 4))))

;;
;; 2. ( searching tco able points phase )
;;     case of found some optimized code
(define (sample x)
  (%fixed-tco-entry (sample x)
                   1
                   2
                   3
                   (%fixed-tco (sample 4))))

;;    case of not found any optimized code
(define (sample x)
  (begin
    1
    2
    3
    (foo 4)))



;; function %fixed-tco-entry will be translated to Ruby code
(%fixed-tco-entry label1 a b c ...)
=> [Ruby code]
  update_label1 = lambda {|_a,_b,_c|
                                     a = _a
                                     b = _b
                                     c = _c
                         }
  cont_label1 = nil
  callcc { |cc| cont_label1 = cc }

  ...

;; function %fixed-tco will be translated to Ruby code
(%fixed-tco (label1 10 20 30))
=> [macro expand]
  (begin
     (update_label 10 20 30)
     (cont_label1))
=> [Ruby code]
  update_label1.call( 10, 20, 30 )
  cont_label1.call()

