;;-*- mode: nendo; syntax: scheme -*-;;
;; -----------------
(enable-idebug)
(disable-idebug)

(debug-print-length)
(debug-print-length 2000)


;; ------------------------------ cut ---------------------------
(define-syntax %cut
  (syntax-rules (<> <...>)
    ((%cut e? params args)
     (lambda params args))
    ((%cut e? (params ...) (args ...) <> . rest)
     (%cut e? (params ... tmp) (args ... tmp) . rest))
    ((%cut e? (params ...) (args ...) <...>)
     (%cut e? (params ... . tmp) (apply args ... tmp)))
    ((%cut e? (params ...) (args ...) <...> . rest)
     (error "cut: non-terminal <...>"))
    ((%cut #t (params ...) (args ...) x . rest)
     (let ((tmp x)) (%cut #t (params ...) (args ... tmp) . rest)))
    ((%cut #f (params ...) (args ...) x . rest)
     (%cut #t (params ...) (args ... x) . rest))))

(pretty-print
 (disasm '%cut 'expanded))

(define-syntax cut
  (syntax-rules () ((cut args ...) (%cut #f () () args ...))))
(define-syntax cute
  (syntax-rules () ((cute args ...) (%cut #t () () args ...))))

(pretty-print
 (disasm 'cut 'expanded))

(macroexpand
 '(map (cut + 1 <>) '(1 2 3 4)))

(map (cut + 1 <>) '(1 2 3 4))

(macroexpand-1
 '(%cut #f () () print <>))

(%cut #f () () print <>)

(macroexpand-1
 (macroexpand-1
  '((cut print <>) 1)))

(cut print <>)


;; ------------------------------ and-let (chibi-scheme)---------------------------
(define-syntax and-let*
  (syntax-rules ()
    ((and-let* () . body)
     (begin . body))
    ((and-let* ((var expr) . rest) . body)
     (let ((var expr))
       (and var (and-let* rest . body))))
    ((and-let* ((expr) . rest) . body)
     (let ((tmp expr))
       (and tmp (and-let* rest . body))))))


(and-let* ((num 1)
           (2)
           ("abc"))
  num)


;; ------------------------------ cond-list (Gauche-0.9.1) ---------------------------
(define-syntax cond-list
  (syntax-rules (=> @)
    ((_) '())
    ((_ (test) . rest)
     (let* ((tmp test)
            (r (cond-list . rest)))
       (if tmp (cons tmp r) r)))
    ((_ (test => proc) . rest)
     (let* ((tmp test)
            (r (cond-list . rest)))
       (if tmp (cons (proc tmp) r) r)))
    ((_ (test => @ proc) . rest)
     (let* ((tmp test)
            (r (cond-list . rest)))
       (if tmp (append (proc tmp) r) r)))
    ((_ (test @ . expr) . rest)
     (let* ((tmp test)
            (r (cond-list . rest)))
       (if tmp (append (begin . expr) r) r)))
    ((_ (test . expr) . rest)
     (let* ((tmp test)
            (r (cond-list . rest)))
       (if tmp (cons (begin . expr) r) r)))
    ))

 	
(let ((alist '((x 3) (y -1) (z 6))))
 (cond-list ((assoc 'x alist) 'have-x)
            ((assoc 'w alist) 'have-w)
            ((assoc 'z alist) => cadr)))
;; (have-x 6)

(let ((x 2) (y #f) (z 5))
  (cond-list (x @ `(:x ,x))
             (y @ `(:y ,y))
             (z @ `(:z ,z))))
;; (:x 2 :z 5)





