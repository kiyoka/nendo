;;-*- mode: nendo; syntax: scheme -*-;;

;; -----------------
(enable-idebug)
(define debug-print-length 256)


;; shiroさんからのアドバイス ( 
;; >kiyoka 性能を考えないなら、guileがやってたように0個と2個以上の値を特別なオブジェクトにパックしてしまうってのでとりあえず動かすことはできますよ。
;; 受け取る値の個数を間違えた場合にその内部的な「多値オブジェクト」が見えてしまう、というのがちょっと残念ですが。
;;
;; 多値オブジェクトは make-values で作成、values? で判断、 values-valuesで値リスト取り出し、と想定。

(values-values (make-values '()))
(values-values (make-values '(1)))
(values-values (make-values '(1 2)))
(values-values (make-values '(1 2 3)))

(define (values . args)
  (case (length args)
    ((1)
     (car args))
    (else
     (make-values args))))

(for-each
 (lambda (x)
   (write (first x))
   (if (values? (second x))
       (printf " is values : %s" (write-to-string (values-values (second x))))
       (printf " is NOT values"))
   (newline))
 `(
   ((values)       ,(values))
   ((values 1)     ,(values 1))
   ((values 1 2)   ,(values 1 2))
   ((values 1 2 3) ,(values 1 2 3))
   ((values '(a) "b" '("C"))
    ,(values '(a) "b" '("C")))))
 
(values 1)
(values-values (values 1 2))
(values-values (values 1 2 3))
(values-values (values '(a) "b" '("C")))

(define (call-with-values producer consumer)
  (let ((v (producer)))
    (if (values? v)
        (apply consumer (values-values v))
        (consumer v))))

(call-with-values
    (lambda () (values 4 5)) 
  (lambda (a b) b))

(call-with-values
    (lambda () (values 1 2)) 
  cons)

(call-with-values * -)

(define-syntax
  receive
  (syntax-rules ()
    ((receive vars expr body ...)
     (call-with-values
         (lambda () expr)
       (lambda vars body ...)))))
