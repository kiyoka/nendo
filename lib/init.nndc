#
#    This file is nendo's compiled library file. 
#    generated  "nendo -c src" command. 
# 

trampCall( 
  begin
      def self.__PAMARKexpand_MIMARKdefine_MIMARKform_MIMARKlambda_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['__PAMARKexpand_MIMARKdefine_MIMARKform_MIMARKlambda'] = self.method( :__PAMARKexpand_MIMARKdefine_MIMARKform_MIMARKlambda_METHOD )
    @__PAMARKexpand_MIMARKdefine_MIMARKform_MIMARKlambda = 
    trampCall(
          Proc.new { |_arg,_body_MIMARKlist| 
              if ( 
                trampCall( self._pair_QUMARK_METHOD(  'pair?',
                    begin
                      if @global_lisp_binding.has_key?('_pair_QUMARK') then
                        trampCall(@_pair_QUMARK)
                      else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:44"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      trampCall( self._cdr_METHOD(  'cdr',
                          begin
                            if @global_lisp_binding.has_key?('_cdr') then
                              trampCall(@_cdr)
                            else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:50"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_arg)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:50"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                ]
                             ))
               ) then
                  if ( 
                    trampCall( self._pair_QUMARK_METHOD(  'pair?',
                        begin
                          if @global_lisp_binding.has_key?('_pair_QUMARK') then
                            trampCall(@_pair_QUMARK)
                          else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:44"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:47"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._cdr_METHOD(  'cdr',
                                    begin
                                      if @global_lisp_binding.has_key?('_cdr') then
                                        trampCall(@_cdr)
                                      else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:50"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_arg)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:50"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
                   ) then
                      begin raise RuntimeError, 
                      "Error: define syntax error."
                      rescue => __e 
                        __e.set_backtrace( ["./lib/init.nnd:45"] + __e.backtrace )
                        raise __e
                      end 
                  end
              end
              delayCall( '_cons',  'cons',
                  begin
                    if @global_lisp_binding.has_key?('_cons') then
                      trampCall(@_cons)
                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:50"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  :"define"                  ,
                    trampCall( self._cons_METHOD(  'cons',
                        begin
                          if @global_lisp_binding.has_key?('_cons') then
                            trampCall(@_cons)
                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:50"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:47"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_arg)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:50"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))                        ,
                          trampCall( self._list_METHOD(  'list',
                              begin
                                if @global_lisp_binding.has_key?('_list') then
                                  trampCall(@_list)
                                else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:48"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:50"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                    :"lambda"                                    ,
                                      trampCall( self._cons_METHOD(  'cons',
                                          begin
                                            if @global_lisp_binding.has_key?('_cons') then
                                              trampCall(@_cons)
                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:50"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            trampCall( self._cdr_METHOD(  'cdr',
                                                begin
                                                  if @global_lisp_binding.has_key?('_cdr') then
                                                    trampCall(@_cdr)
                                                  else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:50"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_arg)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:50"] + __e.backtrace ) ; raise __e
                                                  end
                                            ]
                                                         ))                                          ,
                                            begin
                                                trampCall(_body_MIMARKlist)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:51"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._define_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_define'] = self.method( :_define_METHOD )
    @_define = 
    trampCall(
          LispMacro.new { |_arg,*__rest__| _body = __rest__[0] ;  
              if ( 
                trampCall( self._not_METHOD(  'not',
                    begin
                      if @global_lisp_binding.has_key?('_not') then
                        trampCall(@_not)
                      else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:55"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      trampCall( self._pair_QUMARK_METHOD(  'pair?',
                          begin
                            if @global_lisp_binding.has_key?('_pair_QUMARK') then
                              trampCall(@_pair_QUMARK)
                            else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:55"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_arg)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:60"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                ]
                             ))
               ) then
                  trampCall( self._cons_METHOD(  'cons',
                      begin
                        if @global_lisp_binding.has_key?('_cons') then
                          trampCall(@_cons)
                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:58"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                      :"define"                      ,
                        trampCall( self._cons_METHOD(  'cons',
                            begin
                              if @global_lisp_binding.has_key?('_cons') then
                                trampCall(@_cons)
                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:58"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(_arg)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:60"] + __e.backtrace ) ; raise __e
                              end                            ,
                              begin
                                  trampCall(_body)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:60"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     ))
                  ]
                               ))
              else
                  trampCall( self.__PAMARKexpand_MIMARKdefine_MIMARKform_MIMARKlambda_METHOD(  '%expand-define-form-lambda',
                      begin
                        if @global_lisp_binding.has_key?('__PAMARKexpand_MIMARKdefine_MIMARKform_MIMARKlambda') then
                          trampCall(@__PAMARKexpand_MIMARKdefine_MIMARKform_MIMARKlambda)
                        else raise NameError.new( "Error: undefined variable __PAMARKexpand_MIMARKdefine_MIMARKform_MIMARKlambda", "__PAMARKexpand_MIMARKdefine_MIMARKform_MIMARKlambda" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:60"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                        begin
                            trampCall(_arg)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:60"] + __e.backtrace ) ; raise __e
                        end                      ,
                        begin
                            trampCall(_body)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:60"] + __e.backtrace ) ; raise __e
                        end
                  ]
                               ))
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self.__PAMARKexpand_MIMARKdefine_MIMARKform_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['__PAMARKexpand_MIMARKdefine_MIMARKform'] = self.method( :__PAMARKexpand_MIMARKdefine_MIMARKform_METHOD )
    @__PAMARKexpand_MIMARKdefine_MIMARKform = 
    trampCall(
          Proc.new { |_arg_MIMARKand_MIMARKbody| 
              begin
                ___lambda = lambda { |_arg,_body| 
                    if ( 
                      trampCall( self._not_METHOD(  'not',
                          begin
                            if @global_lisp_binding.has_key?('_not') then
                              trampCall(@_not)
                            else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:67"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            trampCall( self._pair_QUMARK_METHOD(  'pair?',
                                begin
                                  if @global_lisp_binding.has_key?('_pair_QUMARK') then
                                    trampCall(@_pair_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:67"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_arg)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:72"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                      ]
                                   ))
                     ) then
                        delayCall( '_cons',  'cons',
                            begin
                              if @global_lisp_binding.has_key?('_cons') then
                                trampCall(@_cons)
                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:70"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                            :"define"                            ,
                              trampCall( self._cons_METHOD(  'cons',
                                  begin
                                    if @global_lisp_binding.has_key?('_cons') then
                                      trampCall(@_cons)
                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:70"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_arg)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:72"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                    begin
                                        trampCall(_body)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:72"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                        ]
                                     )
                    else
                        delayCall( '__PAMARKexpand_MIMARKdefine_MIMARKform_MIMARKlambda',  '%expand-define-form-lambda',
                            begin
                              if @global_lisp_binding.has_key?('__PAMARKexpand_MIMARKdefine_MIMARKform_MIMARKlambda') then
                                trampCall(@__PAMARKexpand_MIMARKdefine_MIMARKform_MIMARKlambda)
                              else raise NameError.new( "Error: undefined variable __PAMARKexpand_MIMARKdefine_MIMARKform_MIMARKlambda", "__PAMARKexpand_MIMARKdefine_MIMARKform_MIMARKlambda" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:72"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(_arg)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:72"] + __e.backtrace ) ; raise __e
                              end                            ,
                              begin
                                  trampCall(_body)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:72"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     )
                    end
                } ; ___lambda.call(
                      trampCall( self._car_METHOD(  'car',
                          begin
                            if @global_lisp_binding.has_key?('_car') then
                              trampCall(@_car)
                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:64"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_arg_MIMARKand_MIMARKbody)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:65"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))                    ,
                      trampCall( self._cdr_METHOD(  'cdr',
                          begin
                            if @global_lisp_binding.has_key?('_cdr') then
                              trampCall(@_cdr)
                            else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:65"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_arg_MIMARKand_MIMARKbody)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:65"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._debug_MIMARKprint_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_debug_MIMARKprint'] = self.method( :_debug_MIMARKprint_METHOD )
    @_debug_MIMARKprint = 
    trampCall(
          LispMacro.new { |__form,_sourcefile,_lineno,_sourcesexp| 
              begin
                  trampCall(__form)
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:78"] + __e.backtrace ) ; raise __e
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._caar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_caar'] = self.method( :_caar_METHOD )
    @_caar = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_car',  'car',
                  begin
                    if @global_lisp_binding.has_key?('_car') then
                      trampCall(@_car)
                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:83"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:83"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_x)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:83"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cadr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cadr'] = self.method( :_cadr_METHOD )
    @_cadr = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_car',  'car',
                  begin
                    if @global_lisp_binding.has_key?('_car') then
                      trampCall(@_car)
                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:84"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:84"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_x)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:84"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cdar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cdar'] = self.method( :_cdar_METHOD )
    @_cdar = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_cdr',  'cdr',
                  begin
                    if @global_lisp_binding.has_key?('_cdr') then
                      trampCall(@_cdr)
                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:85"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:85"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_x)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:85"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cddr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cddr'] = self.method( :_cddr_METHOD )
    @_cddr = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_cdr',  'cdr',
                  begin
                    if @global_lisp_binding.has_key?('_cdr') then
                      trampCall(@_cdr)
                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:86"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:86"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_x)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:86"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._caaar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_caaar'] = self.method( :_caaar_METHOD )
    @_caaar = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_car',  'car',
                  begin
                    if @global_lisp_binding.has_key?('_car') then
                      trampCall(@_car)
                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:87"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:87"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:87"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_x)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:87"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._caadr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_caadr'] = self.method( :_caadr_METHOD )
    @_caadr = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_car',  'car',
                  begin
                    if @global_lisp_binding.has_key?('_car') then
                      trampCall(@_car)
                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:88"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:88"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cdr_METHOD(  'cdr',
                              begin
                                if @global_lisp_binding.has_key?('_cdr') then
                                  trampCall(@_cdr)
                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:88"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_x)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:88"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cadar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cadar'] = self.method( :_cadar_METHOD )
    @_cadar = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_car',  'car',
                  begin
                    if @global_lisp_binding.has_key?('_car') then
                      trampCall(@_car)
                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:89"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:89"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:89"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_x)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:89"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._caddr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_caddr'] = self.method( :_caddr_METHOD )
    @_caddr = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_car',  'car',
                  begin
                    if @global_lisp_binding.has_key?('_car') then
                      trampCall(@_car)
                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:90"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:90"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cdr_METHOD(  'cdr',
                              begin
                                if @global_lisp_binding.has_key?('_cdr') then
                                  trampCall(@_cdr)
                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:90"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_x)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:90"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cdaar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cdaar'] = self.method( :_cdaar_METHOD )
    @_cdaar = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_cdr',  'cdr',
                  begin
                    if @global_lisp_binding.has_key?('_cdr') then
                      trampCall(@_cdr)
                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:91"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:91"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:91"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_x)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:91"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cdadr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cdadr'] = self.method( :_cdadr_METHOD )
    @_cdadr = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_cdr',  'cdr',
                  begin
                    if @global_lisp_binding.has_key?('_cdr') then
                      trampCall(@_cdr)
                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:92"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:92"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cdr_METHOD(  'cdr',
                              begin
                                if @global_lisp_binding.has_key?('_cdr') then
                                  trampCall(@_cdr)
                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:92"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_x)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:92"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cddar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cddar'] = self.method( :_cddar_METHOD )
    @_cddar = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_cdr',  'cdr',
                  begin
                    if @global_lisp_binding.has_key?('_cdr') then
                      trampCall(@_cdr)
                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:93"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:93"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:93"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_x)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:93"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cdddr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cdddr'] = self.method( :_cdddr_METHOD )
    @_cdddr = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_cdr',  'cdr',
                  begin
                    if @global_lisp_binding.has_key?('_cdr') then
                      trampCall(@_cdr)
                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:94"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:94"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cdr_METHOD(  'cdr',
                              begin
                                if @global_lisp_binding.has_key?('_cdr') then
                                  trampCall(@_cdr)
                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:94"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_x)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:94"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._caaaar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_caaaar'] = self.method( :_caaaar_METHOD )
    @_caaaar = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_car',  'car',
                  begin
                    if @global_lisp_binding.has_key?('_car') then
                      trampCall(@_car)
                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:95"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:95"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:95"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._car_METHOD(  'car',
                                    begin
                                      if @global_lisp_binding.has_key?('_car') then
                                        trampCall(@_car)
                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:95"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:95"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._caaadr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_caaadr'] = self.method( :_caaadr_METHOD )
    @_caaadr = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_car',  'car',
                  begin
                    if @global_lisp_binding.has_key?('_car') then
                      trampCall(@_car)
                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:96"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:96"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:96"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._cdr_METHOD(  'cdr',
                                    begin
                                      if @global_lisp_binding.has_key?('_cdr') then
                                        trampCall(@_cdr)
                                      else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:96"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:96"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._caadar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_caadar'] = self.method( :_caadar_METHOD )
    @_caadar = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_car',  'car',
                  begin
                    if @global_lisp_binding.has_key?('_car') then
                      trampCall(@_car)
                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:97"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:97"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cdr_METHOD(  'cdr',
                              begin
                                if @global_lisp_binding.has_key?('_cdr') then
                                  trampCall(@_cdr)
                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:97"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._car_METHOD(  'car',
                                    begin
                                      if @global_lisp_binding.has_key?('_car') then
                                        trampCall(@_car)
                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:97"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:97"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._caaddr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_caaddr'] = self.method( :_caaddr_METHOD )
    @_caaddr = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_car',  'car',
                  begin
                    if @global_lisp_binding.has_key?('_car') then
                      trampCall(@_car)
                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:98"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:98"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cdr_METHOD(  'cdr',
                              begin
                                if @global_lisp_binding.has_key?('_cdr') then
                                  trampCall(@_cdr)
                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:98"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._cdr_METHOD(  'cdr',
                                    begin
                                      if @global_lisp_binding.has_key?('_cdr') then
                                        trampCall(@_cdr)
                                      else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:98"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:98"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cadaar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cadaar'] = self.method( :_cadaar_METHOD )
    @_cadaar = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_car',  'car',
                  begin
                    if @global_lisp_binding.has_key?('_car') then
                      trampCall(@_car)
                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:99"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:99"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:99"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._car_METHOD(  'car',
                                    begin
                                      if @global_lisp_binding.has_key?('_car') then
                                        trampCall(@_car)
                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:99"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:99"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cadadr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cadadr'] = self.method( :_cadadr_METHOD )
    @_cadadr = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_car',  'car',
                  begin
                    if @global_lisp_binding.has_key?('_car') then
                      trampCall(@_car)
                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:100"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:100"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:100"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._cdr_METHOD(  'cdr',
                                    begin
                                      if @global_lisp_binding.has_key?('_cdr') then
                                        trampCall(@_cdr)
                                      else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:100"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:100"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._caddar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_caddar'] = self.method( :_caddar_METHOD )
    @_caddar = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_car',  'car',
                  begin
                    if @global_lisp_binding.has_key?('_car') then
                      trampCall(@_car)
                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:101"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:101"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cdr_METHOD(  'cdr',
                              begin
                                if @global_lisp_binding.has_key?('_cdr') then
                                  trampCall(@_cdr)
                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:101"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._car_METHOD(  'car',
                                    begin
                                      if @global_lisp_binding.has_key?('_car') then
                                        trampCall(@_car)
                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:101"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:101"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cadddr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cadddr'] = self.method( :_cadddr_METHOD )
    @_cadddr = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_car',  'car',
                  begin
                    if @global_lisp_binding.has_key?('_car') then
                      trampCall(@_car)
                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:102"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:102"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cdr_METHOD(  'cdr',
                              begin
                                if @global_lisp_binding.has_key?('_cdr') then
                                  trampCall(@_cdr)
                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:102"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._cdr_METHOD(  'cdr',
                                    begin
                                      if @global_lisp_binding.has_key?('_cdr') then
                                        trampCall(@_cdr)
                                      else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:102"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:102"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cdaaar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cdaaar'] = self.method( :_cdaaar_METHOD )
    @_cdaaar = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_cdr',  'cdr',
                  begin
                    if @global_lisp_binding.has_key?('_cdr') then
                      trampCall(@_cdr)
                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:103"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:103"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:103"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._car_METHOD(  'car',
                                    begin
                                      if @global_lisp_binding.has_key?('_car') then
                                        trampCall(@_car)
                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:103"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:103"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cdaadr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cdaadr'] = self.method( :_cdaadr_METHOD )
    @_cdaadr = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_cdr',  'cdr',
                  begin
                    if @global_lisp_binding.has_key?('_cdr') then
                      trampCall(@_cdr)
                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:104"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:104"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:104"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._cdr_METHOD(  'cdr',
                                    begin
                                      if @global_lisp_binding.has_key?('_cdr') then
                                        trampCall(@_cdr)
                                      else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:104"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:104"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cdadar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cdadar'] = self.method( :_cdadar_METHOD )
    @_cdadar = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_cdr',  'cdr',
                  begin
                    if @global_lisp_binding.has_key?('_cdr') then
                      trampCall(@_cdr)
                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:105"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:105"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cdr_METHOD(  'cdr',
                              begin
                                if @global_lisp_binding.has_key?('_cdr') then
                                  trampCall(@_cdr)
                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:105"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._car_METHOD(  'car',
                                    begin
                                      if @global_lisp_binding.has_key?('_car') then
                                        trampCall(@_car)
                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:105"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:105"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cdaddr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cdaddr'] = self.method( :_cdaddr_METHOD )
    @_cdaddr = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_cdr',  'cdr',
                  begin
                    if @global_lisp_binding.has_key?('_cdr') then
                      trampCall(@_cdr)
                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:106"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:106"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cdr_METHOD(  'cdr',
                              begin
                                if @global_lisp_binding.has_key?('_cdr') then
                                  trampCall(@_cdr)
                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:106"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._cdr_METHOD(  'cdr',
                                    begin
                                      if @global_lisp_binding.has_key?('_cdr') then
                                        trampCall(@_cdr)
                                      else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:106"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:106"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cddaar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cddaar'] = self.method( :_cddaar_METHOD )
    @_cddaar = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_cdr',  'cdr',
                  begin
                    if @global_lisp_binding.has_key?('_cdr') then
                      trampCall(@_cdr)
                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:107"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:107"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:107"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._car_METHOD(  'car',
                                    begin
                                      if @global_lisp_binding.has_key?('_car') then
                                        trampCall(@_car)
                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:107"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:107"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cddadr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cddadr'] = self.method( :_cddadr_METHOD )
    @_cddadr = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_cdr',  'cdr',
                  begin
                    if @global_lisp_binding.has_key?('_cdr') then
                      trampCall(@_cdr)
                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:108"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:108"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:108"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._cdr_METHOD(  'cdr',
                                    begin
                                      if @global_lisp_binding.has_key?('_cdr') then
                                        trampCall(@_cdr)
                                      else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:108"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:108"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cdddar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cdddar'] = self.method( :_cdddar_METHOD )
    @_cdddar = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_cdr',  'cdr',
                  begin
                    if @global_lisp_binding.has_key?('_cdr') then
                      trampCall(@_cdr)
                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:109"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:109"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cdr_METHOD(  'cdr',
                              begin
                                if @global_lisp_binding.has_key?('_cdr') then
                                  trampCall(@_cdr)
                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:109"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._car_METHOD(  'car',
                                    begin
                                      if @global_lisp_binding.has_key?('_car') then
                                        trampCall(@_car)
                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:109"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:109"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cddddr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cddddr'] = self.method( :_cddddr_METHOD )
    @_cddddr = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_cdr',  'cdr',
                  begin
                    if @global_lisp_binding.has_key?('_cdr') then
                      trampCall(@_cdr)
                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:110"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:110"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cdr_METHOD(  'cdr',
                              begin
                                if @global_lisp_binding.has_key?('_cdr') then
                                  trampCall(@_cdr)
                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:110"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._cdr_METHOD(  'cdr',
                                    begin
                                      if @global_lisp_binding.has_key?('_cdr') then
                                        trampCall(@_cdr)
                                      else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:110"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_x)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:110"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._iota_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_iota'] = self.method( :_iota_METHOD )
    @_iota = 
    trampCall(
          begin
            if @global_lisp_binding.has_key?('_range') then
              trampCall(@_range)
            else raise NameError.new( "Error: undefined variable _range", "_range" ) end
            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:116"] + __e.backtrace ) ; raise __e
          end
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._append_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_append'] = self.method( :_append_METHOD )
    @_append = 
    trampCall(
          Proc.new { |_a,_b| 
              begin
                ___lambda = lambda { |_append_MIMARKreverse| 
                    _append_MIMARKreverse                     = 
                      Proc.new { |_a,_b| 
                          if ( 
                            trampCall( self._pair_QUMARK_METHOD(  'pair?',
                                begin
                                  if @global_lisp_binding.has_key?('_pair_QUMARK') then
                                    trampCall(@_pair_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:121"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_a)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:124"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                           ) then
                              delayCall( '_append_MIMARKreverse',  'append-reverse',
                                  begin
                                      trampCall(_append_MIMARKreverse)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:124"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    trampCall( self._cdr_METHOD(  'cdr',
                                        begin
                                          if @global_lisp_binding.has_key?('_cdr') then
                                            trampCall(@_cdr)
                                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:122"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_a)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:124"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))                                  ,
                                    trampCall( self._cons_METHOD(  'cons',
                                        begin
                                          if @global_lisp_binding.has_key?('_cons') then
                                            trampCall(@_cons)
                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:122"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          trampCall( self._car_METHOD(  'car',
                                              begin
                                                if @global_lisp_binding.has_key?('_car') then
                                                  trampCall(@_car)
                                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:122"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_a)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:124"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))                                        ,
                                          begin
                                              trampCall(_b)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:124"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))
                              ]
                                           )
                          else
                              begin
                                  trampCall(_b)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:124"] + __e.backtrace ) ; raise __e
                              end
                          end
                      }
                    delayCall( '_append_MIMARKreverse',  'append-reverse',
                        begin
                            trampCall(_append_MIMARKreverse)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:124"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._reverse_METHOD(  'reverse',
                              begin
                                if @global_lisp_binding.has_key?('_reverse') then
                                  trampCall(@_reverse)
                                else raise NameError.new( "Error: undefined variable _reverse", "_reverse" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:124"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_a)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:124"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))                        ,
                          begin
                              trampCall(_b)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:124"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 )
                } ; ___lambda.call(
                nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._vector_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_vector'] = self.method( :_vector_METHOD )
    @_vector = 
    trampCall(
          Proc.new { |*__rest__| _lst = __rest__[0] ;  
              delayCall( '_to_MIMARKarr',  'to-arr',
                  begin
                    if @global_lisp_binding.has_key?('_to_MIMARKarr') then
                      trampCall(@_to_MIMARKarr)
                    else raise NameError.new( "Error: undefined variable _to_MIMARKarr", "_to_MIMARKarr" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:129"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(_lst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:129"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._list_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_list_QUMARK'] = self.method( :_list_QUMARK_METHOD )
    @_list_QUMARK = 
    trampCall(
          begin
            if @global_lisp_binding.has_key?('__PAMARKlist_QUMARK') then
              trampCall(@__PAMARKlist_QUMARK)
            else raise NameError.new( "Error: undefined variable __PAMARKlist_QUMARK", "__PAMARKlist_QUMARK" ) end
            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:130"] + __e.backtrace ) ; raise __e
          end
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._even_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_even_QUMARK'] = self.method( :_even_QUMARK_METHOD )
    @_even_QUMARK = 
    trampCall(
          Proc.new { |_n| 
              delayCall( '__EQMARK',  '=',
                  begin
                    if @global_lisp_binding.has_key?('__EQMARK') then
                      trampCall(@__EQMARK)
                    else raise NameError.new( "Error: undefined variable __EQMARK", "__EQMARK" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:131"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self.__PAMARK_METHOD(  '%',
                        begin
                          if @global_lisp_binding.has_key?('__PAMARK') then
                            trampCall(@__PAMARK)
                          else raise NameError.new( "Error: undefined variable __PAMARK", "__PAMARK" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:131"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_n)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:131"] + __e.backtrace ) ; raise __e
                          end                        ,
                        2
                    ]
                                 ))                  ,
                  0
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._odd_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_odd_QUMARK'] = self.method( :_odd_QUMARK_METHOD )
    @_odd_QUMARK = 
    trampCall(
          Proc.new { |_n| 
              delayCall( '_not',  'not',
                  begin
                    if @global_lisp_binding.has_key?('_not') then
                      trampCall(@_not)
                    else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:132"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self.__EQMARK_METHOD(  '=',
                        begin
                          if @global_lisp_binding.has_key?('__EQMARK') then
                            trampCall(@__EQMARK)
                          else raise NameError.new( "Error: undefined variable __EQMARK", "__EQMARK" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:132"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self.__PAMARK_METHOD(  '%',
                              begin
                                if @global_lisp_binding.has_key?('__PAMARK') then
                                  trampCall(@__PAMARK)
                                else raise NameError.new( "Error: undefined variable __PAMARK", "__PAMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:132"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_n)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:132"] + __e.backtrace ) ; raise __e
                                end                              ,
                              2
                          ]
                                       ))                        ,
                        0
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._zero_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_zero_QUMARK'] = self.method( :_zero_QUMARK_METHOD )
    @_zero_QUMARK = 
    trampCall(
          Proc.new { |_n| 
              delayCall( '__EQMARK',  '=',
                  begin
                    if @global_lisp_binding.has_key?('__EQMARK') then
                      trampCall(@__EQMARK)
                    else raise NameError.new( "Error: undefined variable __EQMARK", "__EQMARK" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:133"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(_n)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:133"] + __e.backtrace ) ; raise __e
                    end                  ,
                  0
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._positive_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_positive_QUMARK'] = self.method( :_positive_QUMARK_METHOD )
    @_positive_QUMARK = 
    trampCall(
          Proc.new { |_n| 
              delayCall( '__GTMARK',  '>',
                  begin
                    if @global_lisp_binding.has_key?('__GTMARK') then
                      trampCall(@__GTMARK)
                    else raise NameError.new( "Error: undefined variable __GTMARK", "__GTMARK" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:134"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(_n)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:134"] + __e.backtrace ) ; raise __e
                    end                  ,
                  0
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._negative_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_negative_QUMARK'] = self.method( :_negative_QUMARK_METHOD )
    @_negative_QUMARK = 
    trampCall(
          Proc.new { |_n| 
              delayCall( '__LTMARK',  '<',
                  begin
                    if @global_lisp_binding.has_key?('__LTMARK') then
                      trampCall(@__LTMARK)
                    else raise NameError.new( "Error: undefined variable __LTMARK", "__LTMARK" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:135"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(_n)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:135"] + __e.backtrace ) ; raise __e
                    end                  ,
                  0
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._abs_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_abs'] = self.method( :_abs_METHOD )
    @_abs = 
    trampCall(
          Proc.new { |_n| 
              if ( 
                trampCall( self.__GTMARK_EQMARK_METHOD(  '>=',
                    begin
                      if @global_lisp_binding.has_key?('__GTMARK_EQMARK') then
                        trampCall(@__GTMARK_EQMARK)
                      else raise NameError.new( "Error: undefined variable __GTMARK_EQMARK", "__GTMARK_EQMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:136"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      begin
                          trampCall(_n)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:136"] + __e.backtrace ) ; raise __e
                      end                    ,
                    0
                ]
                             ))
               ) then
                  begin
                      trampCall(_n)
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:136"] + __e.backtrace ) ; raise __e
                  end
              else
                  delayCall( '__MIMARK',  '-',
                      begin
                        if @global_lisp_binding.has_key?('__MIMARK') then
                          trampCall(@__MIMARK)
                        else raise NameError.new( "Error: undefined variable __MIMARK", "__MIMARK" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:136"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                        begin
                            trampCall(_n)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:136"] + __e.backtrace ) ; raise __e
                        end
                  ]
                               )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._max_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_max'] = self.method( :_max_METHOD )
    @_max = 
    trampCall(
          Proc.new { |*__rest__| _lst = __rest__[0] ;  
              delayCall( '_fold_MIMARKright',  'fold-right',
                  begin
                    if @global_lisp_binding.has_key?('_fold_MIMARKright') then
                      trampCall(@_fold_MIMARKright)
                    else raise NameError.new( "Error: undefined variable _fold_MIMARKright", "_fold_MIMARKright" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:138"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    Proc.new { |_a,_b| 
                        if ( 
                          trampCall( self.__GTMARK_METHOD(  '>',
                              begin
                                if @global_lisp_binding.has_key?('__GTMARK') then
                                  trampCall(@__GTMARK)
                                else raise NameError.new( "Error: undefined variable __GTMARK", "__GTMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:138"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_a)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:138"] + __e.backtrace ) ; raise __e
                                end                              ,
                                begin
                                    trampCall(_b)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:138"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                         ) then
                            begin
                                trampCall(_a)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:138"] + __e.backtrace ) ; raise __e
                            end
                        else
                            begin
                                trampCall(_b)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:138"] + __e.backtrace ) ; raise __e
                            end
                        end
                    }                  ,
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:138"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_lst)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:138"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:138"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_lst)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:138"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._min_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_min'] = self.method( :_min_METHOD )
    @_min = 
    trampCall(
          Proc.new { |*__rest__| _lst = __rest__[0] ;  
              delayCall( '_fold_MIMARKright',  'fold-right',
                  begin
                    if @global_lisp_binding.has_key?('_fold_MIMARKright') then
                      trampCall(@_fold_MIMARKright)
                    else raise NameError.new( "Error: undefined variable _fold_MIMARKright", "_fold_MIMARKright" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:140"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    Proc.new { |_a,_b| 
                        if ( 
                          trampCall( self.__LTMARK_METHOD(  '<',
                              begin
                                if @global_lisp_binding.has_key?('__LTMARK') then
                                  trampCall(@__LTMARK)
                                else raise NameError.new( "Error: undefined variable __LTMARK", "__LTMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:140"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_a)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:140"] + __e.backtrace ) ; raise __e
                                end                              ,
                                begin
                                    trampCall(_b)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:140"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                         ) then
                            begin
                                trampCall(_a)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:140"] + __e.backtrace ) ; raise __e
                            end
                        else
                            begin
                                trampCall(_b)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:140"] + __e.backtrace ) ; raise __e
                            end
                        end
                    }                  ,
                    trampCall( self._car_METHOD(  'car',
                        begin
                          if @global_lisp_binding.has_key?('_car') then
                            trampCall(@_car)
                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:140"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_lst)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:140"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._cdr_METHOD(  'cdr',
                        begin
                          if @global_lisp_binding.has_key?('_cdr') then
                            trampCall(@_cdr)
                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:140"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_lst)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:140"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._succ_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_succ'] = self.method( :_succ_METHOD )
    @_succ = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '__PLMARK',  '+',
                  begin
                    if @global_lisp_binding.has_key?('__PLMARK') then
                      trampCall(@__PLMARK)
                    else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:141"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(_x)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:141"] + __e.backtrace ) ; raise __e
                    end                  ,
                  1
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._pred_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_pred'] = self.method( :_pred_METHOD )
    @_pred = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '__MIMARK',  '-',
                  begin
                    if @global_lisp_binding.has_key?('__MIMARK') then
                      trampCall(@__MIMARK)
                    else raise NameError.new( "Error: undefined variable __MIMARK", "__MIMARK" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:142"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(_x)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:142"] + __e.backtrace ) ; raise __e
                    end                  ,
                  1
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._nth_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_nth'] = self.method( :_nth_METHOD )
    @_nth = 
    trampCall(
          Proc.new { |_n,_lst| 
              begin
                ___lambda = lambda { |_nth_MIMARKiter| 
                    _nth_MIMARKiter                     = 
                      Proc.new { |_n,_index,_lst| 
                          if ( 
                            trampCall( self._null_QUMARK_METHOD(  'null?',
                                begin
                                  if @global_lisp_binding.has_key?('_null_QUMARK') then
                                    trampCall(@_null_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:146"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_lst)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:153"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                           ) then
                            Cell.new()
                          else
                              if ( 
                                trampCall( self._not_METHOD(  'not',
                                    begin
                                      if @global_lisp_binding.has_key?('_not') then
                                        trampCall(@_not)
                                      else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:148"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      trampCall( self._pair_QUMARK_METHOD(  'pair?',
                                          begin
                                            if @global_lisp_binding.has_key?('_pair_QUMARK') then
                                              trampCall(@_pair_QUMARK)
                                            else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:148"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_lst)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:153"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                ]
                                             ))
                               ) then
                                  begin raise RuntimeError, 
                                  "Error: nth got improper list."
                                  rescue => __e 
                                    __e.set_backtrace( ["./lib/init.nnd:149"] + __e.backtrace )
                                    raise __e
                                  end 
                              else
                                  if ( 
                                    trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                        begin
                                          if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                            trampCall(@_eqv_QUMARK)
                                          else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:150"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_n)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:153"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                          begin
                                              trampCall(_index)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:152"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))
                                   ) then
                                      delayCall( '_car',  'car',
                                          begin
                                            if @global_lisp_binding.has_key?('_car') then
                                              trampCall(@_car)
                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:151"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_lst)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:153"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   )
                                  else
                                      delayCall( '_nth_MIMARKiter',  'nth-iter',
                                          begin
                                              trampCall(_nth_MIMARKiter)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:153"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_n)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:153"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                            trampCall( self.__PLMARK_METHOD(  '+',
                                                begin
                                                  if @global_lisp_binding.has_key?('__PLMARK') then
                                                    trampCall(@__PLMARK)
                                                  else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:152"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_index)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:152"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                                1
                                            ]
                                                         ))                                          ,
                                            trampCall( self._cdr_METHOD(  'cdr',
                                                begin
                                                  if @global_lisp_binding.has_key?('_cdr') then
                                                    trampCall(@_cdr)
                                                  else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:152"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_lst)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:153"] + __e.backtrace ) ; raise __e
                                                  end
                                            ]
                                                         ))
                                      ]
                                                   )
                                  end
                              end
                          end
                      }
                    delayCall( '_nth_MIMARKiter',  'nth-iter',
                        begin
                            trampCall(_nth_MIMARKiter)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:153"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_n)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:153"] + __e.backtrace ) ; raise __e
                          end                        ,
                        0                        ,
                          begin
                              trampCall(_lst)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:153"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 )
                } ; ___lambda.call(
                nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._first_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_first'] = self.method( :_first_METHOD )
    @_first = 
    trampCall(
          Proc.new { |_lst| 
              delayCall( '_nth',  'nth',
                  begin
                    if @global_lisp_binding.has_key?('_nth') then
                      trampCall(@_nth)
                    else raise NameError.new( "Error: undefined variable _nth", "_nth" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:154"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  0                  ,
                    begin
                        trampCall(_lst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:154"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._second_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_second'] = self.method( :_second_METHOD )
    @_second = 
    trampCall(
          Proc.new { |_lst| 
              delayCall( '_nth',  'nth',
                  begin
                    if @global_lisp_binding.has_key?('_nth') then
                      trampCall(@_nth)
                    else raise NameError.new( "Error: undefined variable _nth", "_nth" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:155"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  1                  ,
                    begin
                        trampCall(_lst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:155"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._third_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_third'] = self.method( :_third_METHOD )
    @_third = 
    trampCall(
          Proc.new { |_lst| 
              delayCall( '_nth',  'nth',
                  begin
                    if @global_lisp_binding.has_key?('_nth') then
                      trampCall(@_nth)
                    else raise NameError.new( "Error: undefined variable _nth", "_nth" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:156"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  2                  ,
                    begin
                        trampCall(_lst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:156"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._fourth_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_fourth'] = self.method( :_fourth_METHOD )
    @_fourth = 
    trampCall(
          Proc.new { |_lst| 
              delayCall( '_nth',  'nth',
                  begin
                    if @global_lisp_binding.has_key?('_nth') then
                      trampCall(@_nth)
                    else raise NameError.new( "Error: undefined variable _nth", "_nth" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:157"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  3                  ,
                    begin
                        trampCall(_lst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:157"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._fifth_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_fifth'] = self.method( :_fifth_METHOD )
    @_fifth = 
    trampCall(
          Proc.new { |_lst| 
              delayCall( '_nth',  'nth',
                  begin
                    if @global_lisp_binding.has_key?('_nth') then
                      trampCall(@_nth)
                    else raise NameError.new( "Error: undefined variable _nth", "_nth" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:158"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  4                  ,
                    begin
                        trampCall(_lst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:158"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._sixth_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_sixth'] = self.method( :_sixth_METHOD )
    @_sixth = 
    trampCall(
          Proc.new { |_lst| 
              delayCall( '_nth',  'nth',
                  begin
                    if @global_lisp_binding.has_key?('_nth') then
                      trampCall(@_nth)
                    else raise NameError.new( "Error: undefined variable _nth", "_nth" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:159"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  5                  ,
                    begin
                        trampCall(_lst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:159"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._seventh_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_seventh'] = self.method( :_seventh_METHOD )
    @_seventh = 
    trampCall(
          Proc.new { |_lst| 
              delayCall( '_nth',  'nth',
                  begin
                    if @global_lisp_binding.has_key?('_nth') then
                      trampCall(@_nth)
                    else raise NameError.new( "Error: undefined variable _nth", "_nth" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:160"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  6                  ,
                    begin
                        trampCall(_lst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:160"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._eighth_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_eighth'] = self.method( :_eighth_METHOD )
    @_eighth = 
    trampCall(
          Proc.new { |_lst| 
              delayCall( '_nth',  'nth',
                  begin
                    if @global_lisp_binding.has_key?('_nth') then
                      trampCall(@_nth)
                    else raise NameError.new( "Error: undefined variable _nth", "_nth" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:161"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  7                  ,
                    begin
                        trampCall(_lst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:161"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._ninth_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_ninth'] = self.method( :_ninth_METHOD )
    @_ninth = 
    trampCall(
          Proc.new { |_lst| 
              delayCall( '_nth',  'nth',
                  begin
                    if @global_lisp_binding.has_key?('_nth') then
                      trampCall(@_nth)
                    else raise NameError.new( "Error: undefined variable _nth", "_nth" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:162"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  8                  ,
                    begin
                        trampCall(_lst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:162"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._tenth_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_tenth'] = self.method( :_tenth_METHOD )
    @_tenth = 
    trampCall(
          Proc.new { |_lst| 
              delayCall( '_nth',  'nth',
                  begin
                    if @global_lisp_binding.has_key?('_nth') then
                      trampCall(@_nth)
                    else raise NameError.new( "Error: undefined variable _nth", "_nth" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:163"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  9                  ,
                    begin
                        trampCall(_lst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:163"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._x_MIMARK_GTMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_x_MIMARK_GTMARKstring'] = self.method( :_x_MIMARK_GTMARKstring_METHOD )
    @_x_MIMARK_GTMARKstring = 
    trampCall(
          Proc.new { |_object| 
              delayCall( '_to_MIMARKs',  'to-s',
                  begin
                    if @global_lisp_binding.has_key?('_to_MIMARKs') then
                      trampCall(@_to_MIMARKs)
                    else raise NameError.new( "Error: undefined variable _to_MIMARKs", "_to_MIMARKs" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:165"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(_object)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:165"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._number_MIMARK_GTMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_number_MIMARK_GTMARKstring'] = self.method( :_number_MIMARK_GTMARKstring_METHOD )
    @_number_MIMARK_GTMARKstring = 
    trampCall(
          Proc.new { |_num| 
              delayCall( '_x_MIMARK_GTMARKstring',  'x->string',
                  begin
                    if @global_lisp_binding.has_key?('_x_MIMARK_GTMARKstring') then
                      trampCall(@_x_MIMARK_GTMARKstring)
                    else raise NameError.new( "Error: undefined variable _x_MIMARK_GTMARKstring", "_x_MIMARK_GTMARKstring" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:166"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(_num)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:166"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._string_MIMARKappend_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_string_MIMARKappend'] = self.method( :_string_MIMARKappend_METHOD )
    @_string_MIMARKappend = 
    trampCall(
          Proc.new { |*__rest__| _str_MIMARKlst = __rest__[0] ;  
              delayCall( '_string_MIMARKjoin',  'string-join',
                  begin
                    if @global_lisp_binding.has_key?('_string_MIMARKjoin') then
                      trampCall(@_string_MIMARKjoin)
                    else raise NameError.new( "Error: undefined variable _string_MIMARKjoin", "_string_MIMARKjoin" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:169"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(_str_MIMARKlst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:169"] + __e.backtrace ) ; raise __e
                    end                  ,
                  ""
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._macroexpand_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_macroexpand'] = self.method( :_macroexpand_METHOD )
    @_macroexpand = 
    trampCall(
          Proc.new { |_sexp| 
              begin
                ___lambda = lambda { |_newsexp| 
                    if ( 
                      trampCall( self._not_METHOD(  'not',
                          begin
                            if @global_lisp_binding.has_key?('_not') then
                              trampCall(@_not)
                            else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:177"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            trampCall( self._equal_QUMARK_METHOD(  'equal?',
                                begin
                                  if @global_lisp_binding.has_key?('_equal_QUMARK') then
                                    trampCall(@_equal_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _equal_QUMARK", "_equal_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:177"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_sexp)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:177"] + __e.backtrace ) ; raise __e
                                  end                                ,
                                  begin
                                      trampCall(_newsexp)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:179"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                      ]
                                   ))
                     ) then
                        delayCall( '_macroexpand',  'macroexpand',
                            begin
                              if @global_lisp_binding.has_key?('_macroexpand') then
                                trampCall(@_macroexpand)
                              else raise NameError.new( "Error: undefined variable _macroexpand", "_macroexpand" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:178"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(_newsexp)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:179"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     )
                    else
                        begin
                            trampCall(_newsexp)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:179"] + __e.backtrace ) ; raise __e
                        end
                    end
                } ; ___lambda.call(
                      trampCall( self._macroexpand_MIMARK1_METHOD(  'macroexpand-1',
                          begin
                            if @global_lisp_binding.has_key?('_macroexpand_MIMARK1') then
                              trampCall(@_macroexpand_MIMARK1)
                            else raise NameError.new( "Error: undefined variable _macroexpand_MIMARK1", "_macroexpand_MIMARK1" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:176"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_sexp)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:177"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._feedto_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_feedto'] = self.method( :_feedto_METHOD )
    @_feedto = 
    trampCall(
          Proc.new { || 
              begin raise RuntimeError, 
              "=> (feedto) appeared outside cond or case."
              rescue => __e 
                __e.set_backtrace( ["./lib/init.nnd:182"] + __e.backtrace )
                raise __e
              end 
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cond_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cond'] = self.method( :_cond_METHOD )
    @_cond = 
    trampCall(
          LispMacro.new { |*__rest__| _lst = __rest__[0] ;  
              begin
                ___lambda = lambda { |_case_MIMARKblock,_cond_MIMARKiter| 
                    _case_MIMARKblock                     = 
                      Proc.new { |_elem,*__rest__| _elseblock = __rest__[0] ;  
                          begin
                            ___lambda = lambda { |_condition,_body,_tmpsym| 
                                trampCall( self._append_METHOD(  'append',
                                    begin
                                      if @global_lisp_binding.has_key?('_append') then
                                        trampCall(@_append)
                                      else raise NameError.new( "Error: undefined variable _append", "_append" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:198"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      if ( 
                                        trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                            begin
                                              if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                trampCall(@_eq_QUMARK)
                                              else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:215"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                            :"feedto"                                            ,
                                              trampCall( self._car_METHOD(  'car',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_car') then
                                                      trampCall(@_car)
                                                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:217"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                    begin
                                                        trampCall(_body)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:207"] + __e.backtrace ) ; raise __e
                                                    end
                                              ]
                                                           ))
                                        ]
                                                     ))
                                       ) then
                                          trampCall( self._cons_METHOD(  'cons',
                                              begin
                                                if @global_lisp_binding.has_key?('_cons') then
                                                  trampCall(@_cons)
                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:207"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                              :"if"                                              ,
                                                trampCall( self._list_METHOD(  'list',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_list') then
                                                        trampCall(@_list)
                                                      else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:205"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      trampCall( self._list_METHOD(  'list',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_list') then
                                                              trampCall(@_list)
                                                            else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:205"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                          :"set!"                                                          ,
                                                            begin
                                                                trampCall(_tmpsym)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:203"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                            begin
                                                                trampCall(_condition)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:206"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))                                                    ,
                                                      trampCall( self._list_METHOD(  'list',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_list') then
                                                              trampCall(@_list)
                                                            else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:205"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            trampCall( self._cadr_METHOD(  'cadr',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_cadr') then
                                                                    trampCall(@_cadr)
                                                                  else raise NameError.new( "Error: undefined variable _cadr", "_cadr" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:203"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  begin
                                                                      trampCall(_body)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:207"] + __e.backtrace ) ; raise __e
                                                                  end
                                                            ]
                                                                         ))                                                          ,
                                                            begin
                                                                trampCall(_tmpsym)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:203"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                ]
                                                             ))
                                          ]
                                                       ))
                                      else
                                          trampCall( self._cons_METHOD(  'cons',
                                              begin
                                                if @global_lisp_binding.has_key?('_cons') then
                                                  trampCall(@_cons)
                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:207"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                              :"if"                                              ,
                                                trampCall( self._list_METHOD(  'list',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_list') then
                                                        trampCall(@_list)
                                                      else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:205"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      begin
                                                          trampCall(_condition)
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:206"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                      trampCall( self._cons_METHOD(  'cons',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_cons') then
                                                              trampCall(@_cons)
                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:207"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                          :"begin"                                                          ,
                                                            begin
                                                                trampCall(_body)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:207"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                ]
                                                             ))
                                          ]
                                                       ))
                                      end                                    ,
                                      if ( 
                                        trampCall( self.__LTMARK_METHOD(  '<',
                                            begin
                                              if @global_lisp_binding.has_key?('__LTMARK') then
                                                trampCall(@__LTMARK)
                                              else raise NameError.new( "Error: undefined variable __LTMARK", "__LTMARK" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:208"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                            0                                            ,
                                              trampCall( self._length_METHOD(  'length',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_length') then
                                                      trampCall(@_length)
                                                    else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:215"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                    begin
                                                        trampCall(_elseblock)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:209"] + __e.backtrace ) ; raise __e
                                                    end
                                              ]
                                                           ))
                                        ]
                                                     ))
                                       ) then
                                          begin
                                              trampCall(_elseblock)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:209"] + __e.backtrace ) ; raise __e
                                          end
                                      else
                                        Cell.new()
                                      end
                                ]
                                             ))
                            } ; ___lambda.call(
                                  if ( 
                                    trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                        begin
                                          if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                            trampCall(@_eq_QUMARK)
                                          else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:215"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                        :"else"                                        ,
                                          trampCall( self._car_METHOD(  'car',
                                              begin
                                                if @global_lisp_binding.has_key?('_car') then
                                                  trampCall(@_car)
                                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:217"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_elem)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:193"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))
                                    ]
                                                 ))
                                   ) then
                                    true
                                  else
                                      trampCall( self._car_METHOD(  'car',
                                          begin
                                            if @global_lisp_binding.has_key?('_car') then
                                              trampCall(@_car)
                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:217"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_elem)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:193"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                  end                                ,
                                  if ( 
                                    trampCall( self._null_QUMARK_METHOD(  'null?',
                                        begin
                                          if @global_lisp_binding.has_key?('_null_QUMARK') then
                                            trampCall(@_null_QUMARK)
                                          else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:191"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          trampCall( self._cdr_METHOD(  'cdr',
                                              begin
                                                if @global_lisp_binding.has_key?('_cdr') then
                                                  trampCall(@_cdr)
                                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:218"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_elem)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:193"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))
                                    ]
                                                 ))
                                   ) then
                                    Cell.new(true)
                                  else
                                      trampCall( self._cdr_METHOD(  'cdr',
                                          begin
                                            if @global_lisp_binding.has_key?('_cdr') then
                                              trampCall(@_cdr)
                                            else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:218"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_elem)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:193"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                  end                                ,
                                  trampCall( self._gensym_METHOD(  'gensym',
                                      begin
                                        if @global_lisp_binding.has_key?('_gensym') then
                                          trampCall(@_gensym)
                                        else raise NameError.new( "Error: undefined variable _gensym", "_gensym" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:194"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                  ]
                                               ))
                                       )
                          end
                      }
                    _cond_MIMARKiter                     = 
                      Proc.new { |_lst| 
                          if ( 
                            trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                begin
                                  if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                    trampCall(@_eq_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:215"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                0                                ,
                                  trampCall( self._length_METHOD(  'length',
                                      begin
                                        if @global_lisp_binding.has_key?('_length') then
                                          trampCall(@_length)
                                        else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:215"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(_lst)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:219"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                            ]
                                         ))
                           ) then
                            Cell.new()
                          else
                              if ( 
                                trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                    begin
                                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                        trampCall(@_eq_QUMARK)
                                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:215"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                    1                                    ,
                                      trampCall( self._length_METHOD(  'length',
                                          begin
                                            if @global_lisp_binding.has_key?('_length') then
                                              trampCall(@_length)
                                            else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:215"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_lst)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:219"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                ]
                                             ))
                               ) then
                                  trampCall( callProcedure(   'case-block',
                                      begin
                                          trampCall(_case_MIMARKblock)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:217"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        trampCall( self._car_METHOD(  'car',
                                            begin
                                              if @global_lisp_binding.has_key?('_car') then
                                                trampCall(@_car)
                                              else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:217"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_lst)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:219"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))                                      ,
                                      Cell.new()
                                  ]
                                               ))
                              else
                                  trampCall( callProcedure(   'case-block',
                                      begin
                                          trampCall(_case_MIMARKblock)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:217"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        trampCall( self._car_METHOD(  'car',
                                            begin
                                              if @global_lisp_binding.has_key?('_car') then
                                                trampCall(@_car)
                                              else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:217"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_lst)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:219"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))                                      ,
                                        trampCall( callProcedure(   'cond-iter',
                                            begin
                                                trampCall(_cond_MIMARKiter)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:219"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              trampCall( self._cdr_METHOD(  'cdr',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_cdr') then
                                                      trampCall(@_cdr)
                                                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:218"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                    begin
                                                        trampCall(_lst)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:219"] + __e.backtrace ) ; raise __e
                                                    end
                                              ]
                                                           ))
                                        ]
                                                     ))
                                  ]
                                               ))
                              end
                          end
                      }
                    trampCall( callProcedure(   'cond-iter',
                        begin
                            trampCall(_cond_MIMARKiter)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:219"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_lst)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:219"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
                } ; ___lambda.call(
                nil,nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._let1_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_let1'] = self.method( :_let1_METHOD )
    @_let1 = 
    trampCall(
          LispMacro.new { |_var,_expr,*__rest__| _body = __rest__[0] ;  
              trampCall( self._append_METHOD(  'append',
                  begin
                    if @global_lisp_binding.has_key?('_append') then
                      trampCall(@_append)
                    else raise NameError.new( "Error: undefined variable _append", "_append" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:223"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:224"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        :"let"                        ,
                          trampCall( self._list_METHOD(  'list',
                              begin
                                if @global_lisp_binding.has_key?('_list') then
                                  trampCall(@_list)
                                else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:224"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._list_METHOD(  'list',
                                    begin
                                      if @global_lisp_binding.has_key?('_list') then
                                        trampCall(@_list)
                                      else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:224"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_var)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:224"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                      begin
                                          trampCall(_expr)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:224"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))                  ,
                    begin
                        trampCall(_body)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:225"] + __e.backtrace ) ; raise __e
                    end
              ]
                           ))
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._or_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_or'] = self.method( :_or_METHOD )
    @_or = 
    trampCall(
          LispMacro.new { |*__rest__| _lst = __rest__[0] ;  
              begin
                ___lambda = lambda { |_or_MIMARKiter| 
                    _or_MIMARKiter                     = 
                      Proc.new { |_lst| 
                          if ( 
                            trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                begin
                                  if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                    trampCall(@_eq_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:234"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                0                                ,
                                  trampCall( self._length_METHOD(  'length',
                                      begin
                                        if @global_lisp_binding.has_key?('_length') then
                                          trampCall(@_length)
                                        else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:234"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(_lst)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:242"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                            ]
                                         ))
                           ) then
                              begin
                                false
                              end
                          else
                              if ( 
                                trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                    begin
                                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                        trampCall(@_eq_QUMARK)
                                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:234"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                    1                                    ,
                                      trampCall( self._length_METHOD(  'length',
                                          begin
                                            if @global_lisp_binding.has_key?('_length') then
                                              trampCall(@_length)
                                            else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:234"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_lst)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:242"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                ]
                                             ))
                               ) then
                                  begin
                                      begin
                                        ___lambda = lambda { |_sym| 
                                            trampCall( self._list_METHOD(  'list',
                                                begin
                                                  if @global_lisp_binding.has_key?('_list') then
                                                    trampCall(@_list)
                                                  else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:241"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                :"let1"                                                ,
                                                  begin
                                                      trampCall(_sym)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:241"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                                  trampCall( self._car_METHOD(  'car',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_car') then
                                                          trampCall(@_car)
                                                        else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:240"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        begin
                                                            trampCall(_lst)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:242"] + __e.backtrace ) ; raise __e
                                                        end
                                                  ]
                                                               ))                                                ,
                                                  trampCall( self._list_METHOD(  'list',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_list') then
                                                          trampCall(@_list)
                                                        else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:241"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                      :"if"                                                      ,
                                                        begin
                                                            trampCall(_sym)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:241"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                        begin
                                                            trampCall(_sym)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:241"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                      false
                                                  ]
                                                               ))
                                            ]
                                                         ))
                                        } ; ___lambda.call(
                                              trampCall( self._gensym_METHOD(  'gensym',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_gensym') then
                                                      trampCall(@_gensym)
                                                    else raise NameError.new( "Error: undefined variable _gensym", "_gensym" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:239"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                              ]
                                                           ))
                                                   )
                                      end
                                  end
                              else
                                  if ( 
                                  true
                                   ) then
                                      begin
                                          begin
                                            ___lambda = lambda { |_sym| 
                                                trampCall( self._list_METHOD(  'list',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_list') then
                                                        trampCall(@_list)
                                                      else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:241"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                    :"let1"                                                    ,
                                                      begin
                                                          trampCall(_sym)
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:241"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                      trampCall( self._car_METHOD(  'car',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_car') then
                                                              trampCall(@_car)
                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:240"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_lst)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:242"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))                                                    ,
                                                      trampCall( self._list_METHOD(  'list',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_list') then
                                                              trampCall(@_list)
                                                            else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:241"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                          :"if"                                                          ,
                                                            begin
                                                                trampCall(_sym)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:241"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                            begin
                                                                trampCall(_sym)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:241"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                            trampCall( callProcedure(   'or-iter',
                                                                begin
                                                                    trampCall(_or_MIMARKiter)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:242"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  trampCall( self._cdr_METHOD(  'cdr',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('_cdr') then
                                                                          trampCall(@_cdr)
                                                                        else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:241"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        begin
                                                                            trampCall(_lst)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:242"] + __e.backtrace ) ; raise __e
                                                                        end
                                                                  ]
                                                                               ))
                                                            ]
                                                                         ))
                                                      ]
                                                                   ))
                                                ]
                                                             ))
                                            } ; ___lambda.call(
                                                  trampCall( self._gensym_METHOD(  'gensym',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_gensym') then
                                                          trampCall(@_gensym)
                                                        else raise NameError.new( "Error: undefined variable _gensym", "_gensym" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:239"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                  ]
                                                               ))
                                                       )
                                          end
                                      end
                                  else
                                      Cell.new()
                                  end
                              end
                          end
                      }
                    trampCall( callProcedure(   'or-iter',
                        begin
                            trampCall(_or_MIMARKiter)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:242"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_lst)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:242"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
                } ; ___lambda.call(
                nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._and_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_and'] = self.method( :_and_METHOD )
    @_and = 
    trampCall(
          LispMacro.new { |*__rest__| _lst = __rest__[0] ;  
              begin
                ___lambda = lambda { |_and_MIMARKiter| 
                    _and_MIMARKiter                     = 
                      Proc.new { |_lst| 
                          if ( 
                            trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                begin
                                  if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                    trampCall(@_eq_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:254"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                0                                ,
                                  trampCall( self._length_METHOD(  'length',
                                      begin
                                        if @global_lisp_binding.has_key?('_length') then
                                          trampCall(@_length)
                                        else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:251"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(_lst)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:257"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                            ]
                                         ))
                           ) then
                              begin
                                true
                              end
                          else
                              if ( 
                                trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                    begin
                                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                        trampCall(@_eq_QUMARK)
                                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:254"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                    1                                    ,
                                      trampCall( self._length_METHOD(  'length',
                                          begin
                                            if @global_lisp_binding.has_key?('_length') then
                                              trampCall(@_length)
                                            else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:251"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_lst)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:257"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                ]
                                             ))
                               ) then
                                  begin
                                      trampCall( self._car_METHOD(  'car',
                                          begin
                                            if @global_lisp_binding.has_key?('_car') then
                                              trampCall(@_car)
                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:254"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_lst)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:257"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                  end
                              else
                                  if ( 
                                  true
                                   ) then
                                      begin
                                          trampCall( self._list_METHOD(  'list',
                                              begin
                                                if @global_lisp_binding.has_key?('_list') then
                                                  trampCall(@_list)
                                                else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:254"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                              :"if"                                              ,
                                                trampCall( self._list_METHOD(  'list',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_list') then
                                                        trampCall(@_list)
                                                      else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:254"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                    :"not"                                                    ,
                                                      trampCall( self._list_METHOD(  'list',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_list') then
                                                              trampCall(@_list)
                                                            else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:254"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                          :"eq?"                                                          ,
                                                          false                                                          ,
                                                            trampCall( self._car_METHOD(  'car',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_car') then
                                                                    trampCall(@_car)
                                                                  else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:254"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  begin
                                                                      trampCall(_lst)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:257"] + __e.backtrace ) ; raise __e
                                                                  end
                                                            ]
                                                                         ))
                                                      ]
                                                                   ))
                                                ]
                                                             ))                                              ,
                                                trampCall( callProcedure(   'and-iter',
                                                    begin
                                                        trampCall(_and_MIMARKiter)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:257"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      trampCall( self._cdr_METHOD(  'cdr',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_cdr') then
                                                              trampCall(@_cdr)
                                                            else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:255"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_lst)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:257"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                ]
                                                             ))                                              ,
                                              false
                                          ]
                                                       ))
                                      end
                                  else
                                      Cell.new()
                                  end
                              end
                          end
                      }
                    trampCall( callProcedure(   'and-iter',
                        begin
                            trampCall(_and_MIMARKiter)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:257"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_lst)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:257"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
                } ; ___lambda.call(
                nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._apply_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_apply'] = self.method( :_apply_METHOD )
    @_apply = 
    trampCall(
          Proc.new { |_proc,*__rest__| _args = __rest__[0] ;  
              if ( 
                trampCall( self._null_QUMARK_METHOD(  'null?',
                    begin
                      if @global_lisp_binding.has_key?('_null_QUMARK') then
                        trampCall(@_null_QUMARK)
                      else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:261"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      begin
                          trampCall(_args)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:265"] + __e.backtrace ) ; raise __e
                      end
                ]
                             ))
               ) then
                  delayCall( '_proc',  'proc',
                      begin
                          trampCall(_proc)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:264"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                  ]
                               )
              else
                  trampCall( callProcedure( 'anonymouse', 
                      Proc.new { |_lol| 
                          trampCall( self._apply1_METHOD(  'apply1',
                              begin
                                if @global_lisp_binding.has_key?('_apply1') then
                                  trampCall(@_apply1)
                                else raise NameError.new( "Error: undefined variable _apply1", "_apply1" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:264"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_proc)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:264"] + __e.backtrace ) ; raise __e
                                end                              ,
                                trampCall( self._append_METHOD(  'append',
                                    begin
                                      if @global_lisp_binding.has_key?('_append') then
                                        trampCall(@_append)
                                      else raise NameError.new( "Error: undefined variable _append", "_append" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:264"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      trampCall( self._reverse_METHOD(  'reverse',
                                          begin
                                            if @global_lisp_binding.has_key?('_reverse') then
                                              trampCall(@_reverse)
                                            else raise NameError.new( "Error: undefined variable _reverse", "_reverse" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:265"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            trampCall( self._cdr_METHOD(  'cdr',
                                                begin
                                                  if @global_lisp_binding.has_key?('_cdr') then
                                                    trampCall(@_cdr)
                                                  else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:264"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_lol)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:264"] + __e.backtrace ) ; raise __e
                                                  end
                                            ]
                                                         ))
                                      ]
                                                   ))                                    ,
                                      trampCall( self._car_METHOD(  'car',
                                          begin
                                            if @global_lisp_binding.has_key?('_car') then
                                              trampCall(@_car)
                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:264"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_lol)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:264"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                ]
                                             ))
                          ]
                                       ))
                      }                    ,
                  [
                        trampCall( self._reverse_METHOD(  'reverse',
                            begin
                              if @global_lisp_binding.has_key?('_reverse') then
                                trampCall(@_reverse)
                              else raise NameError.new( "Error: undefined variable _reverse", "_reverse" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:265"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(_args)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:265"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     ))
                  ]
                            ))
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._quasiquote_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_quasiquote'] = self.method( :_quasiquote_METHOD )
    @_quasiquote = 
    trampCall(
          LispMacro.new { |_l| 
              begin
                ___lambda = lambda { |_mcons,_mappend,_foo| 
                    _mcons                     = 
                      Proc.new { |_f,_l,_r| 
                          if ( 
                            if ( 
                              trampCall( self._not_METHOD(  'not',
                                  begin
                                    if @global_lisp_binding.has_key?('_not') then
                                      trampCall(@_not)
                                    else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:299"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                        begin
                                          if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                            trampCall(@_eq_QUMARK)
                                          else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                        false                                        ,
                                          trampCall( self._pair_QUMARK_METHOD(  'pair?',
                                              begin
                                                if @global_lisp_binding.has_key?('_pair_QUMARK') then
                                                  trampCall(@_pair_QUMARK)
                                                else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:311"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_r)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:296"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))
                                    ]
                                                 ))
                              ]
                                           ))
                             ) then
                                if ( 
                                  trampCall( self._not_METHOD(  'not',
                                      begin
                                        if @global_lisp_binding.has_key?('_not') then
                                          trampCall(@_not)
                                        else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:299"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                            begin
                                              if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                trampCall(@_eq_QUMARK)
                                              else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                            false                                            ,
                                              trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                      trampCall(@_eq_QUMARK)
                                                    else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                    trampCall( self._car_METHOD(  'car',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_car') then
                                                            trampCall(@_car)
                                                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          begin
                                                              trampCall(_r)
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:296"] + __e.backtrace ) ; raise __e
                                                          end
                                                    ]
                                                                 ))                                                  ,
                                                  :"quote"
                                              ]
                                                           ))
                                        ]
                                                     ))
                                  ]
                                               ))
                                 ) then
                                    if ( 
                                      trampCall( self._not_METHOD(  'not',
                                          begin
                                            if @global_lisp_binding.has_key?('_not') then
                                              trampCall(@_not)
                                            else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:299"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                begin
                                                  if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                    trampCall(@_eq_QUMARK)
                                                  else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                false                                                ,
                                                  trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                          trampCall(@_eq_QUMARK)
                                                        else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        trampCall( self._car_METHOD(  'car',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_car') then
                                                                trampCall(@_car)
                                                              else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              trampCall( self._cdr_METHOD(  'cdr',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_cdr') then
                                                                      trampCall(@_cdr)
                                                                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                    begin
                                                                        trampCall(_r)
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:296"] + __e.backtrace ) ; raise __e
                                                                    end
                                                              ]
                                                                           ))
                                                        ]
                                                                     ))                                                      ,
                                                        trampCall( self._cdr_METHOD(  'cdr',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_cdr') then
                                                                trampCall(@_cdr)
                                                              else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              begin
                                                                  trampCall(_f)
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:291"] + __e.backtrace ) ; raise __e
                                                              end
                                                        ]
                                                                     ))
                                                  ]
                                                               ))
                                            ]
                                                         ))
                                      ]
                                                   ))
                                     ) then
                                        if ( 
                                          trampCall( self._not_METHOD(  'not',
                                              begin
                                                if @global_lisp_binding.has_key?('_not') then
                                                  trampCall(@_not)
                                                else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:299"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                        trampCall(@_eq_QUMARK)
                                                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                    false                                                    ,
                                                      trampCall( self._pair_QUMARK_METHOD(  'pair?',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_pair_QUMARK') then
                                                              trampCall(@_pair_QUMARK)
                                                            else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:311"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_l)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                ]
                                                             ))
                                          ]
                                                       ))
                                         ) then
                                            if ( 
                                              trampCall( self._not_METHOD(  'not',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_not') then
                                                      trampCall(@_not)
                                                    else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:299"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                    trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                            trampCall(@_eq_QUMARK)
                                                          else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                        false                                                        ,
                                                          trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                                  trampCall(@_eq_QUMARK)
                                                                else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                                trampCall( self._car_METHOD(  'car',
                                                                    begin
                                                                      if @global_lisp_binding.has_key?('_car') then
                                                                        trampCall(@_car)
                                                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                [
                                                                      begin
                                                                          trampCall(_l)
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                                                                      end
                                                                ]
                                                                             ))                                                              ,
                                                              :"quote"
                                                          ]
                                                                       ))
                                                    ]
                                                                 ))
                                              ]
                                                           ))
                                             ) then
                                                trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                        trampCall(@_eq_QUMARK)
                                                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      trampCall( self._car_METHOD(  'car',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_car') then
                                                              trampCall(@_car)
                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            trampCall( self._cdr_METHOD(  'cdr',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_cdr') then
                                                                    trampCall(@_cdr)
                                                                  else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  begin
                                                                      trampCall(_l)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                                                                  end
                                                            ]
                                                                         ))
                                                      ]
                                                                   ))                                                    ,
                                                      trampCall( self._car_METHOD(  'car',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_car') then
                                                              trampCall(@_car)
                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_f)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:291"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                ]
                                                             ))
                                            else
                                              false
                                            end
                                        else
                                          false
                                        end
                                    else
                                      false
                                    end
                                else
                                  false
                                end
                            else
                              false
                            end
                           ) then
                              if ( 
                                begin
                                  ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20160| 
                                      if ( 
                                        begin
                                            trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20160)
                                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                        end
                                       ) then
                                          begin
                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20160)
                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                          end
                                      else
                                          begin
                                            ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20161| 
                                                if ( 
                                                  begin
                                                      trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20161)
                                                    rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                  end
                                                 ) then
                                                    begin
                                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20161)
                                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                    end
                                                else
                                                    begin
                                                      ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20162| 
                                                          if ( 
                                                            begin
                                                                trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20162)
                                                              rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                            end
                                                           ) then
                                                              begin
                                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20162)
                                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                              end
                                                          else
                                                            false
                                                          end
                                                      } ; ___lambda.call(
                                                            trampCall( self._string_QUMARK_METHOD(  'string?',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_string_QUMARK') then
                                                                    trampCall(@_string_QUMARK)
                                                                  else raise NameError.new( "Error: undefined variable _string_QUMARK", "_string_QUMARK" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:300"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  begin
                                                                      trampCall(_f)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:291"] + __e.backtrace ) ; raise __e
                                                                  end
                                                            ]
                                                                         ))
                                                                 )
                                                    end
                                                end
                                            } ; ___lambda.call(
                                                  trampCall( self._number_QUMARK_METHOD(  'number?',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_number_QUMARK') then
                                                          trampCall(@_number_QUMARK)
                                                        else raise NameError.new( "Error: undefined variable _number_QUMARK", "_number_QUMARK" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:300"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        begin
                                                            trampCall(_f)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:291"] + __e.backtrace ) ; raise __e
                                                        end
                                                  ]
                                                               ))
                                                       )
                                          end
                                      end
                                  } ; ___lambda.call(
                                        trampCall( self._procedure_QUMARK_METHOD(  'procedure?',
                                            begin
                                              if @global_lisp_binding.has_key?('_procedure_QUMARK') then
                                                trampCall(@_procedure_QUMARK)
                                              else raise NameError.new( "Error: undefined variable _procedure_QUMARK", "_procedure_QUMARK" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:300"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_f)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:291"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                             )
                                end
                               ) then
                                  begin
                                      trampCall(_f)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:291"] + __e.backtrace ) ; raise __e
                                  end
                              else
                                  trampCall( self._list_METHOD(  'list',
                                      begin
                                        if @global_lisp_binding.has_key?('_list') then
                                          trampCall(@_list)
                                        else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:302"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                      :"quote"                                      ,
                                        begin
                                            trampCall(_f)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:291"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                              end
                          else
                              if ( 
                                trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                    begin
                                      if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                        trampCall(@_eqv_QUMARK)
                                      else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:284"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_l)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                      begin
                                        if @global_lisp_binding.has_key?('_vector') then
                                          trampCall(@_vector)
                                        else raise NameError.new( "Error: undefined variable _vector", "_vector" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:284"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                               ) then
                                  trampCall( self._apply_METHOD(  'apply',
                                      begin
                                        if @global_lisp_binding.has_key?('_apply') then
                                          trampCall(@_apply)
                                        else raise NameError.new( "Error: undefined variable _apply", "_apply" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:285"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(_l)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                        trampCall( self._eval_METHOD(  'eval',
                                            begin
                                              if @global_lisp_binding.has_key?('_eval') then
                                                trampCall(@_eval)
                                              else raise NameError.new( "Error: undefined variable _eval", "_eval" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:285"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_r)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:296"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                  ]
                                               ))
                              else
                                  trampCall( self._list_METHOD(  'list',
                                      begin
                                        if @global_lisp_binding.has_key?('_list') then
                                          trampCall(@_list)
                                        else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:302"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                      :"cons"                                      ,
                                        begin
                                            trampCall(_l)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                        begin
                                            trampCall(_r)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:296"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                              end
                          end
                      }
                    _mappend                     = 
                      Proc.new { |_f,_l,_r| 
                          if ( 
                            begin
                              ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20163| 
                                  if ( 
                                    begin
                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20163)
                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                    end
                                   ) then
                                      begin
                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20163)
                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                      end
                                  else
                                      begin
                                        ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20164| 
                                            if ( 
                                              begin
                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20164)
                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                              end
                                             ) then
                                                begin
                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20164)
                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                end
                                            else
                                              false
                                            end
                                        } ; ___lambda.call(
                                              if ( 
                                                trampCall( self._not_METHOD(  'not',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_not') then
                                                        trampCall(@_not)
                                                      else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:299"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                              trampCall(@_eq_QUMARK)
                                                            else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                          false                                                          ,
                                                            trampCall( self._pair_QUMARK_METHOD(  'pair?',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_pair_QUMARK') then
                                                                    trampCall(@_pair_QUMARK)
                                                                  else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:311"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  begin
                                                                      trampCall(_r)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:296"] + __e.backtrace ) ; raise __e
                                                                  end
                                                            ]
                                                                         ))
                                                      ]
                                                                   ))
                                                ]
                                                             ))
                                               ) then
                                                  if ( 
                                                    trampCall( self._not_METHOD(  'not',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_not') then
                                                            trampCall(@_not)
                                                          else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:299"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                                  trampCall(@_eq_QUMARK)
                                                                else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                              false                                                              ,
                                                                trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                                    begin
                                                                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                                        trampCall(@_eq_QUMARK)
                                                                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                [
                                                                      trampCall( self._car_METHOD(  'car',
                                                                          begin
                                                                            if @global_lisp_binding.has_key?('_car') then
                                                                              trampCall(@_car)
                                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                      [
                                                                            begin
                                                                                trampCall(_r)
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:296"] + __e.backtrace ) ; raise __e
                                                                            end
                                                                      ]
                                                                                   ))                                                                    ,
                                                                    :"quote"
                                                                ]
                                                                             ))
                                                          ]
                                                                       ))
                                                    ]
                                                                 ))
                                                   ) then
                                                      trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                              trampCall(@_eq_QUMARK)
                                                            else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            trampCall( self._car_METHOD(  'car',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_car') then
                                                                    trampCall(@_car)
                                                                  else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  trampCall( self._cdr_METHOD(  'cdr',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('_cdr') then
                                                                          trampCall(@_cdr)
                                                                        else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        begin
                                                                            trampCall(_r)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:296"] + __e.backtrace ) ; raise __e
                                                                        end
                                                                  ]
                                                                               ))
                                                            ]
                                                                         ))                                                          ,
                                                          Cell.new()
                                                      ]
                                                                   ))
                                                  else
                                                    false
                                                  end
                                              else
                                                false
                                              end
                                                   )
                                      end
                                  end
                              } ; ___lambda.call(
                                    trampCall( self._null_QUMARK_METHOD(  'null?',
                                        begin
                                          if @global_lisp_binding.has_key?('_null_QUMARK') then
                                            trampCall(@_null_QUMARK)
                                          else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:291"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          trampCall( self._cdr_METHOD(  'cdr',
                                              begin
                                                if @global_lisp_binding.has_key?('_cdr') then
                                                  trampCall(@_cdr)
                                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_f)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:291"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))
                                    ]
                                                 ))
                                         )
                            end
                           ) then
                              begin
                                  trampCall(_l)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                              end
                          else
                              trampCall( self._list_METHOD(  'list',
                                  begin
                                    if @global_lisp_binding.has_key?('_list') then
                                      trampCall(@_list)
                                    else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:302"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                  :"append"                                  ,
                                    begin
                                        trampCall(_l)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                    begin
                                        trampCall(_r)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:296"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                          end
                      }
                    _foo                     = 
                      Proc.new { |_level,_form| 
                          if ( 
                            trampCall( self._not_METHOD(  'not',
                                begin
                                  if @global_lisp_binding.has_key?('_not') then
                                    trampCall(@_not)
                                  else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:299"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  trampCall( self._pair_QUMARK_METHOD(  'pair?',
                                      begin
                                        if @global_lisp_binding.has_key?('_pair_QUMARK') then
                                          trampCall(@_pair_QUMARK)
                                        else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:311"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(_form)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                            ]
                                         ))
                           ) then
                              begin
                                  if ( 
                                    begin
                                      ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20168| 
                                          if ( 
                                            begin
                                                trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20168)
                                              rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                            end
                                           ) then
                                              begin
                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20168)
                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                              end
                                          else
                                              begin
                                                ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20169| 
                                                    if ( 
                                                      begin
                                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20169)
                                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                      end
                                                     ) then
                                                        begin
                                                            trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20169)
                                                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                        end
                                                    else
                                                        begin
                                                          ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20170| 
                                                              if ( 
                                                                begin
                                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20170)
                                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                end
                                                               ) then
                                                                  begin
                                                                      trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20170)
                                                                    rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                  end
                                                              else
                                                                false
                                                              end
                                                          } ; ___lambda.call(
                                                                trampCall( self._string_QUMARK_METHOD(  'string?',
                                                                    begin
                                                                      if @global_lisp_binding.has_key?('_string_QUMARK') then
                                                                        trampCall(@_string_QUMARK)
                                                                      else raise NameError.new( "Error: undefined variable _string_QUMARK", "_string_QUMARK" ) end
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:300"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                [
                                                                      begin
                                                                          trampCall(_form)
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                      end
                                                                ]
                                                                             ))
                                                                     )
                                                        end
                                                    end
                                                } ; ___lambda.call(
                                                      trampCall( self._number_QUMARK_METHOD(  'number?',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_number_QUMARK') then
                                                              trampCall(@_number_QUMARK)
                                                            else raise NameError.new( "Error: undefined variable _number_QUMARK", "_number_QUMARK" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:300"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_form)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                           )
                                              end
                                          end
                                      } ; ___lambda.call(
                                            trampCall( self._procedure_QUMARK_METHOD(  'procedure?',
                                                begin
                                                  if @global_lisp_binding.has_key?('_procedure_QUMARK') then
                                                    trampCall(@_procedure_QUMARK)
                                                  else raise NameError.new( "Error: undefined variable _procedure_QUMARK", "_procedure_QUMARK" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:300"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_form)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                  end
                                            ]
                                                         ))
                                                 )
                                    end
                                   ) then
                                      begin
                                          trampCall(_form)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                      end
                                  else
                                      trampCall( self._list_METHOD(  'list',
                                          begin
                                            if @global_lisp_binding.has_key?('_list') then
                                              trampCall(@_list)
                                            else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:302"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                          :"quote"                                          ,
                                            begin
                                                trampCall(_form)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                  end
                              end
                          else
                              if ( 
                                trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                    begin
                                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                        trampCall(@_eq_QUMARK)
                                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                    :"quasiquote"                                    ,
                                      trampCall( self._car_METHOD(  'car',
                                          begin
                                            if @global_lisp_binding.has_key?('_car') then
                                              trampCall(@_car)
                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_form)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                ]
                                             ))
                               ) then
                                  begin
                                      trampCall( callProcedure(   'mcons',
                                          begin
                                              trampCall(_mcons)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_form)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                          Cell.new(:"quote",Cell.new(:"quasiquote"))                                          ,
                                            trampCall( callProcedure(   'foo',
                                                begin
                                                    trampCall(_foo)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  trampCall( self.__PLMARK_METHOD(  '+',
                                                      begin
                                                        if @global_lisp_binding.has_key?('__PLMARK') then
                                                          trampCall(@__PLMARK)
                                                        else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:309"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        begin
                                                            trampCall(_level)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                      1
                                                  ]
                                                               ))                                                ,
                                                  trampCall( self._cdr_METHOD(  'cdr',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cdr') then
                                                          trampCall(@_cdr)
                                                        else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        begin
                                                            trampCall(_form)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                        end
                                                  ]
                                                               ))
                                            ]
                                                         ))
                                      ]
                                                   ))
                                  end
                              else
                                  if ( 
                                  true
                                   ) then
                                      begin
                                          if ( 
                                            trampCall( self._zero_QUMARK_METHOD(  'zero?',
                                                begin
                                                  if @global_lisp_binding.has_key?('_zero_QUMARK') then
                                                    trampCall(@_zero_QUMARK)
                                                  else raise NameError.new( "Error: undefined variable _zero_QUMARK", "_zero_QUMARK" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:306"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_level)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                  end
                                            ]
                                                         ))
                                           ) then
                                              if ( 
                                                trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                        trampCall(@_eq_QUMARK)
                                                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      trampCall( self._car_METHOD(  'car',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_car') then
                                                              trampCall(@_car)
                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_form)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))                                                    ,
                                                    :"unquote"
                                                ]
                                                             ))
                                               ) then
                                                  begin
                                                      trampCall( self._car_METHOD(  'car',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_car') then
                                                              trampCall(@_car)
                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            trampCall( self._cdr_METHOD(  'cdr',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_cdr') then
                                                                    trampCall(@_cdr)
                                                                  else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  begin
                                                                      trampCall(_form)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                  end
                                                            ]
                                                                         ))
                                                      ]
                                                                   ))
                                                  end
                                              else
                                                  if ( 
                                                    trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                            trampCall(@_eq_QUMARK)
                                                          else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          trampCall( self._car_METHOD(  'car',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_car') then
                                                                  trampCall(@_car)
                                                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                                begin
                                                                    trampCall(_form)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))                                                        ,
                                                        :"unquote-splicing"
                                                    ]
                                                                 ))
                                                   ) then
                                                      begin
                                                          trampCall( self._raise_METHOD(  'raise',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_raise') then
                                                                  trampCall(@_raise)
                                                                else raise NameError.new( "Error: undefined variable _raise", "_raise" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:309"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                                begin
                                                                    trampCall(RuntimeError)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:309"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                                trampCall( self.__PLMARK_METHOD(  '+',
                                                                    begin
                                                                      if @global_lisp_binding.has_key?('__PLMARK') then
                                                                        trampCall(@__PLMARK)
                                                                      else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:309"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                [
                                                                    "Error: Unquote-splicing wasn't in a list: "                                                                    ,
                                                                      trampCall( self._write_MIMARKto_MIMARKstring_METHOD(  'write-to-string',
                                                                          begin
                                                                            if @global_lisp_binding.has_key?('_write_MIMARKto_MIMARKstring') then
                                                                              trampCall(@_write_MIMARKto_MIMARKstring)
                                                                            else raise NameError.new( "Error: undefined variable _write_MIMARKto_MIMARKstring", "_write_MIMARKto_MIMARKstring" ) end
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:309"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                      [
                                                                            begin
                                                                                trampCall(_form)
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                            end
                                                                      ]
                                                                                   ))
                                                                ]
                                                                             ))                                                              ,
                                                                trampCall( self._sprintf_METHOD(  'sprintf',
                                                                    begin
                                                                      if @global_lisp_binding.has_key?('_sprintf') then
                                                                        trampCall(@_sprintf)
                                                                      else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:310"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                [
                                                                    "%s:%s outside list."                                                                    ,
                                                                      trampCall( self.__ASMARKFILE_ASMARK_METHOD(  '*FILE*',
                                                                          begin
                                                                            if @global_lisp_binding.has_key?('__ASMARKFILE_ASMARK') then
                                                                              trampCall(@__ASMARKFILE_ASMARK)
                                                                            else raise NameError.new( "Error: undefined variable __ASMARKFILE_ASMARK", "__ASMARKFILE_ASMARK" ) end
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:310"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                      [
                                                                      ]
                                                                                   ))                                                                    ,
                                                                      trampCall( self.__ASMARKLINE_ASMARK_METHOD(  '*LINE*',
                                                                          begin
                                                                            if @global_lisp_binding.has_key?('__ASMARKLINE_ASMARK') then
                                                                              trampCall(@__ASMARKLINE_ASMARK)
                                                                            else raise NameError.new( "Error: undefined variable __ASMARKLINE_ASMARK", "__ASMARKLINE_ASMARK" ) end
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:310"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                      [
                                                                      ]
                                                                                   ))
                                                                ]
                                                                             ))
                                                          ]
                                                                       ))
                                                      end
                                                  else
                                                      if ( 
                                                        if ( 
                                                          trampCall( self._not_METHOD(  'not',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_not') then
                                                                  trampCall(@_not)
                                                                else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:299"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                                trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                                    begin
                                                                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                                        trampCall(@_eq_QUMARK)
                                                                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                [
                                                                    false                                                                    ,
                                                                      trampCall( self._pair_QUMARK_METHOD(  'pair?',
                                                                          begin
                                                                            if @global_lisp_binding.has_key?('_pair_QUMARK') then
                                                                              trampCall(@_pair_QUMARK)
                                                                            else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:311"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                      [
                                                                            trampCall( self._car_METHOD(  'car',
                                                                                begin
                                                                                  if @global_lisp_binding.has_key?('_car') then
                                                                                    trampCall(@_car)
                                                                                  else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                                                end                                                                              ,
                                                                            [
                                                                                  begin
                                                                                      trampCall(_form)
                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                                  end
                                                                            ]
                                                                                         ))
                                                                      ]
                                                                                   ))
                                                                ]
                                                                             ))
                                                          ]
                                                                       ))
                                                         ) then
                                                            trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                                    trampCall(@_eq_QUMARK)
                                                                  else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  trampCall( self._car_METHOD(  'car',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('_car') then
                                                                          trampCall(@_car)
                                                                        else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        trampCall( self._car_METHOD(  'car',
                                                                            begin
                                                                              if @global_lisp_binding.has_key?('_car') then
                                                                                trampCall(@_car)
                                                                              else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                        [
                                                                              begin
                                                                                  trampCall(_form)
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                              end
                                                                        ]
                                                                                     ))
                                                                  ]
                                                                               ))                                                                ,
                                                                :"unquote-splicing"
                                                            ]
                                                                         ))
                                                        else
                                                          false
                                                        end
                                                       ) then
                                                          begin
                                                              trampCall( callProcedure(   'mappend',
                                                                  begin
                                                                      trampCall(_mappend)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:313"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                    begin
                                                                        trampCall(_form)
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                    trampCall( self._car_METHOD(  'car',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_car') then
                                                                            trampCall(@_car)
                                                                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          trampCall( self._cdr_METHOD(  'cdr',
                                                                              begin
                                                                                if @global_lisp_binding.has_key?('_cdr') then
                                                                                  trampCall(@_cdr)
                                                                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                          [
                                                                                trampCall( self._car_METHOD(  'car',
                                                                                    begin
                                                                                      if @global_lisp_binding.has_key?('_car') then
                                                                                        trampCall(@_car)
                                                                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                                                    end                                                                                  ,
                                                                                [
                                                                                      begin
                                                                                          trampCall(_form)
                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                                      end
                                                                                ]
                                                                                             ))
                                                                          ]
                                                                                       ))
                                                                    ]
                                                                                 ))                                                                  ,
                                                                    trampCall( callProcedure(   'foo',
                                                                        begin
                                                                            trampCall(_foo)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          begin
                                                                              trampCall(_level)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                          trampCall( self._cdr_METHOD(  'cdr',
                                                                              begin
                                                                                if @global_lisp_binding.has_key?('_cdr') then
                                                                                  trampCall(@_cdr)
                                                                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                          [
                                                                                begin
                                                                                    trampCall(_form)
                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                                end
                                                                          ]
                                                                                       ))
                                                                    ]
                                                                                 ))
                                                              ]
                                                                           ))
                                                          end
                                                      else
                                                          if ( 
                                                          true
                                                           ) then
                                                              begin
                                                                  trampCall( callProcedure(   'mcons',
                                                                      begin
                                                                          trampCall(_mcons)
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        begin
                                                                            trampCall(_form)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                        trampCall( callProcedure(   'foo',
                                                                            begin
                                                                                trampCall(_foo)
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                        [
                                                                              begin
                                                                                  trampCall(_level)
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                              trampCall( self._car_METHOD(  'car',
                                                                                  begin
                                                                                    if @global_lisp_binding.has_key?('_car') then
                                                                                      trampCall(@_car)
                                                                                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                                                  end                                                                                ,
                                                                              [
                                                                                    begin
                                                                                        trampCall(_form)
                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                                    end
                                                                              ]
                                                                                           ))
                                                                        ]
                                                                                     ))                                                                      ,
                                                                        trampCall( callProcedure(   'foo',
                                                                            begin
                                                                                trampCall(_foo)
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                        [
                                                                              begin
                                                                                  trampCall(_level)
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                              trampCall( self._cdr_METHOD(  'cdr',
                                                                                  begin
                                                                                    if @global_lisp_binding.has_key?('_cdr') then
                                                                                      trampCall(@_cdr)
                                                                                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                                  end                                                                                ,
                                                                              [
                                                                                    begin
                                                                                        trampCall(_form)
                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                                    end
                                                                              ]
                                                                                           ))
                                                                        ]
                                                                                     ))
                                                                  ]
                                                                               ))
                                                              end
                                                          else
                                                              Cell.new()
                                                          end
                                                      end
                                                  end
                                              end
                                          else
                                              if ( 
                                                trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                        trampCall(@_eq_QUMARK)
                                                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      trampCall( self._car_METHOD(  'car',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_car') then
                                                              trampCall(@_car)
                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_form)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))                                                    ,
                                                    :"unquote"
                                                ]
                                                             ))
                                               ) then
                                                  begin
                                                      trampCall( callProcedure(   'mcons',
                                                          begin
                                                              trampCall(_mcons)
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_form)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                          Cell.new(:"quote",Cell.new(:"unquote"))                                                          ,
                                                            trampCall( callProcedure(   'foo',
                                                                begin
                                                                    trampCall(_foo)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  trampCall( self.__MIMARK_METHOD(  '-',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('__MIMARK') then
                                                                          trampCall(@__MIMARK)
                                                                        else raise NameError.new( "Error: undefined variable __MIMARK", "__MIMARK" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:322"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        begin
                                                                            trampCall(_level)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                      1
                                                                  ]
                                                                               ))                                                                ,
                                                                  trampCall( self._cdr_METHOD(  'cdr',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('_cdr') then
                                                                          trampCall(@_cdr)
                                                                        else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        begin
                                                                            trampCall(_form)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                        end
                                                                  ]
                                                                               ))
                                                            ]
                                                                         ))
                                                      ]
                                                                   ))
                                                  end
                                              else
                                                  if ( 
                                                    trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                            trampCall(@_eq_QUMARK)
                                                          else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          trampCall( self._car_METHOD(  'car',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_car') then
                                                                  trampCall(@_car)
                                                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                                begin
                                                                    trampCall(_form)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))                                                        ,
                                                        :"unquote-splicing"
                                                    ]
                                                                 ))
                                                   ) then
                                                      begin
                                                          trampCall( callProcedure(   'mcons',
                                                              begin
                                                                  trampCall(_mcons)
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                                begin
                                                                    trampCall(_form)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                              Cell.new(:"quote",Cell.new(:"unquote-splicing"))                                                              ,
                                                                trampCall( callProcedure(   'foo',
                                                                    begin
                                                                        trampCall(_foo)
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                [
                                                                      trampCall( self.__MIMARK_METHOD(  '-',
                                                                          begin
                                                                            if @global_lisp_binding.has_key?('__MIMARK') then
                                                                              trampCall(@__MIMARK)
                                                                            else raise NameError.new( "Error: undefined variable __MIMARK", "__MIMARK" ) end
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:322"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                      [
                                                                            begin
                                                                                trampCall(_level)
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                          1
                                                                      ]
                                                                                   ))                                                                    ,
                                                                      trampCall( self._cdr_METHOD(  'cdr',
                                                                          begin
                                                                            if @global_lisp_binding.has_key?('_cdr') then
                                                                              trampCall(@_cdr)
                                                                            else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                      [
                                                                            begin
                                                                                trampCall(_form)
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                            end
                                                                      ]
                                                                                   ))
                                                                ]
                                                                             ))
                                                          ]
                                                                       ))
                                                      end
                                                  else
                                                      if ( 
                                                      true
                                                       ) then
                                                          begin
                                                              trampCall( callProcedure(   'mcons',
                                                                  begin
                                                                      trampCall(_mcons)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                    begin
                                                                        trampCall(_form)
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                    trampCall( callProcedure(   'foo',
                                                                        begin
                                                                            trampCall(_foo)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          begin
                                                                              trampCall(_level)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                          trampCall( self._car_METHOD(  'car',
                                                                              begin
                                                                                if @global_lisp_binding.has_key?('_car') then
                                                                                  trampCall(@_car)
                                                                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:323"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                          [
                                                                                begin
                                                                                    trampCall(_form)
                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                                end
                                                                          ]
                                                                                       ))
                                                                    ]
                                                                                 ))                                                                  ,
                                                                    trampCall( callProcedure(   'foo',
                                                                        begin
                                                                            trampCall(_foo)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          begin
                                                                              trampCall(_level)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                          trampCall( self._cdr_METHOD(  'cdr',
                                                                              begin
                                                                                if @global_lisp_binding.has_key?('_cdr') then
                                                                                  trampCall(@_cdr)
                                                                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                          [
                                                                                begin
                                                                                    trampCall(_form)
                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:324"] + __e.backtrace ) ; raise __e
                                                                                end
                                                                          ]
                                                                                       ))
                                                                    ]
                                                                                 ))
                                                              ]
                                                                           ))
                                                          end
                                                      else
                                                          Cell.new()
                                                      end
                                                  end
                                              end
                                          end
                                      end
                                  else
                                      Cell.new()
                                  end
                              end
                          end
                      }
                    trampCall( callProcedure(   'foo',
                        begin
                            trampCall(_foo)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        0                        ,
                          begin
                              trampCall(_l)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:325"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
                } ; ___lambda.call(
                nil,nil,nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._unquote_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_unquote'] = self.method( :_unquote_METHOD )
    @_unquote = 
    trampCall(
          LispMacro.new { |_lst| 
              trampCall( self._raise_METHOD(  'raise',
                  begin
                    if @global_lisp_binding.has_key?('_raise') then
                      trampCall(@_raise)
                    else raise NameError.new( "Error: undefined variable _raise", "_raise" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:329"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(RuntimeError)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:329"] + __e.backtrace ) ; raise __e
                    end                  ,
                  "Error: unquote appeared outside quasiquote"                  ,
                    trampCall( self._sprintf_METHOD(  'sprintf',
                        begin
                          if @global_lisp_binding.has_key?('_sprintf') then
                            trampCall(@_sprintf)
                          else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:329"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "%s:%s outside quasiquote"                        ,
                          trampCall( self.__ASMARKFILE_ASMARK_METHOD(  '*FILE*',
                              begin
                                if @global_lisp_binding.has_key?('__ASMARKFILE_ASMARK') then
                                  trampCall(@__ASMARKFILE_ASMARK)
                                else raise NameError.new( "Error: undefined variable __ASMARKFILE_ASMARK", "__ASMARKFILE_ASMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:329"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                          ]
                                       ))                        ,
                          trampCall( self.__ASMARKLINE_ASMARK_METHOD(  '*LINE*',
                              begin
                                if @global_lisp_binding.has_key?('__ASMARKLINE_ASMARK') then
                                  trampCall(@__ASMARKLINE_ASMARK)
                                else raise NameError.new( "Error: undefined variable __ASMARKLINE_ASMARK", "__ASMARKLINE_ASMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:329"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                          ]
                                       ))
                    ]
                                 ))
              ]
                           ))
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._unquote_MIMARKsplicing_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_unquote_MIMARKsplicing'] = self.method( :_unquote_MIMARKsplicing_METHOD )
    @_unquote_MIMARKsplicing = 
    trampCall(
          LispMacro.new { |_lst| 
              trampCall( self._raise_METHOD(  'raise',
                  begin
                    if @global_lisp_binding.has_key?('_raise') then
                      trampCall(@_raise)
                    else raise NameError.new( "Error: undefined variable _raise", "_raise" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:334"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(RuntimeError)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:334"] + __e.backtrace ) ; raise __e
                    end                  ,
                  "Error: unquote-splicing appeared outside quasiquote"                  ,
                    trampCall( self._sprintf_METHOD(  'sprintf',
                        begin
                          if @global_lisp_binding.has_key?('_sprintf') then
                            trampCall(@_sprintf)
                          else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:334"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "%s:%s outside quasiquote"                        ,
                          trampCall( self.__ASMARKFILE_ASMARK_METHOD(  '*FILE*',
                              begin
                                if @global_lisp_binding.has_key?('__ASMARKFILE_ASMARK') then
                                  trampCall(@__ASMARKFILE_ASMARK)
                                else raise NameError.new( "Error: undefined variable __ASMARKFILE_ASMARK", "__ASMARKFILE_ASMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:334"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                          ]
                                       ))                        ,
                          trampCall( self.__ASMARKLINE_ASMARK_METHOD(  '*LINE*',
                              begin
                                if @global_lisp_binding.has_key?('__ASMARKLINE_ASMARK') then
                                  trampCall(@__ASMARKLINE_ASMARK)
                                else raise NameError.new( "Error: undefined variable __ASMARKLINE_ASMARK", "__ASMARKLINE_ASMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:334"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                          ]
                                       ))
                    ]
                                 ))
              ]
                           ))
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._when_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_when'] = self.method( :_when_METHOD )
    @_when = 
    trampCall(
          LispMacro.new { |*__rest__| _form = __rest__[0] ;  
              trampCall( self._cons_METHOD(  'cons',
                  begin
                    if @global_lisp_binding.has_key?('_cons') then
                      trampCall(@_cons)
                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  :"if"                  ,
                    trampCall( self._cons_METHOD(  'cons',
                        begin
                          if @global_lisp_binding.has_key?('_cons') then
                            trampCall(@_cons)
                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:339"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_form)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:339"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))                        ,
                          trampCall( self._cons_METHOD(  'cons',
                              begin
                                if @global_lisp_binding.has_key?('_cons') then
                                  trampCall(@_cons)
                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                    :"begin"                                    ,
                                      trampCall( self._cdr_METHOD(  'cdr',
                                          begin
                                            if @global_lisp_binding.has_key?('_cdr') then
                                              trampCall(@_cdr)
                                            else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:339"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_form)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:339"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                ]
                                             ))                              ,
                              Cell.new()
                          ]
                                       ))
                    ]
                                 ))
              ]
                           ))
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._unless_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_unless'] = self.method( :_unless_METHOD )
    @_unless = 
    trampCall(
          LispMacro.new { |*__rest__| _form = __rest__[0] ;  
              trampCall( self._cons_METHOD(  'cons',
                  begin
                    if @global_lisp_binding.has_key?('_cons') then
                      trampCall(@_cons)
                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  :"if"                  ,
                    trampCall( self._cons_METHOD(  'cons',
                        begin
                          if @global_lisp_binding.has_key?('_cons') then
                            trampCall(@_cons)
                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cons_METHOD(  'cons',
                              begin
                                if @global_lisp_binding.has_key?('_cons') then
                                  trampCall(@_cons)
                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                              :"not"                              ,
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      trampCall( self._car_METHOD(  'car',
                                          begin
                                            if @global_lisp_binding.has_key?('_car') then
                                              trampCall(@_car)
                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:343"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_form)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:343"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))                                    ,
                                    Cell.new()
                                ]
                                             ))
                          ]
                                       ))                        ,
                          trampCall( self._cons_METHOD(  'cons',
                              begin
                                if @global_lisp_binding.has_key?('_cons') then
                                  trampCall(@_cons)
                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                    :"begin"                                    ,
                                      trampCall( self._cdr_METHOD(  'cdr',
                                          begin
                                            if @global_lisp_binding.has_key?('_cdr') then
                                              trampCall(@_cdr)
                                            else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:343"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_form)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:343"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                ]
                                             ))                              ,
                              Cell.new()
                          ]
                                       ))
                    ]
                                 ))
              ]
                           ))
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._while_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_while'] = self.method( :_while_METHOD )
    @_while = 
    trampCall(
          LispMacro.new { |*__rest__| _form = __rest__[0] ;  
              begin
                ___lambda = lambda { |_sym| 
                    trampCall( self._cons_METHOD(  'cons',
                        begin
                          if @global_lisp_binding.has_key?('_cons') then
                            trampCall(@_cons)
                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        :"begin"                        ,
                          trampCall( self._cons_METHOD(  'cons',
                              begin
                                if @global_lisp_binding.has_key?('_cons') then
                                  trampCall(@_cons)
                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                    :"define"                                    ,
                                      trampCall( self._cons_METHOD(  'cons',
                                          begin
                                            if @global_lisp_binding.has_key?('_cons') then
                                              trampCall(@_cons)
                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_sym)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:354"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                            trampCall( self._cons_METHOD(  'cons',
                                                begin
                                                  if @global_lisp_binding.has_key?('_cons') then
                                                    trampCall(@_cons)
                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  trampCall( self._cons_METHOD(  'cons',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cons') then
                                                          trampCall(@_cons)
                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                      :"lambda"                                                      ,
                                                        trampCall( self._cons_METHOD(  'cons',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                trampCall(@_cons)
                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                            Cell.new()                                                            ,
                                                              trampCall( self._cons_METHOD(  'cons',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                      trampCall(@_cons)
                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                    trampCall( self._cons_METHOD(  'cons',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_cons') then
                                                                            trampCall(@_cons)
                                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                        :"if"                                                                        ,
                                                                          trampCall( self._cons_METHOD(  'cons',
                                                                              begin
                                                                                if @global_lisp_binding.has_key?('_cons') then
                                                                                  trampCall(@_cons)
                                                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                          [
                                                                                trampCall( self._car_METHOD(  'car',
                                                                                    begin
                                                                                      if @global_lisp_binding.has_key?('_car') then
                                                                                        trampCall(@_car)
                                                                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:351"] + __e.backtrace ) ; raise __e
                                                                                    end                                                                                  ,
                                                                                [
                                                                                      begin
                                                                                          trampCall(_form)
                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:352"] + __e.backtrace ) ; raise __e
                                                                                      end
                                                                                ]
                                                                                             ))                                                                              ,
                                                                                trampCall( self._cons_METHOD(  'cons',
                                                                                    begin
                                                                                      if @global_lisp_binding.has_key?('_cons') then
                                                                                        trampCall(@_cons)
                                                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                                    end                                                                                  ,
                                                                                [
                                                                                      trampCall( self._cons_METHOD(  'cons',
                                                                                          begin
                                                                                            if @global_lisp_binding.has_key?('_cons') then
                                                                                              trampCall(@_cons)
                                                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                                          end                                                                                        ,
                                                                                      [
                                                                                          :"begin"                                                                                          ,
                                                                                            trampCall( self._append_METHOD(  'append',
                                                                                                begin
                                                                                                  if @global_lisp_binding.has_key?('_append') then
                                                                                                    trampCall(@_append)
                                                                                                  else raise NameError.new( "Error: undefined variable _append", "_append" ) end
                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:296"] + __e.backtrace ) ; raise __e
                                                                                                end                                                                                              ,
                                                                                            [
                                                                                                  trampCall( self._cdr_METHOD(  'cdr',
                                                                                                      begin
                                                                                                        if @global_lisp_binding.has_key?('_cdr') then
                                                                                                          trampCall(@_cdr)
                                                                                                        else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:352"] + __e.backtrace ) ; raise __e
                                                                                                      end                                                                                                    ,
                                                                                                  [
                                                                                                        begin
                                                                                                            trampCall(_form)
                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:352"] + __e.backtrace ) ; raise __e
                                                                                                        end
                                                                                                  ]
                                                                                                               ))                                                                                                ,
                                                                                                  trampCall( self._cons_METHOD(  'cons',
                                                                                                      begin
                                                                                                        if @global_lisp_binding.has_key?('_cons') then
                                                                                                          trampCall(@_cons)
                                                                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                                                      end                                                                                                    ,
                                                                                                  [
                                                                                                        trampCall( self._cons_METHOD(  'cons',
                                                                                                            begin
                                                                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                                                                trampCall(@_cons)
                                                                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                                                            end                                                                                                          ,
                                                                                                        [
                                                                                                              begin
                                                                                                                  trampCall(_sym)
                                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:354"] + __e.backtrace ) ; raise __e
                                                                                                              end                                                                                                            ,
                                                                                                            Cell.new()
                                                                                                        ]
                                                                                                                     ))                                                                                                      ,
                                                                                                      Cell.new()
                                                                                                  ]
                                                                                                               ))
                                                                                            ]
                                                                                                         ))
                                                                                      ]
                                                                                                   ))                                                                                    ,
                                                                                    Cell.new()
                                                                                ]
                                                                                             ))
                                                                          ]
                                                                                       ))
                                                                    ]
                                                                                 ))                                                                  ,
                                                                  Cell.new()
                                                              ]
                                                                           ))
                                                        ]
                                                                     ))
                                                  ]
                                                               ))                                                ,
                                                Cell.new()
                                            ]
                                                         ))
                                      ]
                                                   ))
                                ]
                                             ))                              ,
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      trampCall( self._cons_METHOD(  'cons',
                                          begin
                                            if @global_lisp_binding.has_key?('_cons') then
                                              trampCall(@_cons)
                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_sym)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:354"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                          Cell.new()
                                      ]
                                                   ))                                    ,
                                    Cell.new()
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
                } ; ___lambda.call(
                      trampCall( self._gensym_METHOD(  'gensym',
                          begin
                            if @global_lisp_binding.has_key?('_gensym') then
                              trampCall(@_gensym)
                            else raise NameError.new( "Error: undefined variable _gensym", "_gensym" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:347"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                      ]
                                   ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._until_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_until'] = self.method( :_until_METHOD )
    @_until = 
    trampCall(
          LispMacro.new { |*__rest__| _form = __rest__[0] ;  
              trampCall( self._cons_METHOD(  'cons',
                  begin
                    if @global_lisp_binding.has_key?('_cons') then
                      trampCall(@_cons)
                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  :"while"                  ,
                    trampCall( self._cons_METHOD(  'cons',
                        begin
                          if @global_lisp_binding.has_key?('_cons') then
                            trampCall(@_cons)
                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cons_METHOD(  'cons',
                              begin
                                if @global_lisp_binding.has_key?('_cons') then
                                  trampCall(@_cons)
                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                              :"not"                              ,
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      trampCall( self._car_METHOD(  'car',
                                          begin
                                            if @global_lisp_binding.has_key?('_car') then
                                              trampCall(@_car)
                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:358"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_form)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:359"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))                                    ,
                                    Cell.new()
                                ]
                                             ))
                          ]
                                       ))                        ,
                          trampCall( self._cdr_METHOD(  'cdr',
                              begin
                                if @global_lisp_binding.has_key?('_cdr') then
                                  trampCall(@_cdr)
                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:359"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_form)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:359"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                    ]
                                 ))
              ]
                           ))
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._let_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_let'] = self.method( :_let_METHOD )
    @_let = 
    trampCall(
          LispMacro.new { |*__rest__| _lst = __rest__[0] ;  
              if ( 
                trampCall( self._symbol_QUMARK_METHOD(  'symbol?',
                    begin
                      if @global_lisp_binding.has_key?('_symbol_QUMARK') then
                        trampCall(@_symbol_QUMARK)
                      else raise NameError.new( "Error: undefined variable _symbol_QUMARK", "_symbol_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:364"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      trampCall( self._car_METHOD(  'car',
                          begin
                            if @global_lisp_binding.has_key?('_car') then
                              trampCall(@_car)
                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:364"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_lst)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:379"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                ]
                             ))
               ) then
                  trampCall( self._cons_METHOD(  'cons',
                      begin
                        if @global_lisp_binding.has_key?('_cons') then
                          trampCall(@_cons)
                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                      :"letrec"                      ,
                        trampCall( self._cons_METHOD(  'cons',
                            begin
                              if @global_lisp_binding.has_key?('_cons') then
                                trampCall(@_cons)
                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              trampCall( self._cons_METHOD(  'cons',
                                  begin
                                    if @global_lisp_binding.has_key?('_cons') then
                                      trampCall(@_cons)
                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    trampCall( self._cons_METHOD(  'cons',
                                        begin
                                          if @global_lisp_binding.has_key?('_cons') then
                                            trampCall(@_cons)
                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          trampCall( self._first_METHOD(  'first',
                                              begin
                                                if @global_lisp_binding.has_key?('_first') then
                                                  trampCall(@_first)
                                                else raise NameError.new( "Error: undefined variable _first", "_first" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:372"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_lst)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:379"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))                                        ,
                                          trampCall( self._cons_METHOD(  'cons',
                                              begin
                                                if @global_lisp_binding.has_key?('_cons') then
                                                  trampCall(@_cons)
                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                trampCall( self._cons_METHOD(  'cons',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_cons') then
                                                        trampCall(@_cons)
                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                    :"lambda"                                                    ,
                                                      trampCall( self._cons_METHOD(  'cons',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_cons') then
                                                              trampCall(@_cons)
                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            trampCall( self._map_METHOD(  'map',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_map') then
                                                                    trampCall(@_map)
                                                                  else raise NameError.new( "Error: undefined variable _map", "_map" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:373"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  Proc.new { |_x| 
                                                                      trampCall( self._first_METHOD(  'first',
                                                                          begin
                                                                            if @global_lisp_binding.has_key?('_first') then
                                                                              trampCall(@_first)
                                                                            else raise NameError.new( "Error: undefined variable _first", "_first" ) end
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:372"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                      [
                                                                            begin
                                                                                trampCall(_x)
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:375"] + __e.backtrace ) ; raise __e
                                                                            end
                                                                      ]
                                                                                   ))
                                                                  }                                                                ,
                                                                  trampCall( self._second_METHOD(  'second',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('_second') then
                                                                          trampCall(@_second)
                                                                        else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:376"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        begin
                                                                            trampCall(_lst)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:379"] + __e.backtrace ) ; raise __e
                                                                        end
                                                                  ]
                                                                               ))
                                                            ]
                                                                         ))                                                          ,
                                                            trampCall( self._cddr_METHOD(  'cddr',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_cddr') then
                                                                    trampCall(@_cddr)
                                                                  else raise NameError.new( "Error: undefined variable _cddr", "_cddr" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:371"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  begin
                                                                      trampCall(_lst)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:379"] + __e.backtrace ) ; raise __e
                                                                  end
                                                            ]
                                                                         ))
                                                      ]
                                                                   ))
                                                ]
                                                             ))                                              ,
                                              Cell.new()
                                          ]
                                                       ))
                                    ]
                                                 ))                                  ,
                                  Cell.new()
                              ]
                                           ))                            ,
                              trampCall( self._cons_METHOD(  'cons',
                                  begin
                                    if @global_lisp_binding.has_key?('_cons') then
                                      trampCall(@_cons)
                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    trampCall( self._cons_METHOD(  'cons',
                                        begin
                                          if @global_lisp_binding.has_key?('_cons') then
                                            trampCall(@_cons)
                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          trampCall( self._first_METHOD(  'first',
                                              begin
                                                if @global_lisp_binding.has_key?('_first') then
                                                  trampCall(@_first)
                                                else raise NameError.new( "Error: undefined variable _first", "_first" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:372"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_lst)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:379"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))                                        ,
                                          trampCall( self._map_METHOD(  'map',
                                              begin
                                                if @global_lisp_binding.has_key?('_map') then
                                                  trampCall(@_map)
                                                else raise NameError.new( "Error: undefined variable _map", "_map" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:373"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                Proc.new { |_x| 
                                                    trampCall( self._second_METHOD(  'second',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_second') then
                                                            trampCall(@_second)
                                                          else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:376"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          begin
                                                              trampCall(_x)
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:375"] + __e.backtrace ) ; raise __e
                                                          end
                                                    ]
                                                                 ))
                                                }                                              ,
                                                trampCall( self._second_METHOD(  'second',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_second') then
                                                        trampCall(@_second)
                                                      else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:376"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      begin
                                                          trampCall(_lst)
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:379"] + __e.backtrace ) ; raise __e
                                                      end
                                                ]
                                                             ))
                                          ]
                                                       ))
                                    ]
                                                 ))                                  ,
                                  Cell.new()
                              ]
                                           ))
                        ]
                                     ))
                  ]
                               ))
              else
                  trampCall( self._cons_METHOD(  'cons',
                      begin
                        if @global_lisp_binding.has_key?('_cons') then
                          trampCall(@_cons)
                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                      :"let"                      ,
                        begin
                            trampCall(_lst)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:379"] + __e.backtrace ) ; raise __e
                        end
                  ]
                               ))
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._if_MIMARKlet1_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_if_MIMARKlet1'] = self.method( :_if_MIMARKlet1_METHOD )
    @_if_MIMARKlet1 = 
    trampCall(
          LispMacro.new { |_var,__expr,__then,*__rest__| __else = __rest__[0] ;  
              trampCall( self._cons_METHOD(  'cons',
                  begin
                    if @global_lisp_binding.has_key?('_cons') then
                      trampCall(@_cons)
                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  :"let1"                  ,
                    trampCall( self._cons_METHOD(  'cons',
                        begin
                          if @global_lisp_binding.has_key?('_cons') then
                            trampCall(@_cons)
                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_var)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:384"] + __e.backtrace ) ; raise __e
                          end                        ,
                          trampCall( self._cons_METHOD(  'cons',
                              begin
                                if @global_lisp_binding.has_key?('_cons') then
                                  trampCall(@_cons)
                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(__expr)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:383"] + __e.backtrace ) ; raise __e
                                end                              ,
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      trampCall( self._cons_METHOD(  'cons',
                                          begin
                                            if @global_lisp_binding.has_key?('_cons') then
                                              trampCall(@_cons)
                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                          :"if"                                          ,
                                            trampCall( self._cons_METHOD(  'cons',
                                                begin
                                                  if @global_lisp_binding.has_key?('_cons') then
                                                    trampCall(@_cons)
                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_var)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:384"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                                  trampCall( self._cons_METHOD(  'cons',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cons') then
                                                          trampCall(@_cons)
                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        begin
                                                            trampCall(__then)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:384"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                        begin
                                                            trampCall(__else)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:384"] + __e.backtrace ) ; raise __e
                                                        end
                                                  ]
                                                               ))
                                            ]
                                                         ))
                                      ]
                                                   ))                                    ,
                                    Cell.new()
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
              ]
                           ))
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._errorf_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_errorf'] = self.method( :_errorf_METHOD )
    @_errorf = 
    trampCall(
          LispMacro.new { |_format,*__rest__| _args = __rest__[0] ;  
              trampCall( self._cons_METHOD(  'cons',
                  begin
                    if @global_lisp_binding.has_key?('_cons') then
                      trampCall(@_cons)
                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  :"error"                  ,
                    trampCall( self._cons_METHOD(  'cons',
                        begin
                          if @global_lisp_binding.has_key?('_cons') then
                            trampCall(@_cons)
                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cons_METHOD(  'cons',
                              begin
                                if @global_lisp_binding.has_key?('_cons') then
                                  trampCall(@_cons)
                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                              :"sprintf"                              ,
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_format)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:393"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                      begin
                                          trampCall(_args)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:393"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))                        ,
                        Cell.new()
                    ]
                                 ))
              ]
                           ))
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._get_MIMARKoptional_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_get_MIMARKoptional'] = self.method( :_get_MIMARKoptional_METHOD )
    @_get_MIMARKoptional = 
    trampCall(
          LispMacro.new { |_restarg,_default| 
              begin
                ___lambda = lambda { |__restarg| 
                    trampCall( self._cons_METHOD(  'cons',
                        begin
                          if @global_lisp_binding.has_key?('_cons') then
                            trampCall(@_cons)
                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        :"let1"                        ,
                          trampCall( self._cons_METHOD(  'cons',
                              begin
                                if @global_lisp_binding.has_key?('_cons') then
                                  trampCall(@_cons)
                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(__restarg)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:405"] + __e.backtrace ) ; raise __e
                                end                              ,
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_restarg)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:402"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                      trampCall( self._cons_METHOD(  'cons',
                                          begin
                                            if @global_lisp_binding.has_key?('_cons') then
                                              trampCall(@_cons)
                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            trampCall( self._cons_METHOD(  'cons',
                                                begin
                                                  if @global_lisp_binding.has_key?('_cons') then
                                                    trampCall(@_cons)
                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                :"if"                                                ,
                                                  trampCall( self._cons_METHOD(  'cons',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cons') then
                                                          trampCall(@_cons)
                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        trampCall( self._cons_METHOD(  'cons',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                trampCall(@_cons)
                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                            :"null?"                                                            ,
                                                              trampCall( self._cons_METHOD(  'cons',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                      trampCall(@_cons)
                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                    begin
                                                                        trampCall(__restarg)
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:405"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                  Cell.new()
                                                              ]
                                                                           ))
                                                        ]
                                                                     ))                                                      ,
                                                        trampCall( self._cons_METHOD(  'cons',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                trampCall(@_cons)
                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              begin
                                                                  trampCall(_default)
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:404"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                              trampCall( self._cons_METHOD(  'cons',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                      trampCall(@_cons)
                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                    trampCall( self._cons_METHOD(  'cons',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_cons') then
                                                                            trampCall(@_cons)
                                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                        :"car"                                                                        ,
                                                                          trampCall( self._cons_METHOD(  'cons',
                                                                              begin
                                                                                if @global_lisp_binding.has_key?('_cons') then
                                                                                  trampCall(@_cons)
                                                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                          [
                                                                                begin
                                                                                    trampCall(__restarg)
                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:405"] + __e.backtrace ) ; raise __e
                                                                                end                                                                              ,
                                                                              Cell.new()
                                                                          ]
                                                                                       ))
                                                                    ]
                                                                                 ))                                                                  ,
                                                                  Cell.new()
                                                              ]
                                                                           ))
                                                        ]
                                                                     ))
                                                  ]
                                                               ))
                                            ]
                                                         ))                                          ,
                                          Cell.new()
                                      ]
                                                   ))
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
                } ; ___lambda.call(
                      trampCall( self._gensym_METHOD(  'gensym',
                          begin
                            if @global_lisp_binding.has_key?('_gensym') then
                              trampCall(@_gensym)
                            else raise NameError.new( "Error: undefined variable _gensym", "_gensym" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:401"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                      ]
                                   ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._check_MIMARKarg_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_check_MIMARKarg'] = self.method( :_check_MIMARKarg_METHOD )
    @_check_MIMARKarg = 
    trampCall(
          LispMacro.new { |_a,_b,*__rest__| _c = __rest__[0] ;  
            Cell.new(:"begin")
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._do_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_do'] = self.method( :_do_METHOD )
    @_do = 
    trampCall(
          LispMacro.new { |*__rest__| _do_MIMARKmacro = __rest__[0] ;  
              trampCall( self._apply_METHOD(  'apply',
                  begin
                    if @global_lisp_binding.has_key?('_apply') then
                      trampCall(@_apply)
                    else raise NameError.new( "Error: undefined variable _apply", "_apply" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:421"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    Proc.new { |_vars,_endtest,*__rest__| _body = __rest__[0] ;  
                        begin
                          ___lambda = lambda { |_do_MIMARKloop| 
                              trampCall( self._cons_METHOD(  'cons',
                                  begin
                                    if @global_lisp_binding.has_key?('_cons') then
                                      trampCall(@_cons)
                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                  :"letrec"                                  ,
                                    trampCall( self._cons_METHOD(  'cons',
                                        begin
                                          if @global_lisp_binding.has_key?('_cons') then
                                            trampCall(@_cons)
                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          trampCall( self._cons_METHOD(  'cons',
                                              begin
                                                if @global_lisp_binding.has_key?('_cons') then
                                                  trampCall(@_cons)
                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                trampCall( self._cons_METHOD(  'cons',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_cons') then
                                                        trampCall(@_cons)
                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      begin
                                                          trampCall(_do_MIMARKloop)
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:438"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                      trampCall( self._cons_METHOD(  'cons',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_cons') then
                                                              trampCall(@_cons)
                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            trampCall( self._cons_METHOD(  'cons',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_cons') then
                                                                    trampCall(@_cons)
                                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                :"lambda"                                                                ,
                                                                  trampCall( self._cons_METHOD(  'cons',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('_cons') then
                                                                          trampCall(@_cons)
                                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        trampCall( self._map_METHOD(  'map',
                                                                            begin
                                                                              if @global_lisp_binding.has_key?('_map') then
                                                                                trampCall(@_map)
                                                                              else raise NameError.new( "Error: undefined variable _map", "_map" ) end
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:439"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                        [
                                                                              Proc.new { |_x| 
                                                                                  if ( 
                                                                                    trampCall( self._pair_QUMARK_METHOD(  'pair?',
                                                                                        begin
                                                                                          if @global_lisp_binding.has_key?('_pair_QUMARK') then
                                                                                            trampCall(@_pair_QUMARK)
                                                                                          else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:440"] + __e.backtrace ) ; raise __e
                                                                                        end                                                                                      ,
                                                                                    [
                                                                                          begin
                                                                                              trampCall(_x)
                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                          end
                                                                                    ]
                                                                                                 ))
                                                                                   ) then
                                                                                      trampCall( self._car_METHOD(  'car',
                                                                                          begin
                                                                                            if @global_lisp_binding.has_key?('_car') then
                                                                                              trampCall(@_car)
                                                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                          end                                                                                        ,
                                                                                      [
                                                                                            begin
                                                                                                trampCall(_x)
                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                            end
                                                                                      ]
                                                                                                   ))
                                                                                  else
                                                                                      begin
                                                                                          trampCall(_x)
                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                      end
                                                                                  end
                                                                              }                                                                            ,
                                                                              begin
                                                                                  trampCall(_vars)
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:443"] + __e.backtrace ) ; raise __e
                                                                              end
                                                                        ]
                                                                                     ))                                                                      ,
                                                                        trampCall( self._cons_METHOD(  'cons',
                                                                            begin
                                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                                trampCall(@_cons)
                                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                        [
                                                                              trampCall( self._cons_METHOD(  'cons',
                                                                                  begin
                                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                                      trampCall(@_cons)
                                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                                  end                                                                                ,
                                                                              [
                                                                                  :"if"                                                                                  ,
                                                                                    trampCall( self._cons_METHOD(  'cons',
                                                                                        begin
                                                                                          if @global_lisp_binding.has_key?('_cons') then
                                                                                            trampCall(@_cons)
                                                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                                        end                                                                                      ,
                                                                                    [
                                                                                          trampCall( self._car_METHOD(  'car',
                                                                                              begin
                                                                                                if @global_lisp_binding.has_key?('_car') then
                                                                                                  trampCall(@_car)
                                                                                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                              end                                                                                            ,
                                                                                          [
                                                                                                begin
                                                                                                    trampCall(_endtest)
                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:428"] + __e.backtrace ) ; raise __e
                                                                                                end
                                                                                          ]
                                                                                                       ))                                                                                        ,
                                                                                          trampCall( self._cons_METHOD(  'cons',
                                                                                              begin
                                                                                                if @global_lisp_binding.has_key?('_cons') then
                                                                                                  trampCall(@_cons)
                                                                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                                              end                                                                                            ,
                                                                                          [
                                                                                                trampCall( self._cons_METHOD(  'cons',
                                                                                                    begin
                                                                                                      if @global_lisp_binding.has_key?('_cons') then
                                                                                                        trampCall(@_cons)
                                                                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                                                    end                                                                                                  ,
                                                                                                [
                                                                                                    :"begin"                                                                                                    ,
                                                                                                      trampCall( self._cdr_METHOD(  'cdr',
                                                                                                          begin
                                                                                                            if @global_lisp_binding.has_key?('_cdr') then
                                                                                                              trampCall(@_cdr)
                                                                                                            else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                                          end                                                                                                        ,
                                                                                                      [
                                                                                                            begin
                                                                                                                trampCall(_endtest)
                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:428"] + __e.backtrace ) ; raise __e
                                                                                                            end
                                                                                                      ]
                                                                                                                   ))
                                                                                                ]
                                                                                                             ))                                                                                              ,
                                                                                                trampCall( self._cons_METHOD(  'cons',
                                                                                                    begin
                                                                                                      if @global_lisp_binding.has_key?('_cons') then
                                                                                                        trampCall(@_cons)
                                                                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                                                    end                                                                                                  ,
                                                                                                [
                                                                                                      trampCall( self._cons_METHOD(  'cons',
                                                                                                          begin
                                                                                                            if @global_lisp_binding.has_key?('_cons') then
                                                                                                              trampCall(@_cons)
                                                                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                                                          end                                                                                                        ,
                                                                                                      [
                                                                                                          :"begin"                                                                                                          ,
                                                                                                            trampCall( self._append_METHOD(  'append',
                                                                                                                begin
                                                                                                                  if @global_lisp_binding.has_key?('_append') then
                                                                                                                    trampCall(@_append)
                                                                                                                  else raise NameError.new( "Error: undefined variable _append", "_append" ) end
                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:296"] + __e.backtrace ) ; raise __e
                                                                                                                end                                                                                                              ,
                                                                                                            [
                                                                                                                  begin
                                                                                                                      trampCall(_body)
                                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:430"] + __e.backtrace ) ; raise __e
                                                                                                                  end                                                                                                                ,
                                                                                                                  trampCall( self._cons_METHOD(  'cons',
                                                                                                                      begin
                                                                                                                        if @global_lisp_binding.has_key?('_cons') then
                                                                                                                          trampCall(@_cons)
                                                                                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                                                                      end                                                                                                                    ,
                                                                                                                  [
                                                                                                                        trampCall( self._cons_METHOD(  'cons',
                                                                                                                            begin
                                                                                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                                                                                trampCall(@_cons)
                                                                                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                                                                                            end                                                                                                                          ,
                                                                                                                        [
                                                                                                                              begin
                                                                                                                                  trampCall(_do_MIMARKloop)
                                                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:438"] + __e.backtrace ) ; raise __e
                                                                                                                              end                                                                                                                            ,
                                                                                                                              trampCall( self._map_METHOD(  'map',
                                                                                                                                  begin
                                                                                                                                    if @global_lisp_binding.has_key?('_map') then
                                                                                                                                      trampCall(@_map)
                                                                                                                                    else raise NameError.new( "Error: undefined variable _map", "_map" ) end
                                                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:439"] + __e.backtrace ) ; raise __e
                                                                                                                                  end                                                                                                                                ,
                                                                                                                              [
                                                                                                                                    Proc.new { |_x| 
                                                                                                                                        if ( 
                                                                                                                                          trampCall( self._not_METHOD(  'not',
                                                                                                                                              begin
                                                                                                                                                if @global_lisp_binding.has_key?('_not') then
                                                                                                                                                  trampCall(@_not)
                                                                                                                                                else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:434"] + __e.backtrace ) ; raise __e
                                                                                                                                              end                                                                                                                                            ,
                                                                                                                                          [
                                                                                                                                                trampCall( self._pair_QUMARK_METHOD(  'pair?',
                                                                                                                                                    begin
                                                                                                                                                      if @global_lisp_binding.has_key?('_pair_QUMARK') then
                                                                                                                                                        trampCall(@_pair_QUMARK)
                                                                                                                                                      else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                                                                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:440"] + __e.backtrace ) ; raise __e
                                                                                                                                                    end                                                                                                                                                  ,
                                                                                                                                                [
                                                                                                                                                      begin
                                                                                                                                                          trampCall(_x)
                                                                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                                                                                      end
                                                                                                                                                ]
                                                                                                                                                             ))
                                                                                                                                          ]
                                                                                                                                                       ))
                                                                                                                                         ) then
                                                                                                                                            begin
                                                                                                                                                begin
                                                                                                                                                    trampCall(_x)
                                                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                                                                                end
                                                                                                                                            end
                                                                                                                                        else
                                                                                                                                            if ( 
                                                                                                                                              trampCall( self.__LTMARK_METHOD(  '<',
                                                                                                                                                  begin
                                                                                                                                                    if @global_lisp_binding.has_key?('__LTMARK') then
                                                                                                                                                      trampCall(@__LTMARK)
                                                                                                                                                    else raise NameError.new( "Error: undefined variable __LTMARK", "__LTMARK" ) end
                                                                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:435"] + __e.backtrace ) ; raise __e
                                                                                                                                                  end                                                                                                                                                ,
                                                                                                                                              [
                                                                                                                                                    trampCall( self._length_METHOD(  'length',
                                                                                                                                                        begin
                                                                                                                                                          if @global_lisp_binding.has_key?('_length') then
                                                                                                                                                            trampCall(@_length)
                                                                                                                                                          else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                                                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:435"] + __e.backtrace ) ; raise __e
                                                                                                                                                        end                                                                                                                                                      ,
                                                                                                                                                    [
                                                                                                                                                          begin
                                                                                                                                                              trampCall(_x)
                                                                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                                                                                          end
                                                                                                                                                    ]
                                                                                                                                                                 ))                                                                                                                                                  ,
                                                                                                                                                  3
                                                                                                                                              ]
                                                                                                                                                           ))
                                                                                                                                             ) then
                                                                                                                                                begin
                                                                                                                                                    trampCall( self._car_METHOD(  'car',
                                                                                                                                                        begin
                                                                                                                                                          if @global_lisp_binding.has_key?('_car') then
                                                                                                                                                            trampCall(@_car)
                                                                                                                                                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                                                                                        end                                                                                                                                                      ,
                                                                                                                                                    [
                                                                                                                                                          begin
                                                                                                                                                              trampCall(_x)
                                                                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                                                                                          end
                                                                                                                                                    ]
                                                                                                                                                                 ))
                                                                                                                                                end
                                                                                                                                            else
                                                                                                                                                if ( 
                                                                                                                                                true
                                                                                                                                                 ) then
                                                                                                                                                    begin
                                                                                                                                                        trampCall( self._car_METHOD(  'car',
                                                                                                                                                            begin
                                                                                                                                                              if @global_lisp_binding.has_key?('_car') then
                                                                                                                                                                trampCall(@_car)
                                                                                                                                                              else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                                                                                            end                                                                                                                                                          ,
                                                                                                                                                        [
                                                                                                                                                              trampCall( self._cdr_METHOD(  'cdr',
                                                                                                                                                                  begin
                                                                                                                                                                    if @global_lisp_binding.has_key?('_cdr') then
                                                                                                                                                                      trampCall(@_cdr)
                                                                                                                                                                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                                                                                                  end                                                                                                                                                                ,
                                                                                                                                                              [
                                                                                                                                                                    trampCall( self._cdr_METHOD(  'cdr',
                                                                                                                                                                        begin
                                                                                                                                                                          if @global_lisp_binding.has_key?('_cdr') then
                                                                                                                                                                            trampCall(@_cdr)
                                                                                                                                                                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                                                                                                        end                                                                                                                                                                      ,
                                                                                                                                                                    [
                                                                                                                                                                          begin
                                                                                                                                                                              trampCall(_x)
                                                                                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                                                                                                          end
                                                                                                                                                                    ]
                                                                                                                                                                                 ))
                                                                                                                                                              ]
                                                                                                                                                                           ))
                                                                                                                                                        ]
                                                                                                                                                                     ))
                                                                                                                                                    end
                                                                                                                                                else
                                                                                                                                                    Cell.new()
                                                                                                                                                end
                                                                                                                                            end
                                                                                                                                        end
                                                                                                                                    }                                                                                                                                  ,
                                                                                                                                    begin
                                                                                                                                        trampCall(_vars)
                                                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:443"] + __e.backtrace ) ; raise __e
                                                                                                                                    end
                                                                                                                              ]
                                                                                                                                           ))
                                                                                                                        ]
                                                                                                                                     ))                                                                                                                      ,
                                                                                                                      Cell.new()
                                                                                                                  ]
                                                                                                                               ))
                                                                                                            ]
                                                                                                                         ))
                                                                                                      ]
                                                                                                                   ))                                                                                                    ,
                                                                                                    Cell.new()
                                                                                                ]
                                                                                                             ))
                                                                                          ]
                                                                                                       ))
                                                                                    ]
                                                                                                 ))
                                                                              ]
                                                                                           ))                                                                            ,
                                                                            Cell.new()
                                                                        ]
                                                                                     ))
                                                                  ]
                                                                               ))
                                                            ]
                                                                         ))                                                          ,
                                                          Cell.new()
                                                      ]
                                                                   ))
                                                ]
                                                             ))                                              ,
                                              Cell.new()
                                          ]
                                                       ))                                        ,
                                          trampCall( self._cons_METHOD(  'cons',
                                              begin
                                                if @global_lisp_binding.has_key?('_cons') then
                                                  trampCall(@_cons)
                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                trampCall( self._cons_METHOD(  'cons',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_cons') then
                                                        trampCall(@_cons)
                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:286"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      begin
                                                          trampCall(_do_MIMARKloop)
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:438"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                      trampCall( self._map_METHOD(  'map',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_map') then
                                                              trampCall(@_map)
                                                            else raise NameError.new( "Error: undefined variable _map", "_map" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:439"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            Proc.new { |_x| 
                                                                if ( 
                                                                  if ( 
                                                                    trampCall( self._not_METHOD(  'not',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_not') then
                                                                            trampCall(@_not)
                                                                          else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:434"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                                              begin
                                                                                if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                                                  trampCall(@_eq_QUMARK)
                                                                                else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:320"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                          [
                                                                              false                                                                              ,
                                                                                trampCall( self._pair_QUMARK_METHOD(  'pair?',
                                                                                    begin
                                                                                      if @global_lisp_binding.has_key?('_pair_QUMARK') then
                                                                                        trampCall(@_pair_QUMARK)
                                                                                      else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:440"] + __e.backtrace ) ; raise __e
                                                                                    end                                                                                  ,
                                                                                [
                                                                                      begin
                                                                                          trampCall(_x)
                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                      end
                                                                                ]
                                                                                             ))
                                                                          ]
                                                                                       ))
                                                                    ]
                                                                                 ))
                                                                   ) then
                                                                      trampCall( self._cdr_METHOD(  'cdr',
                                                                          begin
                                                                            if @global_lisp_binding.has_key?('_cdr') then
                                                                              trampCall(@_cdr)
                                                                            else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                      [
                                                                            begin
                                                                                trampCall(_x)
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                            end
                                                                      ]
                                                                                   ))
                                                                  else
                                                                    false
                                                                  end
                                                                 ) then
                                                                    trampCall( self._car_METHOD(  'car',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_car') then
                                                                            trampCall(@_car)
                                                                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          trampCall( self._cdr_METHOD(  'cdr',
                                                                              begin
                                                                                if @global_lisp_binding.has_key?('_cdr') then
                                                                                  trampCall(@_cdr)
                                                                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                          [
                                                                                begin
                                                                                    trampCall(_x)
                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:441"] + __e.backtrace ) ; raise __e
                                                                                end
                                                                          ]
                                                                                       ))
                                                                    ]
                                                                                 ))
                                                                else
                                                                  Cell.new()
                                                                end
                                                            }                                                          ,
                                                            begin
                                                                trampCall(_vars)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:443"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                ]
                                                             ))                                              ,
                                              Cell.new()
                                          ]
                                                       ))
                                    ]
                                                 ))
                              ]
                                           ))
                          } ; ___lambda.call(
                                trampCall( self._gensym_METHOD(  'gensym',
                                    begin
                                      if @global_lisp_binding.has_key?('_gensym') then
                                        trampCall(@_gensym)
                                      else raise NameError.new( "Error: undefined variable _gensym", "_gensym" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:422"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                ]
                                             ))
                                     )
                        end
                    }                  ,
                    begin
                        trampCall(_do_MIMARKmacro)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:444"] + __e.backtrace ) ; raise __e
                    end
              ]
                           ))
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._generic_MIMARKmember_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_generic_MIMARKmember'] = self.method( :_generic_MIMARKmember_METHOD )
    @_generic_MIMARKmember = 
    trampCall(
          Proc.new { |_cmp,_obj,_lst| 
              if ( 
                trampCall( self._null_QUMARK_METHOD(  'null?',
                    begin
                      if @global_lisp_binding.has_key?('_null_QUMARK') then
                        trampCall(@_null_QUMARK)
                      else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:450"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      begin
                          trampCall(_lst)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:452"] + __e.backtrace ) ; raise __e
                      end
                ]
                             ))
               ) then
                  begin
                    false
                  end
              else
                  if ( 
                    trampCall( callProcedure(   'cmp',
                        begin
                            trampCall(_cmp)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:452"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_obj)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:452"] + __e.backtrace ) ; raise __e
                          end                        ,
                          trampCall( self._car_METHOD(  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:451"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_lst)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:452"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                    ]
                                 ))
                   ) then
                      begin
                          begin
                              trampCall(_lst)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:452"] + __e.backtrace ) ; raise __e
                          end
                      end
                  else
                      if ( 
                      true
                       ) then
                          begin
                              delayCall( '_generic_MIMARKmember',  'generic-member',
                                  begin
                                    if @global_lisp_binding.has_key?('_generic_MIMARKmember') then
                                      trampCall(@_generic_MIMARKmember)
                                    else raise NameError.new( "Error: undefined variable _generic_MIMARKmember", "_generic_MIMARKmember" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:452"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_cmp)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:452"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                    begin
                                        trampCall(_obj)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:452"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                    trampCall( self._cdr_METHOD(  'cdr',
                                        begin
                                          if @global_lisp_binding.has_key?('_cdr') then
                                            trampCall(@_cdr)
                                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:452"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_lst)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:452"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))
                              ]
                                           )
                          end
                      else
                          Cell.new()
                      end
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._memq_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_memq'] = self.method( :_memq_METHOD )
    @_memq = 
    trampCall(
          Proc.new { |_obj,_lst| 
              delayCall( '_generic_MIMARKmember',  'generic-member',
                  begin
                    if @global_lisp_binding.has_key?('_generic_MIMARKmember') then
                      trampCall(@_generic_MIMARKmember)
                    else raise NameError.new( "Error: undefined variable _generic_MIMARKmember", "_generic_MIMARKmember" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:455"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                        trampCall(@_eq_QUMARK)
                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:455"] + __e.backtrace ) ; raise __e
                    end                  ,
                    begin
                        trampCall(_obj)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:455"] + __e.backtrace ) ; raise __e
                    end                  ,
                    begin
                        trampCall(_lst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:455"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._memv_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_memv'] = self.method( :_memv_METHOD )
    @_memv = 
    trampCall(
          Proc.new { |_obj,_lst| 
              delayCall( '_generic_MIMARKmember',  'generic-member',
                  begin
                    if @global_lisp_binding.has_key?('_generic_MIMARKmember') then
                      trampCall(@_generic_MIMARKmember)
                    else raise NameError.new( "Error: undefined variable _generic_MIMARKmember", "_generic_MIMARKmember" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:457"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                      if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                        trampCall(@_eqv_QUMARK)
                      else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:457"] + __e.backtrace ) ; raise __e
                    end                  ,
                    begin
                        trampCall(_obj)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:457"] + __e.backtrace ) ; raise __e
                    end                  ,
                    begin
                        trampCall(_lst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:457"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._member_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_member'] = self.method( :_member_METHOD )
    @_member = 
    trampCall(
          Proc.new { |_obj,_lst| 
              delayCall( '_generic_MIMARKmember',  'generic-member',
                  begin
                    if @global_lisp_binding.has_key?('_generic_MIMARKmember') then
                      trampCall(@_generic_MIMARKmember)
                    else raise NameError.new( "Error: undefined variable _generic_MIMARKmember", "_generic_MIMARKmember" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:459"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                      if @global_lisp_binding.has_key?('_equal_QUMARK') then
                        trampCall(@_equal_QUMARK)
                      else raise NameError.new( "Error: undefined variable _equal_QUMARK", "_equal_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:459"] + __e.backtrace ) ; raise __e
                    end                  ,
                    begin
                        trampCall(_obj)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:459"] + __e.backtrace ) ; raise __e
                    end                  ,
                    begin
                        trampCall(_lst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:459"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._generic_MIMARKassoc_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_generic_MIMARKassoc'] = self.method( :_generic_MIMARKassoc_METHOD )
    @_generic_MIMARKassoc = 
    trampCall(
          Proc.new { |_cmp,_obj,_alst| 
              if ( 
                trampCall( self._null_QUMARK_METHOD(  'null?',
                    begin
                      if @global_lisp_binding.has_key?('_null_QUMARK') then
                        trampCall(@_null_QUMARK)
                      else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:464"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      begin
                          trampCall(_alst)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:466"] + __e.backtrace ) ; raise __e
                      end
                ]
                             ))
               ) then
                  begin
                    false
                  end
              else
                  if ( 
                    trampCall( callProcedure(   'cmp',
                        begin
                            trampCall(_cmp)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:466"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_obj)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:466"] + __e.backtrace ) ; raise __e
                          end                        ,
                          trampCall( self._caar_METHOD(  'caar',
                              begin
                                if @global_lisp_binding.has_key?('_caar') then
                                  trampCall(@_caar)
                                else raise NameError.new( "Error: undefined variable _caar", "_caar" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:465"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_alst)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:466"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                    ]
                                 ))
                   ) then
                      begin
                          delayCall( '_car',  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:465"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_alst)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:466"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       )
                      end
                  else
                      if ( 
                      true
                       ) then
                          begin
                              delayCall( '_generic_MIMARKassoc',  'generic-assoc',
                                  begin
                                    if @global_lisp_binding.has_key?('_generic_MIMARKassoc') then
                                      trampCall(@_generic_MIMARKassoc)
                                    else raise NameError.new( "Error: undefined variable _generic_MIMARKassoc", "_generic_MIMARKassoc" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:466"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_cmp)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:466"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                    begin
                                        trampCall(_obj)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:466"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                    trampCall( self._cdr_METHOD(  'cdr',
                                        begin
                                          if @global_lisp_binding.has_key?('_cdr') then
                                            trampCall(@_cdr)
                                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:466"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_alst)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:466"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))
                              ]
                                           )
                          end
                      else
                          Cell.new()
                      end
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._assq_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_assq'] = self.method( :_assq_METHOD )
    @_assq = 
    trampCall(
          Proc.new { |_obj,_alst| 
              delayCall( '_generic_MIMARKassoc',  'generic-assoc',
                  begin
                    if @global_lisp_binding.has_key?('_generic_MIMARKassoc') then
                      trampCall(@_generic_MIMARKassoc)
                    else raise NameError.new( "Error: undefined variable _generic_MIMARKassoc", "_generic_MIMARKassoc" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:469"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                        trampCall(@_eq_QUMARK)
                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:469"] + __e.backtrace ) ; raise __e
                    end                  ,
                    begin
                        trampCall(_obj)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:469"] + __e.backtrace ) ; raise __e
                    end                  ,
                    begin
                        trampCall(_alst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:469"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._assv_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_assv'] = self.method( :_assv_METHOD )
    @_assv = 
    trampCall(
          Proc.new { |_obj,_alst| 
              delayCall( '_generic_MIMARKassoc',  'generic-assoc',
                  begin
                    if @global_lisp_binding.has_key?('_generic_MIMARKassoc') then
                      trampCall(@_generic_MIMARKassoc)
                    else raise NameError.new( "Error: undefined variable _generic_MIMARKassoc", "_generic_MIMARKassoc" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:471"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                      if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                        trampCall(@_eqv_QUMARK)
                      else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:471"] + __e.backtrace ) ; raise __e
                    end                  ,
                    begin
                        trampCall(_obj)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:471"] + __e.backtrace ) ; raise __e
                    end                  ,
                    begin
                        trampCall(_alst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:471"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._assoc_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_assoc'] = self.method( :_assoc_METHOD )
    @_assoc = 
    trampCall(
          Proc.new { |_obj,_alst| 
              delayCall( '_generic_MIMARKassoc',  'generic-assoc',
                  begin
                    if @global_lisp_binding.has_key?('_generic_MIMARKassoc') then
                      trampCall(@_generic_MIMARKassoc)
                    else raise NameError.new( "Error: undefined variable _generic_MIMARKassoc", "_generic_MIMARKassoc" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:473"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                      if @global_lisp_binding.has_key?('_equal_QUMARK') then
                        trampCall(@_equal_QUMARK)
                      else raise NameError.new( "Error: undefined variable _equal_QUMARK", "_equal_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:473"] + __e.backtrace ) ; raise __e
                    end                  ,
                    begin
                        trampCall(_obj)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:473"] + __e.backtrace ) ; raise __e
                    end                  ,
                    begin
                        trampCall(_alst)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:473"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._acons_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_acons'] = self.method( :_acons_METHOD )
    @_acons = 
    trampCall(
          Proc.new { |_x,_y,_z| 
              delayCall( '_cons',  'cons',
                  begin
                    if @global_lisp_binding.has_key?('_cons') then
                      trampCall(@_cons)
                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:475"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._cons_METHOD(  'cons',
                        begin
                          if @global_lisp_binding.has_key?('_cons') then
                            trampCall(@_cons)
                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:475"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_x)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:475"] + __e.backtrace ) ; raise __e
                          end                        ,
                          begin
                              trampCall(_y)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:475"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    begin
                        trampCall(_z)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:475"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._assq_MIMARKref_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_assq_MIMARKref'] = self.method( :_assq_MIMARKref_METHOD )
    @_assq_MIMARKref = 
    trampCall(
          Proc.new { |_obj,_alst| 
              if ( 
                begin
                    def self.___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20188_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
                    @global_lisp_binding['___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20188'] = self.method( :___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20188_METHOD )
                  @___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20188 = 
                  trampCall(
                        trampCall( self._assq_METHOD(  'assq',
                            begin
                              if @global_lisp_binding.has_key?('_assq') then
                                trampCall(@_assq)
                              else raise NameError.new( "Error: undefined variable _assq", "_assq" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:478"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(_obj)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:478"] + __e.backtrace ) ; raise __e
                              end                            ,
                              begin
                                  trampCall(_alst)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:478"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     ))
                  )
                end
               ) then
                  delayCall( '_cdr',  'cdr',
                      begin
                        if @global_lisp_binding.has_key?('_cdr') then
                          trampCall(@_cdr)
                        else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:478"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                        begin
                          if @global_lisp_binding.has_key?('___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20188') then
                            trampCall(@___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20188)
                          else raise NameError.new( "Error: undefined variable ___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20188", "___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20188" ) end
                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                        end
                  ]
                               )
              else
                  if ( 
                  true
                   ) then
                      begin
                        nil
                      end
                  else
                      Cell.new()
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._assv_MIMARKref_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_assv_MIMARKref'] = self.method( :_assv_MIMARKref_METHOD )
    @_assv_MIMARKref = 
    trampCall(
          Proc.new { |_obj,_alst| 
              if ( 
                begin
                    def self.___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20190_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
                    @global_lisp_binding['___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20190'] = self.method( :___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20190_METHOD )
                  @___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20190 = 
                  trampCall(
                        trampCall( self._assv_METHOD(  'assv',
                            begin
                              if @global_lisp_binding.has_key?('_assv') then
                                trampCall(@_assv)
                              else raise NameError.new( "Error: undefined variable _assv", "_assv" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:481"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(_obj)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:481"] + __e.backtrace ) ; raise __e
                              end                            ,
                              begin
                                  trampCall(_alst)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:481"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     ))
                  )
                end
               ) then
                  delayCall( '_cdr',  'cdr',
                      begin
                        if @global_lisp_binding.has_key?('_cdr') then
                          trampCall(@_cdr)
                        else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:481"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                        begin
                          if @global_lisp_binding.has_key?('___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20190') then
                            trampCall(@___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20190)
                          else raise NameError.new( "Error: undefined variable ___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20190", "___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20190" ) end
                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                        end
                  ]
                               )
              else
                  if ( 
                  true
                   ) then
                      begin
                        nil
                      end
                  else
                      Cell.new()
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._assoc_MIMARKref_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_assoc_MIMARKref'] = self.method( :_assoc_MIMARKref_METHOD )
    @_assoc_MIMARKref = 
    trampCall(
          Proc.new { |_obj,_alst| 
              if ( 
                begin
                    def self.___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20192_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
                    @global_lisp_binding['___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20192'] = self.method( :___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20192_METHOD )
                  @___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20192 = 
                  trampCall(
                        trampCall( self._assoc_METHOD(  'assoc',
                            begin
                              if @global_lisp_binding.has_key?('_assoc') then
                                trampCall(@_assoc)
                              else raise NameError.new( "Error: undefined variable _assoc", "_assoc" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:484"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(_obj)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:484"] + __e.backtrace ) ; raise __e
                              end                            ,
                              begin
                                  trampCall(_alst)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:484"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     ))
                  )
                end
               ) then
                  delayCall( '_cdr',  'cdr',
                      begin
                        if @global_lisp_binding.has_key?('_cdr') then
                          trampCall(@_cdr)
                        else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:484"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                        begin
                          if @global_lisp_binding.has_key?('___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20192') then
                            trampCall(@___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20192)
                          else raise NameError.new( "Error: undefined variable ___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20192", "___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20192" ) end
                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                        end
                  ]
                               )
              else
                  if ( 
                  true
                   ) then
                      begin
                        nil
                      end
                  else
                      Cell.new()
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._fold_MIMARKright_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_fold_MIMARKright'] = self.method( :_fold_MIMARKright_METHOD )
    @_fold_MIMARKright = 
    trampCall(
          Proc.new { |_f,_x,_lst| 
              if ( 
                trampCall( self._null_QUMARK_METHOD(  'null?',
                    begin
                      if @global_lisp_binding.has_key?('_null_QUMARK') then
                        trampCall(@_null_QUMARK)
                      else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:494"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      begin
                          trampCall(_lst)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:496"] + __e.backtrace ) ; raise __e
                      end
                ]
                             ))
               ) then
                  begin
                      trampCall(_x)
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:496"] + __e.backtrace ) ; raise __e
                  end
              else
                  delayCall( '_fold_MIMARKright',  'fold-right',
                      begin
                        if @global_lisp_binding.has_key?('_fold_MIMARKright') then
                          trampCall(@_fold_MIMARKright)
                        else raise NameError.new( "Error: undefined variable _fold_MIMARKright", "_fold_MIMARKright" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:496"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                        begin
                            trampCall(_f)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:496"] + __e.backtrace ) ; raise __e
                        end                      ,
                        trampCall( callProcedure(   'f',
                            begin
                                trampCall(_f)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:496"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(_x)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:496"] + __e.backtrace ) ; raise __e
                              end                            ,
                              trampCall( self._car_METHOD(  'car',
                                  begin
                                    if @global_lisp_binding.has_key?('_car') then
                                      trampCall(@_car)
                                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:496"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_lst)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:496"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                        ]
                                     ))                      ,
                        trampCall( self._cdr_METHOD(  'cdr',
                            begin
                              if @global_lisp_binding.has_key?('_cdr') then
                                trampCall(@_cdr)
                              else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:496"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(_lst)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:496"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     ))
                  ]
                               )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._unzip1_MIMARKwith_MIMARKcdr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_unzip1_MIMARKwith_MIMARKcdr'] = self.method( :_unzip1_MIMARKwith_MIMARKcdr_METHOD )
    @_unzip1_MIMARKwith_MIMARKcdr = 
    trampCall(
          Proc.new { |*__rest__| _lists = __rest__[0] ;  
              delayCall( '_unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative',  'unzip1-with-cdr-iterative',
                  begin
                    if @global_lisp_binding.has_key?('_unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative') then
                      trampCall(@_unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative)
                    else raise NameError.new( "Error: undefined variable _unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative", "_unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:499"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(_lists)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:499"] + __e.backtrace ) ; raise __e
                    end                  ,
                  Cell.new()                  ,
                  Cell.new()
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative'] = self.method( :_unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative_METHOD )
    @_unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative = 
    trampCall(
          Proc.new { |_lists,_cars,_cdrs| 
              if ( 
                trampCall( self._null_QUMARK_METHOD(  'null?',
                    begin
                      if @global_lisp_binding.has_key?('_null_QUMARK') then
                        trampCall(@_null_QUMARK)
                      else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:502"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      begin
                          trampCall(_lists)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:507"] + __e.backtrace ) ; raise __e
                      end
                ]
                             ))
               ) then
                  delayCall( '_cons',  'cons',
                      begin
                        if @global_lisp_binding.has_key?('_cons') then
                          trampCall(@_cons)
                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:503"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                        begin
                            trampCall(_cars)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:508"] + __e.backtrace ) ; raise __e
                        end                      ,
                        begin
                            trampCall(_cdrs)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:509"] + __e.backtrace ) ; raise __e
                        end
                  ]
                               )
              else
                  begin
                    ___lambda = lambda { |_car1,_cdr1| 
                        delayCall( '_unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative',  'unzip1-with-cdr-iterative',
                            begin
                              if @global_lisp_binding.has_key?('_unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative') then
                                trampCall(@_unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative)
                              else raise NameError.new( "Error: undefined variable _unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative", "_unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:506"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              trampCall( self._cdr_METHOD(  'cdr',
                                  begin
                                    if @global_lisp_binding.has_key?('_cdr') then
                                      trampCall(@_cdr)
                                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:507"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_lists)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:507"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))                            ,
                              trampCall( self._append_METHOD(  'append',
                                  begin
                                    if @global_lisp_binding.has_key?('_append') then
                                      trampCall(@_append)
                                    else raise NameError.new( "Error: undefined variable _append", "_append" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:509"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_cars)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:508"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                    trampCall( self._list_METHOD(  'list',
                                        begin
                                          if @global_lisp_binding.has_key?('_list') then
                                            trampCall(@_list)
                                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:509"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_car1)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:508"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))
                              ]
                                           ))                            ,
                              trampCall( self._append_METHOD(  'append',
                                  begin
                                    if @global_lisp_binding.has_key?('_append') then
                                      trampCall(@_append)
                                    else raise NameError.new( "Error: undefined variable _append", "_append" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:509"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_cdrs)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:509"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                    trampCall( self._list_METHOD(  'list',
                                        begin
                                          if @global_lisp_binding.has_key?('_list') then
                                            trampCall(@_list)
                                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:509"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_cdr1)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:509"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))
                              ]
                                           ))
                        ]
                                     )
                    } ; ___lambda.call(
                          trampCall( self._caar_METHOD(  'caar',
                              begin
                                if @global_lisp_binding.has_key?('_caar') then
                                  trampCall(@_caar)
                                else raise NameError.new( "Error: undefined variable _caar", "_caar" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:504"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_lists)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:507"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))                        ,
                          trampCall( self._cdar_METHOD(  'cdar',
                              begin
                                if @global_lisp_binding.has_key?('_cdar') then
                                  trampCall(@_cdar)
                                else raise NameError.new( "Error: undefined variable _cdar", "_cdar" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:505"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_lists)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:507"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                               )
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self.__PAMARKmap_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['__PAMARKmap'] = self.method( :__PAMARKmap_METHOD )
    @__PAMARKmap = 
    trampCall(
          Proc.new { |_proc,*__rest__| _lists = __rest__[0] ;  
              begin
                ___lambda = lambda { |_result,__PAMARKmap_MIMARKarg1| 
                    _result                     = 
                    Cell.new()
                    __PAMARKmap_MIMARKarg1                     = 
                      Proc.new { |_proc,_lst| 
                          if ( 
                            trampCall( self._null_QUMARK_METHOD(  'null?',
                                begin
                                  if @global_lisp_binding.has_key?('_null_QUMARK') then
                                    trampCall(@_null_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:536"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_lst)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:522"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                           ) then
                            true
                          else
                              begin
                                  begin
                                    
                                    _result = 
                                    trampCall(
                                          trampCall( self._cons_METHOD(  'cons',
                                              begin
                                                if @global_lisp_binding.has_key?('_cons') then
                                                  trampCall(@_cons)
                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                trampCall( callProcedure(   'proc',
                                                    begin
                                                        trampCall(_proc)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      trampCall( self._car_METHOD(  'car',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_car') then
                                                              trampCall(@_car)
                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:533"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_lst)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:522"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                ]
                                                             ))                                              ,
                                                begin
                                                    trampCall(_result)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:528"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))
                                    )
                                  end
                                  delayCall( '__PAMARKmap_MIMARKarg1',  '%map-arg1',
                                      begin
                                          trampCall(__PAMARKmap_MIMARKarg1)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:527"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(_proc)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                        trampCall( self._cdr_METHOD(  'cdr',
                                            begin
                                              if @global_lisp_binding.has_key?('_cdr') then
                                                trampCall(@_cdr)
                                              else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:534"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_lst)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:522"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                  ]
                                               )
                              end
                          end
                      }
                    if ( 
                      trampCall( self._null_QUMARK_METHOD(  'null?',
                          begin
                            if @global_lisp_binding.has_key?('_null_QUMARK') then
                              trampCall(@_null_QUMARK)
                            else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:536"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_lists)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:532"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                     ) then
                        begin
                            delayCall( '_apply',  'apply',
                                begin
                                  if @global_lisp_binding.has_key?('_apply') then
                                    trampCall(@_apply)
                                  else raise NameError.new( "Error: undefined variable _apply", "_apply" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_proc)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         )
                        end
                    else
                        if ( 
                          trampCall( self._eq_QUMARK_METHOD(  'eq?',
                              begin
                                if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                  trampCall(@_eq_QUMARK)
                                else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:526"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                              1                              ,
                                trampCall( self._length_METHOD(  'length',
                                    begin
                                      if @global_lisp_binding.has_key?('_length') then
                                        trampCall(@_length)
                                      else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:526"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_lists)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:532"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                         ) then
                            begin
                                trampCall( callProcedure(   '%map-arg1',
                                    begin
                                        trampCall(__PAMARKmap_MIMARKarg1)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:527"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_proc)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                      trampCall( self._car_METHOD(  'car',
                                          begin
                                            if @global_lisp_binding.has_key?('_car') then
                                              trampCall(@_car)
                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:533"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_lists)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:532"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                ]
                                             ))
                                delayCall( '_reverse',  'reverse',
                                    begin
                                      if @global_lisp_binding.has_key?('_reverse') then
                                        trampCall(@_reverse)
                                      else raise NameError.new( "Error: undefined variable _reverse", "_reverse" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:528"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_result)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:528"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             )
                            end
                        else
                            if ( 
                            true
                             ) then
                                begin
                                    if ( 
                                      trampCall( self._null_QUMARK_METHOD(  'null?',
                                          begin
                                            if @global_lisp_binding.has_key?('_null_QUMARK') then
                                              trampCall(@_null_QUMARK)
                                            else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:536"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            trampCall( self._car_METHOD(  'car',
                                                begin
                                                  if @global_lisp_binding.has_key?('_car') then
                                                    trampCall(@_car)
                                                  else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:533"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_lists)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:532"] + __e.backtrace ) ; raise __e
                                                  end
                                            ]
                                                         ))
                                      ]
                                                   ))
                                     ) then
                                      Cell.new()
                                    else
                                        begin
                                          ___lambda = lambda { |_unz| 
                                              begin
                                                ___lambda = lambda { |_cars,_cdrs| 
                                                    delayCall( '_cons',  'cons',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_cons') then
                                                            trampCall(@_cons)
                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          trampCall( self._apply_METHOD(  'apply',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_apply') then
                                                                  trampCall(@_apply)
                                                                else raise NameError.new( "Error: undefined variable _apply", "_apply" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                                begin
                                                                    trampCall(_proc)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                                begin
                                                                    trampCall(_cars)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:535"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))                                                        ,
                                                          if ( 
                                                            trampCall( self._null_QUMARK_METHOD(  'null?',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_null_QUMARK') then
                                                                    trampCall(@_null_QUMARK)
                                                                  else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:536"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  begin
                                                                      trampCall(_cdrs)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                                                  end
                                                            ]
                                                                         ))
                                                           ) then
                                                            Cell.new()
                                                          else
                                                              trampCall( self._apply_METHOD(  'apply',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_apply') then
                                                                      trampCall(@_apply)
                                                                    else raise NameError.new( "Error: undefined variable _apply", "_apply" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                    begin
                                                                      if @global_lisp_binding.has_key?('__PAMARKmap') then
                                                                        trampCall(@__PAMARKmap)
                                                                      else raise NameError.new( "Error: undefined variable __PAMARKmap", "__PAMARKmap" ) end
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                    trampCall( self._cons_METHOD(  'cons',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_cons') then
                                                                            trampCall(@_cons)
                                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          begin
                                                                              trampCall(_proc)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                          begin
                                                                              trampCall(_cdrs)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                                                          end
                                                                    ]
                                                                                 ))
                                                              ]
                                                                           ))
                                                          end
                                                    ]
                                                                 )
                                                } ; ___lambda.call(
                                                      trampCall( self._car_METHOD(  'car',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_car') then
                                                              trampCall(@_car)
                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:533"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_unz)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:534"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))                                                    ,
                                                      trampCall( self._cdr_METHOD(  'cdr',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_cdr') then
                                                              trampCall(@_cdr)
                                                            else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:534"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_unz)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:534"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                           )
                                              end
                                          } ; ___lambda.call(
                                                trampCall( self._apply_METHOD(  'apply',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_apply') then
                                                        trampCall(@_apply)
                                                      else raise NameError.new( "Error: undefined variable _apply", "_apply" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:538"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      begin
                                                        if @global_lisp_binding.has_key?('_unzip1_MIMARKwith_MIMARKcdr') then
                                                          trampCall(@_unzip1_MIMARKwith_MIMARKcdr)
                                                        else raise NameError.new( "Error: undefined variable _unzip1_MIMARKwith_MIMARKcdr", "_unzip1_MIMARKwith_MIMARKcdr" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:532"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                      begin
                                                          trampCall(_lists)
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:532"] + __e.backtrace ) ; raise __e
                                                      end
                                                ]
                                                             ))
                                                     )
                                        end
                                    end
                                end
                            else
                                Cell.new()
                            end
                        end
                    end
                } ; ___lambda.call(
                nil,nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self.__PAMARKinternal_MIMARKdefine_MIMARKto_MIMARKletrec_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['__PAMARKinternal_MIMARKdefine_MIMARKto_MIMARKletrec'] = self.method( :__PAMARKinternal_MIMARKdefine_MIMARKto_MIMARKletrec_METHOD )
    @__PAMARKinternal_MIMARKdefine_MIMARKto_MIMARKletrec = 
    trampCall(
          Proc.new { |__sym,__src| 
              if ( 
                trampCall( self._not_METHOD(  'not',
                    begin
                      if @global_lisp_binding.has_key?('_not') then
                        trampCall(@_not)
                      else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:546"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      trampCall( self._list_QUMARK_METHOD(  'list?',
                          begin
                            if @global_lisp_binding.has_key?('_list_QUMARK') then
                              trampCall(@_list_QUMARK)
                            else raise NameError.new( "Error: undefined variable _list_QUMARK", "_list_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:546"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            trampCall( self._cadr_METHOD(  'cadr',
                                begin
                                  if @global_lisp_binding.has_key?('_cadr') then
                                    trampCall(@_cadr)
                                  else raise NameError.new( "Error: undefined variable _cadr", "_cadr" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:565"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(__src)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:570"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                      ]
                                   ))
                ]
                             ))
               ) then
                  delayCall( '_cons',  'cons',
                      begin
                        if @global_lisp_binding.has_key?('_cons') then
                          trampCall(@_cons)
                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:554"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                        begin
                            trampCall(__sym)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:570"] + __e.backtrace ) ; raise __e
                        end                      ,
                        begin
                            trampCall(__src)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:570"] + __e.backtrace ) ; raise __e
                        end
                  ]
                               )
              else
                  begin
                    ___lambda = lambda { |_body,_defs,_rest| 
                        if ( 
                          trampCall( self._not_METHOD(  'not',
                              begin
                                if @global_lisp_binding.has_key?('_not') then
                                  trampCall(@_not)
                                else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:546"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._list_QUMARK_METHOD(  'list?',
                                    begin
                                      if @global_lisp_binding.has_key?('_list_QUMARK') then
                                        trampCall(@_list_QUMARK)
                                      else raise NameError.new( "Error: undefined variable _list_QUMARK", "_list_QUMARK" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:546"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      trampCall( self._car_METHOD(  'car',
                                          begin
                                            if @global_lisp_binding.has_key?('_car') then
                                              trampCall(@_car)
                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:560"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_body)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:555"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                ]
                                             ))
                          ]
                                       ))
                         ) then
                            delayCall( '_cons',  'cons',
                                begin
                                  if @global_lisp_binding.has_key?('_cons') then
                                    trampCall(@_cons)
                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:554"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(__sym)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:570"] + __e.backtrace ) ; raise __e
                                  end                                ,
                                  begin
                                      trampCall(__src)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:570"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         )
                        else
                            begin
                                trampCall( self.__PAMARKmap_METHOD(  '%map',
                                    begin
                                      if @global_lisp_binding.has_key?('__PAMARKmap') then
                                        trampCall(@__PAMARKmap)
                                      else raise NameError.new( "Error: undefined variable __PAMARKmap", "__PAMARKmap" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:562"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      Proc.new { |_x| 
                                          if ( 
                                            if ( 
                                              trampCall( self._not_METHOD(  'not',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_not') then
                                                      trampCall(@_not)
                                                    else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:546"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                    trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                            trampCall(@_eq_QUMARK)
                                                          else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:552"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                        false                                                        ,
                                                          trampCall( self._pair_QUMARK_METHOD(  'pair?',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_pair_QUMARK') then
                                                                  trampCall(@_pair_QUMARK)
                                                                else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:551"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                                begin
                                                                    trampCall(_x)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:566"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))
                                                    ]
                                                                 ))
                                              ]
                                                           ))
                                             ) then
                                                trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                        trampCall(@_eq_QUMARK)
                                                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:552"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                    :"define"                                                    ,
                                                      trampCall( self._car_METHOD(  'car',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_car') then
                                                              trampCall(@_car)
                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:560"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_x)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:566"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                ]
                                                             ))
                                            else
                                              false
                                            end
                                           ) then
                                              begin
                                                
                                                _defs = 
                                                trampCall(
                                                      trampCall( self._cons_METHOD(  'cons',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_cons') then
                                                              trampCall(@_cons)
                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:554"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            trampCall( self.__PAMARKexpand_MIMARKdefine_MIMARKform_METHOD(  '%expand-define-form',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('__PAMARKexpand_MIMARKdefine_MIMARKform') then
                                                                    trampCall(@__PAMARKexpand_MIMARKdefine_MIMARKform)
                                                                  else raise NameError.new( "Error: undefined variable __PAMARKexpand_MIMARKdefine_MIMARKform", "__PAMARKexpand_MIMARKdefine_MIMARKform" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:553"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  trampCall( self._cdr_METHOD(  'cdr',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('_cdr') then
                                                                          trampCall(@_cdr)
                                                                        else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:553"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        begin
                                                                            trampCall(_x)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:566"] + __e.backtrace ) ; raise __e
                                                                        end
                                                                  ]
                                                                               ))
                                                            ]
                                                                         ))                                                          ,
                                                            begin
                                                                trampCall(_defs)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:567"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                )
                                              end
                                          else
                                              begin
                                                
                                                _rest = 
                                                trampCall(
                                                      trampCall( self._cons_METHOD(  'cons',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_cons') then
                                                              trampCall(@_cons)
                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:554"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_x)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:566"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                            begin
                                                                trampCall(_rest)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:568"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                )
                                              end
                                          end
                                      }                                    ,
                                      begin
                                          trampCall(_body)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:555"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                                begin
                                  ___lambda = lambda { |_defs,_rest| 
                                      if ( 
                                        trampCall( self.__LTMARK_METHOD(  '<',
                                            begin
                                              if @global_lisp_binding.has_key?('__LTMARK') then
                                                trampCall(@__LTMARK)
                                              else raise NameError.new( "Error: undefined variable __LTMARK", "__LTMARK" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:558"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                            0                                            ,
                                              trampCall( self._length_METHOD(  'length',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_length') then
                                                      trampCall(@_length)
                                                    else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:558"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                    begin
                                                        trampCall(_defs)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:567"] + __e.backtrace ) ; raise __e
                                                    end
                                              ]
                                                           ))
                                        ]
                                                     ))
                                       ) then
                                          delayCall( '_cons',  'cons',
                                              begin
                                                if @global_lisp_binding.has_key?('_cons') then
                                                  trampCall(@_cons)
                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:554"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(__sym)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:570"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                                trampCall( self._cons_METHOD(  'cons',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_cons') then
                                                        trampCall(@_cons)
                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:554"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      trampCall( self._car_METHOD(  'car',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_car') then
                                                              trampCall(@_car)
                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:560"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(__src)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:570"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))                                                    ,
                                                      trampCall( self._cons_METHOD(  'cons',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_cons') then
                                                              trampCall(@_cons)
                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:554"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            trampCall( self._cons_METHOD(  'cons',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_cons') then
                                                                    trampCall(@_cons)
                                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:554"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                :"letrec"                                                                ,
                                                                  trampCall( self._cons_METHOD(  'cons',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('_cons') then
                                                                          trampCall(@_cons)
                                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:554"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        trampCall( self.__PAMARKmap_METHOD(  '%map',
                                                                            begin
                                                                              if @global_lisp_binding.has_key?('__PAMARKmap') then
                                                                                trampCall(@__PAMARKmap)
                                                                              else raise NameError.new( "Error: undefined variable __PAMARKmap", "__PAMARKmap" ) end
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:562"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                        [
                                                                              Proc.new { |_x| 
                                                                                  trampCall( self._list_METHOD(  'list',
                                                                                      begin
                                                                                        if @global_lisp_binding.has_key?('_list') then
                                                                                          trampCall(@_list)
                                                                                        else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:564"] + __e.backtrace ) ; raise __e
                                                                                      end                                                                                    ,
                                                                                  [
                                                                                        trampCall( self._cadr_METHOD(  'cadr',
                                                                                            begin
                                                                                              if @global_lisp_binding.has_key?('_cadr') then
                                                                                                trampCall(@_cadr)
                                                                                              else raise NameError.new( "Error: undefined variable _cadr", "_cadr" ) end
                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:565"] + __e.backtrace ) ; raise __e
                                                                                            end                                                                                          ,
                                                                                        [
                                                                                              begin
                                                                                                  trampCall(_x)
                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:566"] + __e.backtrace ) ; raise __e
                                                                                              end
                                                                                        ]
                                                                                                     ))                                                                                      ,
                                                                                        trampCall( self._caddr_METHOD(  'caddr',
                                                                                            begin
                                                                                              if @global_lisp_binding.has_key?('_caddr') then
                                                                                                trampCall(@_caddr)
                                                                                              else raise NameError.new( "Error: undefined variable _caddr", "_caddr" ) end
                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:566"] + __e.backtrace ) ; raise __e
                                                                                            end                                                                                          ,
                                                                                        [
                                                                                              begin
                                                                                                  trampCall(_x)
                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:566"] + __e.backtrace ) ; raise __e
                                                                                              end
                                                                                        ]
                                                                                                     ))
                                                                                  ]
                                                                                               ))
                                                                              }                                                                            ,
                                                                              begin
                                                                                  trampCall(_defs)
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:567"] + __e.backtrace ) ; raise __e
                                                                              end
                                                                        ]
                                                                                     ))                                                                      ,
                                                                        begin
                                                                            trampCall(_rest)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:568"] + __e.backtrace ) ; raise __e
                                                                        end
                                                                  ]
                                                                               ))
                                                            ]
                                                                         ))                                                          ,
                                                          Cell.new()
                                                      ]
                                                                   ))
                                                ]
                                                             ))
                                          ]
                                                       )
                                      else
                                          delayCall( '_cons',  'cons',
                                              begin
                                                if @global_lisp_binding.has_key?('_cons') then
                                                  trampCall(@_cons)
                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:554"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(__sym)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:570"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                                begin
                                                    trampCall(__src)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:570"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       )
                                      end
                                  } ; ___lambda.call(
                                        trampCall( self._reverse_METHOD(  'reverse',
                                            begin
                                              if @global_lisp_binding.has_key?('_reverse') then
                                                trampCall(@_reverse)
                                              else raise NameError.new( "Error: undefined variable _reverse", "_reverse" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:557"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_defs)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:567"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))                                      ,
                                        trampCall( self._reverse_METHOD(  'reverse',
                                            begin
                                              if @global_lisp_binding.has_key?('_reverse') then
                                                trampCall(@_reverse)
                                              else raise NameError.new( "Error: undefined variable _reverse", "_reverse" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:557"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_rest)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:568"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                             )
                                end
                            end
                        end
                    } ; ___lambda.call(
                          trampCall( self._cdr_METHOD(  'cdr',
                              begin
                                if @global_lisp_binding.has_key?('_cdr') then
                                  trampCall(@_cdr)
                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:553"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(__src)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:570"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))                        ,
                        Cell.new()                        ,
                        Cell.new()
                               )
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._lambda_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_lambda'] = self.method( :_lambda_METHOD )
    @_lambda = 
    trampCall(
          LispMacro.new { |*__rest__| _src = __rest__[0] ;  
              trampCall( self.__PAMARKinternal_MIMARKdefine_MIMARKto_MIMARKletrec_METHOD(  '%internal-define-to-letrec',
                  begin
                    if @global_lisp_binding.has_key?('__PAMARKinternal_MIMARKdefine_MIMARKto_MIMARKletrec') then
                      trampCall(@__PAMARKinternal_MIMARKdefine_MIMARKto_MIMARKletrec)
                    else raise NameError.new( "Error: undefined variable __PAMARKinternal_MIMARKdefine_MIMARKto_MIMARKletrec", "__PAMARKinternal_MIMARKdefine_MIMARKto_MIMARKletrec" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:575"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  :"lambda"                  ,
                    begin
                        trampCall(_src)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:575"] + __e.backtrace ) ; raise __e
                    end
              ]
                           ))
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._macro_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_macro'] = self.method( :_macro_METHOD )
    @_macro = 
    trampCall(
          LispMacro.new { |*__rest__| _src = __rest__[0] ;  
              trampCall( self.__PAMARKinternal_MIMARKdefine_MIMARKto_MIMARKletrec_METHOD(  '%internal-define-to-letrec',
                  begin
                    if @global_lisp_binding.has_key?('__PAMARKinternal_MIMARKdefine_MIMARKto_MIMARKletrec') then
                      trampCall(@__PAMARKinternal_MIMARKdefine_MIMARKto_MIMARKletrec)
                    else raise NameError.new( "Error: undefined variable __PAMARKinternal_MIMARKdefine_MIMARKto_MIMARKletrec", "__PAMARKinternal_MIMARKdefine_MIMARKto_MIMARKletrec" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:579"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  :"macro"                  ,
                    begin
                        trampCall(_src)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:579"] + __e.backtrace ) ; raise __e
                    end
              ]
                           ))
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self.__PAMARKfor_MIMARKeach_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['__PAMARKfor_MIMARKeach'] = self.method( :__PAMARKfor_MIMARKeach_METHOD )
    @__PAMARKfor_MIMARKeach = 
    trampCall(
          Proc.new { |_proc,*__rest__| _lists = __rest__[0] ;  
              begin
                ___lambda = lambda { |__PAMARKfor_MIMARKeach_MIMARKarg1| 
                    __PAMARKfor_MIMARKeach_MIMARKarg1                     = 
                      Proc.new { |_proc,_lst| 
                          if ( 
                            trampCall( self._null_QUMARK_METHOD(  'null?',
                                begin
                                  if @global_lisp_binding.has_key?('_null_QUMARK') then
                                    trampCall(@_null_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:600"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_lst)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:587"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                           ) then
                            true
                          else
                              begin
                                  trampCall( callProcedure(   'proc',
                                      begin
                                          trampCall(_proc)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:602"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        trampCall( self._car_METHOD(  'car',
                                            begin
                                              if @global_lisp_binding.has_key?('_car') then
                                                trampCall(@_car)
                                              else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:597"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_lst)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:587"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                  ]
                                               ))
                                  delayCall( '__PAMARKfor_MIMARKeach_MIMARKarg1',  '%for-each-arg1',
                                      begin
                                          trampCall(__PAMARKfor_MIMARKeach_MIMARKarg1)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:592"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(_proc)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:602"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                        trampCall( self._cdr_METHOD(  'cdr',
                                            begin
                                              if @global_lisp_binding.has_key?('_cdr') then
                                                trampCall(@_cdr)
                                              else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:598"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_lst)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:587"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                  ]
                                               )
                              end
                          end
                      }
                    if ( 
                      trampCall( self._null_QUMARK_METHOD(  'null?',
                          begin
                            if @global_lisp_binding.has_key?('_null_QUMARK') then
                              trampCall(@_null_QUMARK)
                            else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:600"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_lists)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:596"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                     ) then
                        begin
                            delayCall( '_apply',  'apply',
                                begin
                                  if @global_lisp_binding.has_key?('_apply') then
                                    trampCall(@_apply)
                                  else raise NameError.new( "Error: undefined variable _apply", "_apply" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:602"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_proc)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:602"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         )
                        end
                    else
                        if ( 
                          trampCall( self._eq_QUMARK_METHOD(  'eq?',
                              begin
                                if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                  trampCall(@_eq_QUMARK)
                                else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:591"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                              1                              ,
                                trampCall( self._length_METHOD(  'length',
                                    begin
                                      if @global_lisp_binding.has_key?('_length') then
                                        trampCall(@_length)
                                      else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:591"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_lists)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:596"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                         ) then
                            begin
                                delayCall( '__PAMARKfor_MIMARKeach_MIMARKarg1',  '%for-each-arg1',
                                    begin
                                        trampCall(__PAMARKfor_MIMARKeach_MIMARKarg1)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:592"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_proc)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:602"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                      trampCall( self._car_METHOD(  'car',
                                          begin
                                            if @global_lisp_binding.has_key?('_car') then
                                              trampCall(@_car)
                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:597"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_lists)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:596"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                ]
                                             )
                            end
                        else
                            if ( 
                            true
                             ) then
                                begin
                                    if ( 
                                      trampCall( self._null_QUMARK_METHOD(  'null?',
                                          begin
                                            if @global_lisp_binding.has_key?('_null_QUMARK') then
                                              trampCall(@_null_QUMARK)
                                            else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:600"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            trampCall( self._car_METHOD(  'car',
                                                begin
                                                  if @global_lisp_binding.has_key?('_car') then
                                                    trampCall(@_car)
                                                  else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:597"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_lists)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:596"] + __e.backtrace ) ; raise __e
                                                  end
                                            ]
                                                         ))
                                      ]
                                                   ))
                                     ) then
                                      true
                                    else
                                        begin
                                          ___lambda = lambda { |_unz| 
                                              begin
                                                ___lambda = lambda { |_cars,_cdrs| 
                                                    trampCall( self._apply_METHOD(  'apply',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_apply') then
                                                            trampCall(@_apply)
                                                          else raise NameError.new( "Error: undefined variable _apply", "_apply" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:602"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          begin
                                                              trampCall(_proc)
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:602"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                          begin
                                                              trampCall(_cars)
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:599"] + __e.backtrace ) ; raise __e
                                                          end
                                                    ]
                                                                 ))
                                                    if ( 
                                                      trampCall( self._null_QUMARK_METHOD(  'null?',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_null_QUMARK') then
                                                              trampCall(@_null_QUMARK)
                                                            else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:600"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_cdrs)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:602"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                     ) then
                                                      Cell.new()
                                                    else
                                                        delayCall( '_apply',  'apply',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_apply') then
                                                                trampCall(@_apply)
                                                              else raise NameError.new( "Error: undefined variable _apply", "_apply" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:602"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              begin
                                                                if @global_lisp_binding.has_key?('__PAMARKfor_MIMARKeach') then
                                                                  trampCall(@__PAMARKfor_MIMARKeach)
                                                                else raise NameError.new( "Error: undefined variable __PAMARKfor_MIMARKeach", "__PAMARKfor_MIMARKeach" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:602"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                              trampCall( self._cons_METHOD(  'cons',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                      trampCall(@_cons)
                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:602"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                    begin
                                                                        trampCall(_proc)
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:602"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                    begin
                                                                        trampCall(_cdrs)
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:602"] + __e.backtrace ) ; raise __e
                                                                    end
                                                              ]
                                                                           ))
                                                        ]
                                                                     )
                                                    end
                                                } ; ___lambda.call(
                                                      trampCall( self._car_METHOD(  'car',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_car') then
                                                              trampCall(@_car)
                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:597"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_unz)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:598"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))                                                    ,
                                                      trampCall( self._cdr_METHOD(  'cdr',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_cdr') then
                                                              trampCall(@_cdr)
                                                            else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:598"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_unz)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:598"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                           )
                                              end
                                          } ; ___lambda.call(
                                                trampCall( self._apply_METHOD(  'apply',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_apply') then
                                                        trampCall(@_apply)
                                                      else raise NameError.new( "Error: undefined variable _apply", "_apply" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:602"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      begin
                                                        if @global_lisp_binding.has_key?('_unzip1_MIMARKwith_MIMARKcdr') then
                                                          trampCall(@_unzip1_MIMARKwith_MIMARKcdr)
                                                        else raise NameError.new( "Error: undefined variable _unzip1_MIMARKwith_MIMARKcdr", "_unzip1_MIMARKwith_MIMARKcdr" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:596"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                      begin
                                                          trampCall(_lists)
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:596"] + __e.backtrace ) ; raise __e
                                                      end
                                                ]
                                                             ))
                                                     )
                                        end
                                    end
                                end
                            else
                                Cell.new()
                            end
                        end
                    end
                } ; ___lambda.call(
                nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self.__PAMARKfilter_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['__PAMARKfilter'] = self.method( :__PAMARKfilter_METHOD )
    @__PAMARKfilter = 
    trampCall(
          Proc.new { |_pred,_lst| 
              begin
                ___lambda = lambda { |_result,__PAMARKfilter_MIMARKarg1| 
                    _result                     = 
                    Cell.new()
                    __PAMARKfilter_MIMARKarg1                     = 
                      Proc.new { |_proc,_lst| 
                          if ( 
                            trampCall( self._null_QUMARK_METHOD(  'null?',
                                begin
                                  if @global_lisp_binding.has_key?('_null_QUMARK') then
                                    trampCall(@_null_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:607"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_lst)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:614"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                           ) then
                            Cell.new()
                          else
                              begin
                                ___lambda = lambda { |_v| 
                                    if ( 
                                      begin
                                          trampCall(_v)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:610"] + __e.backtrace ) ; raise __e
                                      end
                                     ) then
                                        begin
                                            begin
                                              
                                              _result = 
                                              trampCall(
                                                    trampCall( self._cons_METHOD(  'cons',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_cons') then
                                                            trampCall(@_cons)
                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:611"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          trampCall( self._car_METHOD(  'car',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_car') then
                                                                  trampCall(@_car)
                                                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:611"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                                begin
                                                                    trampCall(_lst)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:614"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))                                                        ,
                                                          begin
                                                              trampCall(_result)
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:615"] + __e.backtrace ) ; raise __e
                                                          end
                                                    ]
                                                                 ))
                                              )
                                            end
                                        end
                                    end
                                    delayCall( '__PAMARKfilter_MIMARKarg1',  '%filter-arg1',
                                        begin
                                            trampCall(__PAMARKfilter_MIMARKarg1)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:614"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_proc)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:612"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                          trampCall( self._cdr_METHOD(  'cdr',
                                              begin
                                                if @global_lisp_binding.has_key?('_cdr') then
                                                  trampCall(@_cdr)
                                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:612"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_lst)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:614"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))
                                    ]
                                                 )
                                } ; ___lambda.call(
                                      trampCall( callProcedure(   'proc',
                                          begin
                                              trampCall(_proc)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:612"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            trampCall( self._car_METHOD(  'car',
                                                begin
                                                  if @global_lisp_binding.has_key?('_car') then
                                                    trampCall(@_car)
                                                  else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:611"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_lst)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:614"] + __e.backtrace ) ; raise __e
                                                  end
                                            ]
                                                         ))
                                      ]
                                                   ))
                                           )
                              end
                          end
                      }
                    trampCall( callProcedure(   '%filter-arg1',
                        begin
                            trampCall(__PAMARKfilter_MIMARKarg1)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:614"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_pred)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:614"] + __e.backtrace ) ; raise __e
                          end                        ,
                          begin
                              trampCall(_lst)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:614"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
                    delayCall( '_reverse',  'reverse',
                        begin
                          if @global_lisp_binding.has_key?('_reverse') then
                            trampCall(@_reverse)
                          else raise NameError.new( "Error: undefined variable _reverse", "_reverse" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:615"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_result)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:615"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 )
                } ; ___lambda.call(
                nil,nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self.__PAMARKfilter_MIMARKmap_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['__PAMARKfilter_MIMARKmap'] = self.method( :__PAMARKfilter_MIMARKmap_METHOD )
    @__PAMARKfilter_MIMARKmap = 
    trampCall(
          Proc.new { |_pred,_lst| 
              begin
                ___lambda = lambda { |_result,__PAMARKfilter_MIMARKmap_MIMARKarg1| 
                    _result                     = 
                    Cell.new()
                    __PAMARKfilter_MIMARKmap_MIMARKarg1                     = 
                      Proc.new { |_proc,_lst| 
                          if ( 
                            trampCall( self._null_QUMARK_METHOD(  'null?',
                                begin
                                  if @global_lisp_binding.has_key?('_null_QUMARK') then
                                    trampCall(@_null_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:620"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_lst)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:627"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                           ) then
                            Cell.new()
                          else
                              begin
                                ___lambda = lambda { |_v| 
                                    if ( 
                                      begin
                                          trampCall(_v)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:624"] + __e.backtrace ) ; raise __e
                                      end
                                     ) then
                                        begin
                                            begin
                                              
                                              _result = 
                                              trampCall(
                                                    trampCall( self._cons_METHOD(  'cons',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_cons') then
                                                            trampCall(@_cons)
                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:624"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          begin
                                                              trampCall(_v)
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:624"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                          begin
                                                              trampCall(_result)
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:628"] + __e.backtrace ) ; raise __e
                                                          end
                                                    ]
                                                                 ))
                                              )
                                            end
                                        end
                                    end
                                    delayCall( '__PAMARKfilter_MIMARKmap_MIMARKarg1',  '%filter-map-arg1',
                                        begin
                                            trampCall(__PAMARKfilter_MIMARKmap_MIMARKarg1)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:627"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_proc)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:625"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                          trampCall( self._cdr_METHOD(  'cdr',
                                              begin
                                                if @global_lisp_binding.has_key?('_cdr') then
                                                  trampCall(@_cdr)
                                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:625"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_lst)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:627"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))
                                    ]
                                                 )
                                } ; ___lambda.call(
                                      trampCall( callProcedure(   'proc',
                                          begin
                                              trampCall(_proc)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:625"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            trampCall( self._car_METHOD(  'car',
                                                begin
                                                  if @global_lisp_binding.has_key?('_car') then
                                                    trampCall(@_car)
                                                  else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:622"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_lst)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:627"] + __e.backtrace ) ; raise __e
                                                  end
                                            ]
                                                         ))
                                      ]
                                                   ))
                                           )
                              end
                          end
                      }
                    trampCall( callProcedure(   '%filter-map-arg1',
                        begin
                            trampCall(__PAMARKfilter_MIMARKmap_MIMARKarg1)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:627"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_pred)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:627"] + __e.backtrace ) ; raise __e
                          end                        ,
                          begin
                              trampCall(_lst)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:627"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
                    delayCall( '_reverse',  'reverse',
                        begin
                          if @global_lisp_binding.has_key?('_reverse') then
                            trampCall(@_reverse)
                          else raise NameError.new( "Error: undefined variable _reverse", "_reverse" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:628"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_result)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:628"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 )
                } ; ___lambda.call(
                nil,nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._find_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_find'] = self.method( :_find_METHOD )
    @_find = 
    trampCall(
          Proc.new { |_pred,_lst| 
              begin
                ___lambda = lambda { |_result| 
                    if ( 
                      trampCall( self._null_QUMARK_METHOD(  'null?',
                          begin
                            if @global_lisp_binding.has_key?('_null_QUMARK') then
                              trampCall(@_null_QUMARK)
                            else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:633"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_result)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:635"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                     ) then
                      false
                    else
                        delayCall( '_car',  'car',
                            begin
                              if @global_lisp_binding.has_key?('_car') then
                                trampCall(@_car)
                              else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:635"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(_result)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:635"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     )
                    end
                } ; ___lambda.call(
                      trampCall( self.__PAMARKfilter_METHOD(  '%filter',
                          begin
                            if @global_lisp_binding.has_key?('__PAMARKfilter') then
                              trampCall(@__PAMARKfilter)
                            else raise NameError.new( "Error: undefined variable __PAMARKfilter", "__PAMARKfilter" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:632"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_pred)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:632"] + __e.backtrace ) ; raise __e
                            end                          ,
                            begin
                                trampCall(_lst)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:632"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._any_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_any'] = self.method( :_any_METHOD )
    @_any = 
    trampCall(
          begin
            if @global_lisp_binding.has_key?('_find') then
              trampCall(@_find)
            else raise NameError.new( "Error: undefined variable _find", "_find" ) end
            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:636"] + __e.backtrace ) ; raise __e
          end
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._map_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_map'] = self.method( :_map_METHOD )
    @_map = 
    trampCall(
          begin
            if @global_lisp_binding.has_key?('__PAMARKmap') then
              trampCall(@__PAMARKmap)
            else raise NameError.new( "Error: undefined variable __PAMARKmap", "__PAMARKmap" ) end
            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:638"] + __e.backtrace ) ; raise __e
          end
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._for_MIMARKeach_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_for_MIMARKeach'] = self.method( :_for_MIMARKeach_METHOD )
    @_for_MIMARKeach = 
    trampCall(
          begin
            if @global_lisp_binding.has_key?('__PAMARKfor_MIMARKeach') then
              trampCall(@__PAMARKfor_MIMARKeach)
            else raise NameError.new( "Error: undefined variable __PAMARKfor_MIMARKeach", "__PAMARKfor_MIMARKeach" ) end
            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:639"] + __e.backtrace ) ; raise __e
          end
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._filter_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_filter'] = self.method( :_filter_METHOD )
    @_filter = 
    trampCall(
          begin
            if @global_lisp_binding.has_key?('__PAMARKfilter') then
              trampCall(@__PAMARKfilter)
            else raise NameError.new( "Error: undefined variable __PAMARKfilter", "__PAMARKfilter" ) end
            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:640"] + __e.backtrace ) ; raise __e
          end
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._filter_MIMARKmap_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_filter_MIMARKmap'] = self.method( :_filter_MIMARKmap_METHOD )
    @_filter_MIMARKmap = 
    trampCall(
          begin
            if @global_lisp_binding.has_key?('__PAMARKfilter_MIMARKmap') then
              trampCall(@__PAMARKfilter_MIMARKmap)
            else raise NameError.new( "Error: undefined variable __PAMARKfilter_MIMARKmap", "__PAMARKfilter_MIMARKmap" ) end
            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:641"] + __e.backtrace ) ; raise __e
          end
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._case_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_case'] = self.method( :_case_METHOD )
    @_case = 
    trampCall(
          LispMacro.new { |_cond_MIMARKexp,*__rest__| _body = __rest__[0] ;  
              begin
                ___lambda = lambda { |_case_MIMARKblock,_case_MIMARKiter| 
                    _case_MIMARKblock                     = 
                      Proc.new { |_val,*__rest__| _elem = __rest__[0] ;  
                          begin
                            ___lambda = lambda { |_block| 
                                begin
                                  ___lambda = lambda { |_cond_MIMARKvals,_body| 
                                      begin
                                        ___lambda = lambda { |_v| 
                                            trampCall( self._cons_METHOD(  'cons',
                                                begin
                                                  if @global_lisp_binding.has_key?('_cons') then
                                                    trampCall(@_cons)
                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  trampCall( self._cons_METHOD(  'cons',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cons') then
                                                          trampCall(@_cons)
                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        begin
                                                            trampCall(_v)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:664"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                        begin
                                                            trampCall(_body)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:680"] + __e.backtrace ) ; raise __e
                                                        end
                                                  ]
                                                               ))                                                ,
                                                Cell.new()
                                            ]
                                                         ))
                                        } ; ___lambda.call(
                                              if ( 
                                                trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                        trampCall(@_eq_QUMARK)
                                                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:671"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                    :"else"                                                    ,
                                                      begin
                                                          trampCall(_cond_MIMARKvals)
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:663"] + __e.backtrace ) ; raise __e
                                                      end
                                                ]
                                                             ))
                                               ) then
                                                  begin
                                                      trampCall(_cond_MIMARKvals)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:663"] + __e.backtrace ) ; raise __e
                                                  end
                                              else
                                                  trampCall( self._cons_METHOD(  'cons',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cons') then
                                                          trampCall(@_cons)
                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                      :"or"                                                      ,
                                                        trampCall( self._map_METHOD(  'map',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_map') then
                                                                trampCall(@_map)
                                                              else raise NameError.new( "Error: undefined variable _map", "_map" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:660"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              Proc.new { |_x| 
                                                                  trampCall( self._cons_METHOD(  'cons',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('_cons') then
                                                                          trampCall(@_cons)
                                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                      :"eqv?"                                                                      ,
                                                                        trampCall( self._cons_METHOD(  'cons',
                                                                            begin
                                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                                trampCall(@_cons)
                                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                        [
                                                                              trampCall( self._cons_METHOD(  'cons',
                                                                                  begin
                                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                                      trampCall(@_cons)
                                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                                                  end                                                                                ,
                                                                              [
                                                                                  :"quote"                                                                                  ,
                                                                                    trampCall( self._cons_METHOD(  'cons',
                                                                                        begin
                                                                                          if @global_lisp_binding.has_key?('_cons') then
                                                                                            trampCall(@_cons)
                                                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                                                        end                                                                                      ,
                                                                                    [
                                                                                          begin
                                                                                              trampCall(_x)
                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:662"] + __e.backtrace ) ; raise __e
                                                                                          end                                                                                        ,
                                                                                        Cell.new()
                                                                                    ]
                                                                                                 ))
                                                                              ]
                                                                                           ))                                                                            ,
                                                                              trampCall( self._cons_METHOD(  'cons',
                                                                                  begin
                                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                                      trampCall(@_cons)
                                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                                                  end                                                                                ,
                                                                              [
                                                                                    begin
                                                                                        trampCall(_val)
                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:675"] + __e.backtrace ) ; raise __e
                                                                                    end                                                                                  ,
                                                                                  Cell.new()
                                                                              ]
                                                                                           ))
                                                                        ]
                                                                                     ))
                                                                  ]
                                                                               ))
                                                              }                                                            ,
                                                              begin
                                                                  trampCall(_cond_MIMARKvals)
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:663"] + __e.backtrace ) ; raise __e
                                                              end
                                                        ]
                                                                     ))
                                                  ]
                                                               ))
                                              end
                                                   )
                                      end
                                  } ; ___lambda.call(
                                        trampCall( self._car_METHOD(  'car',
                                            begin
                                              if @global_lisp_binding.has_key?('_car') then
                                                trampCall(@_car)
                                              else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:674"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_block)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:655"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))                                      ,
                                        trampCall( self._cdr_METHOD(  'cdr',
                                            begin
                                              if @global_lisp_binding.has_key?('_cdr') then
                                                trampCall(@_cdr)
                                              else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:675"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_block)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:655"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                             )
                                end
                            } ; ___lambda.call(
                                  trampCall( self._car_METHOD(  'car',
                                      begin
                                        if @global_lisp_binding.has_key?('_car') then
                                          trampCall(@_car)
                                        else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:674"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(_elem)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:653"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                                       )
                          end
                      }
                    _case_MIMARKiter                     = 
                      Proc.new { |_val,_lst| 
                          if ( 
                            trampCall( self._null_QUMARK_METHOD(  'null?',
                                begin
                                  if @global_lisp_binding.has_key?('_null_QUMARK') then
                                    trampCall(@_null_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:669"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_lst)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:675"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                           ) then
                              begin
                                Cell.new()
                              end
                          else
                              if ( 
                                trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                    begin
                                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                        trampCall(@_eq_QUMARK)
                                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:671"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                    1                                    ,
                                      trampCall( self._length_METHOD(  'length',
                                          begin
                                            if @global_lisp_binding.has_key?('_length') then
                                              trampCall(@_length)
                                            else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:671"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_lst)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:675"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                ]
                                             ))
                               ) then
                                  begin
                                      trampCall( callProcedure(   'case-block',
                                          begin
                                              trampCall(_case_MIMARKblock)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:674"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_val)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:675"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                            trampCall( self._car_METHOD(  'car',
                                                begin
                                                  if @global_lisp_binding.has_key?('_car') then
                                                    trampCall(@_car)
                                                  else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:674"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_lst)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:675"] + __e.backtrace ) ; raise __e
                                                  end
                                            ]
                                                         ))
                                      ]
                                                   ))
                                  end
                              else
                                  if ( 
                                  true
                                   ) then
                                      begin
                                          trampCall( self._append_METHOD(  'append',
                                              begin
                                                if @global_lisp_binding.has_key?('_append') then
                                                  trampCall(@_append)
                                                else raise NameError.new( "Error: undefined variable _append", "_append" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:674"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                trampCall( callProcedure(   'case-block',
                                                    begin
                                                        trampCall(_case_MIMARKblock)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:674"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      begin
                                                          trampCall(_val)
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:675"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                      trampCall( self._car_METHOD(  'car',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_car') then
                                                              trampCall(@_car)
                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:674"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_lst)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:675"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                ]
                                                             ))                                              ,
                                                trampCall( callProcedure(   'case-iter',
                                                    begin
                                                        trampCall(_case_MIMARKiter)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:680"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      begin
                                                          trampCall(_val)
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:675"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                      trampCall( self._cdr_METHOD(  'cdr',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_cdr') then
                                                              trampCall(@_cdr)
                                                            else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:675"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_lst)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:675"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))
                                                ]
                                                             ))
                                          ]
                                                       ))
                                      end
                                  else
                                      Cell.new()
                                  end
                              end
                          end
                      }
                    begin
                      ___lambda = lambda { |_sym| 
                          trampCall( self._cons_METHOD(  'cons',
                              begin
                                if @global_lisp_binding.has_key?('_cons') then
                                  trampCall(@_cons)
                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                              :"let1"                              ,
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_sym)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:680"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                      trampCall( self._cons_METHOD(  'cons',
                                          begin
                                            if @global_lisp_binding.has_key?('_cons') then
                                              trampCall(@_cons)
                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_cond_MIMARKexp)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:678"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                            trampCall( self._cons_METHOD(  'cons',
                                                begin
                                                  if @global_lisp_binding.has_key?('_cons') then
                                                    trampCall(@_cons)
                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  trampCall( self._cons_METHOD(  'cons',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cons') then
                                                          trampCall(@_cons)
                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                      :"cond"                                                      ,
                                                        trampCall( callProcedure(   'case-iter',
                                                            begin
                                                                trampCall(_case_MIMARKiter)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:680"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              begin
                                                                  trampCall(_sym)
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:680"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                              begin
                                                                  trampCall(_body)
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:680"] + __e.backtrace ) ; raise __e
                                                              end
                                                        ]
                                                                     ))
                                                  ]
                                                               ))                                                ,
                                                Cell.new()
                                            ]
                                                         ))
                                      ]
                                                   ))
                                ]
                                             ))
                          ]
                                       ))
                      } ; ___lambda.call(
                            trampCall( self._gensym_METHOD(  'gensym',
                                begin
                                  if @global_lisp_binding.has_key?('_gensym') then
                                    trampCall(@_gensym)
                                  else raise NameError.new( "Error: undefined variable _gensym", "_gensym" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:677"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                            ]
                                         ))
                                 )
                    end
                } ; ___lambda.call(
                nil,nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._let_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_let_ASMARK'] = self.method( :_let_ASMARK_METHOD )
    @_let_ASMARK = 
    trampCall(
          LispMacro.new { |_exps,*__rest__| _body = __rest__[0] ;  
              begin
                ___lambda = lambda { |_let_ASMARK_MIMARKexpand| 
                    _let_ASMARK_MIMARKexpand                     = 
                      Proc.new { |_rest,_body| 
                          begin
                            ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20202| 
                                if ( 
                                  begin
                                    ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20206| 
                                        if ( 
                                          begin
                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20206)
                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                          end
                                         ) then
                                            begin
                                                trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20206)
                                              rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                            end
                                        else
                                          false
                                        end
                                    } ; ___lambda.call(
                                          trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                              begin
                                                if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                  trampCall(@_eqv_QUMARK)
                                                else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:662"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                              0                                              ,
                                                begin
                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20202)
                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))
                                               )
                                  end
                                 ) then
                                    begin
                                      Cell.new()
                                    end
                                else
                                    if ( 
                                      begin
                                        ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20207| 
                                            if ( 
                                              begin
                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20207)
                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                              end
                                             ) then
                                                begin
                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20207)
                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                end
                                            else
                                              false
                                            end
                                        } ; ___lambda.call(
                                              trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                      trampCall(@_eqv_QUMARK)
                                                    else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:662"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                  1                                                  ,
                                                    begin
                                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20202)
                                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                    end
                                              ]
                                                           ))
                                                   )
                                      end
                                     ) then
                                        begin
                                            trampCall( self._cons_METHOD(  'cons',
                                                begin
                                                  if @global_lisp_binding.has_key?('_cons') then
                                                    trampCall(@_cons)
                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                :"let"                                                ,
                                                  trampCall( self._cons_METHOD(  'cons',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cons') then
                                                          trampCall(@_cons)
                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        trampCall( self._cons_METHOD(  'cons',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                trampCall(@_cons)
                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              trampCall( self._car_METHOD(  'car',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_car') then
                                                                      trampCall(@_car)
                                                                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:693"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                    begin
                                                                        trampCall(_rest)
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:694"] + __e.backtrace ) ; raise __e
                                                                    end
                                                              ]
                                                                           ))                                                            ,
                                                            Cell.new()
                                                        ]
                                                                     ))                                                      ,
                                                        begin
                                                            trampCall(_body)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:695"] + __e.backtrace ) ; raise __e
                                                        end
                                                  ]
                                                               ))
                                            ]
                                                         ))
                                        end
                                    else
                                        if ( 
                                        true
                                         ) then
                                            begin
                                                trampCall( self._cons_METHOD(  'cons',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_cons') then
                                                        trampCall(@_cons)
                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                    :"let"                                                    ,
                                                      trampCall( self._cons_METHOD(  'cons',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_cons') then
                                                              trampCall(@_cons)
                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            trampCall( self._cons_METHOD(  'cons',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_cons') then
                                                                    trampCall(@_cons)
                                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  trampCall( self._car_METHOD(  'car',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('_car') then
                                                                          trampCall(@_car)
                                                                        else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:693"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        begin
                                                                            trampCall(_rest)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:694"] + __e.backtrace ) ; raise __e
                                                                        end
                                                                  ]
                                                                               ))                                                                ,
                                                                Cell.new()
                                                            ]
                                                                         ))                                                          ,
                                                            trampCall( self._cons_METHOD(  'cons',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_cons') then
                                                                    trampCall(@_cons)
                                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  trampCall( callProcedure(   'let*-expand',
                                                                      begin
                                                                          trampCall(_let_ASMARK_MIMARKexpand)
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:695"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        trampCall( self._cdr_METHOD(  'cdr',
                                                                            begin
                                                                              if @global_lisp_binding.has_key?('_cdr') then
                                                                                trampCall(@_cdr)
                                                                              else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:694"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                        [
                                                                              begin
                                                                                  trampCall(_rest)
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:694"] + __e.backtrace ) ; raise __e
                                                                              end
                                                                        ]
                                                                                     ))                                                                      ,
                                                                        begin
                                                                            trampCall(_body)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:695"] + __e.backtrace ) ; raise __e
                                                                        end
                                                                  ]
                                                                               ))                                                                ,
                                                                Cell.new()
                                                            ]
                                                                         ))
                                                      ]
                                                                   ))
                                                ]
                                                             ))
                                            end
                                        else
                                            Cell.new()
                                        end
                                    end
                                end
                            } ; ___lambda.call(
                                  trampCall( self._length_METHOD(  'length',
                                      begin
                                        if @global_lisp_binding.has_key?('_length') then
                                          trampCall(@_length)
                                        else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:686"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(_rest)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:694"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                                       )
                          end
                      }
                    trampCall( callProcedure(   'let*-expand',
                        begin
                            trampCall(_let_ASMARK_MIMARKexpand)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:695"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_exps)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:695"] + __e.backtrace ) ; raise __e
                          end                        ,
                          begin
                              trampCall(_body)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:695"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
                } ; ___lambda.call(
                nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._begin0_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_begin0'] = self.method( :_begin0_METHOD )
    @_begin0 = 
    trampCall(
          LispMacro.new { |*__rest__| _body = __rest__[0] ;  
              if ( 
                trampCall( self._null_QUMARK_METHOD(  'null?',
                    begin
                      if @global_lisp_binding.has_key?('_null_QUMARK') then
                        trampCall(@_null_QUMARK)
                      else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:700"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      begin
                          trampCall(_body)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:705"] + __e.backtrace ) ; raise __e
                      end
                ]
                             ))
               ) then
                Cell.new(:"begin",Cell.new(false))
              else
                  begin
                    ___lambda = lambda { |_result| 
                        trampCall( self._cons_METHOD(  'cons',
                            begin
                              if @global_lisp_binding.has_key?('_cons') then
                                trampCall(@_cons)
                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                            :"receive"                            ,
                              trampCall( self._cons_METHOD(  'cons',
                                  begin
                                    if @global_lisp_binding.has_key?('_cons') then
                                      trampCall(@_cons)
                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_result)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:706"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                    trampCall( self._cons_METHOD(  'cons',
                                        begin
                                          if @global_lisp_binding.has_key?('_cons') then
                                            trampCall(@_cons)
                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          trampCall( self._car_METHOD(  'car',
                                              begin
                                                if @global_lisp_binding.has_key?('_car') then
                                                  trampCall(@_car)
                                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:704"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_body)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:705"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))                                        ,
                                          trampCall( self._append_METHOD(  'append',
                                              begin
                                                if @global_lisp_binding.has_key?('_append') then
                                                  trampCall(@_append)
                                                else raise NameError.new( "Error: undefined variable _append", "_append" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:674"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                trampCall( self._cdr_METHOD(  'cdr',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_cdr') then
                                                        trampCall(@_cdr)
                                                      else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:705"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      begin
                                                          trampCall(_body)
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:705"] + __e.backtrace ) ; raise __e
                                                      end
                                                ]
                                                             ))                                              ,
                                                trampCall( self._cons_METHOD(  'cons',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_cons') then
                                                        trampCall(@_cons)
                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      trampCall( self._cons_METHOD(  'cons',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_cons') then
                                                              trampCall(@_cons)
                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                          :"apply"                                                          ,
                                                            trampCall( self._cons_METHOD(  'cons',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_cons') then
                                                                    trampCall(@_cons)
                                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                :"values"                                                                ,
                                                                  trampCall( self._cons_METHOD(  'cons',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('_cons') then
                                                                          trampCall(@_cons)
                                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        begin
                                                                            trampCall(_result)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:706"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                      Cell.new()
                                                                  ]
                                                                               ))
                                                            ]
                                                                         ))
                                                      ]
                                                                   ))                                                    ,
                                                    Cell.new()
                                                ]
                                                             ))
                                          ]
                                                       ))
                                    ]
                                                 ))
                              ]
                                           ))
                        ]
                                     ))
                    } ; ___lambda.call(
                          trampCall( self._gensym_METHOD(  'gensym',
                              begin
                                if @global_lisp_binding.has_key?('_gensym') then
                                  trampCall(@_gensym)
                                else raise NameError.new( "Error: undefined variable _gensym", "_gensym" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:703"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                          ]
                                       ))
                               )
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._values_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_values'] = self.method( :_values_METHOD )
    @_values = 
    trampCall(
          Proc.new { |*__rest__| _args = __rest__[0] ;  
              begin
                ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20208| 
                    if ( 
                      begin
                        ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20211| 
                            if ( 
                              begin
                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20211)
                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                              end
                             ) then
                                begin
                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20211)
                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                end
                            else
                              false
                            end
                        } ; ___lambda.call(
                              trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                  begin
                                    if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                      trampCall(@_eqv_QUMARK)
                                    else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:662"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                  1                                  ,
                                    begin
                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20208)
                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                                   )
                      end
                     ) then
                        begin
                            delayCall( '_car',  'car',
                                begin
                                  if @global_lisp_binding.has_key?('_car') then
                                    trampCall(@_car)
                                  else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:715"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_args)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:717"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         )
                        end
                    else
                        if ( 
                        true
                         ) then
                            begin
                                delayCall( '_make_MIMARKvalues',  'make-values',
                                    begin
                                      if @global_lisp_binding.has_key?('_make_MIMARKvalues') then
                                        trampCall(@_make_MIMARKvalues)
                                      else raise NameError.new( "Error: undefined variable _make_MIMARKvalues", "_make_MIMARKvalues" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:717"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_args)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:717"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             )
                            end
                        else
                            Cell.new()
                        end
                    end
                } ; ___lambda.call(
                      trampCall( self._length_METHOD(  'length',
                          begin
                            if @global_lisp_binding.has_key?('_length') then
                              trampCall(@_length)
                            else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:713"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_args)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:717"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._call_MIMARKwith_MIMARKvalues_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_call_MIMARKwith_MIMARKvalues'] = self.method( :_call_MIMARKwith_MIMARKvalues_METHOD )
    @_call_MIMARKwith_MIMARKvalues = 
    trampCall(
          Proc.new { |_producer,_consumer| 
              begin
                ___lambda = lambda { |_v| 
                    if ( 
                      trampCall( self._values_QUMARK_METHOD(  'values?',
                          begin
                            if @global_lisp_binding.has_key?('_values_QUMARK') then
                              trampCall(@_values_QUMARK)
                            else raise NameError.new( "Error: undefined variable _values_QUMARK", "_values_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:722"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_v)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:724"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                     ) then
                        delayCall( '_apply',  'apply',
                            begin
                              if @global_lisp_binding.has_key?('_apply') then
                                trampCall(@_apply)
                              else raise NameError.new( "Error: undefined variable _apply", "_apply" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:723"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(_consumer)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:724"] + __e.backtrace ) ; raise __e
                              end                            ,
                              trampCall( self._values_MIMARKvalues_METHOD(  'values-values',
                                  begin
                                    if @global_lisp_binding.has_key?('_values_MIMARKvalues') then
                                      trampCall(@_values_MIMARKvalues)
                                    else raise NameError.new( "Error: undefined variable _values_MIMARKvalues", "_values_MIMARKvalues" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:723"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_v)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:724"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                        ]
                                     )
                    else
                        delayCall( '_consumer',  'consumer',
                            begin
                                trampCall(_consumer)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:724"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(_v)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:724"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     )
                    end
                } ; ___lambda.call(
                      trampCall( callProcedure(   'producer',
                          begin
                              trampCall(_producer)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:721"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                      ]
                                   ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._receive_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_receive'] = self.method( :_receive_METHOD )
    @_receive = 
    trampCall(
          LispMacro.new { |_vars,_expr,*__rest__| _body = __rest__[0] ;  
              trampCall( self._cons_METHOD(  'cons',
                  begin
                    if @global_lisp_binding.has_key?('_cons') then
                      trampCall(@_cons)
                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  :"call-with-values"                  ,
                    trampCall( self._cons_METHOD(  'cons',
                        begin
                          if @global_lisp_binding.has_key?('_cons') then
                            trampCall(@_cons)
                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._cons_METHOD(  'cons',
                              begin
                                if @global_lisp_binding.has_key?('_cons') then
                                  trampCall(@_cons)
                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                              :"lambda"                              ,
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                    Cell.new()                                    ,
                                      trampCall( self._cons_METHOD(  'cons',
                                          begin
                                            if @global_lisp_binding.has_key?('_cons') then
                                              trampCall(@_cons)
                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_expr)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:730"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                          Cell.new()
                                      ]
                                                   ))
                                ]
                                             ))
                          ]
                                       ))                        ,
                          trampCall( self._cons_METHOD(  'cons',
                              begin
                                if @global_lisp_binding.has_key?('_cons') then
                                  trampCall(@_cons)
                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                    :"lambda"                                    ,
                                      trampCall( self._cons_METHOD(  'cons',
                                          begin
                                            if @global_lisp_binding.has_key?('_cons') then
                                              trampCall(@_cons)
                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_vars)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:731"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                            begin
                                                trampCall(_body)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:731"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                ]
                                             ))                              ,
                              Cell.new()
                          ]
                                       ))
                    ]
                                 ))
              ]
                           ))
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._get_MIMARKkeyword_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_get_MIMARKkeyword'] = self.method( :_get_MIMARKkeyword_METHOD )
    @_get_MIMARKkeyword = 
    trampCall(
          Proc.new { |_key,_kv_MIMARKlist,*__rest__| _fallback = __rest__[0] ;  
              if ( 
                begin
                  ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20214| 
                      if ( 
                        begin
                            trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20214)
                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                        end
                       ) then
                          begin
                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20214)
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                      else
                          begin
                            ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20215| 
                                if ( 
                                  begin
                                      trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20215)
                                    rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                  end
                                 ) then
                                    begin
                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20215)
                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                    end
                                else
                                  false
                                end
                            } ; ___lambda.call(
                                  trampCall( self.__GTMARK_EQMARK_METHOD(  '>=',
                                      begin
                                        if @global_lisp_binding.has_key?('__GTMARK_EQMARK') then
                                          trampCall(@__GTMARK_EQMARK)
                                        else raise NameError.new( "Error: undefined variable __GTMARK_EQMARK", "__GTMARK_EQMARK" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:739"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                      2                                      ,
                                        trampCall( self._length_METHOD(  'length',
                                            begin
                                              if @global_lisp_binding.has_key?('_length') then
                                                trampCall(@_length)
                                              else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:749"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_kv_MIMARKlist)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:755"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                  ]
                                               ))
                                       )
                          end
                      end
                  } ; ___lambda.call(
                        trampCall( self._not_METHOD(  'not',
                            begin
                              if @global_lisp_binding.has_key?('_not') then
                                trampCall(@_not)
                              else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:739"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              trampCall( self._list_QUMARK_METHOD(  'list?',
                                  begin
                                    if @global_lisp_binding.has_key?('_list_QUMARK') then
                                      trampCall(@_list_QUMARK)
                                    else raise NameError.new( "Error: undefined variable _list_QUMARK", "_list_QUMARK" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:739"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_kv_MIMARKlist)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:755"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                        ]
                                     ))
                             )
                end
               ) then
                  begin
                      if ( 
                        trampCall( self._null_QUMARK_METHOD(  'null?',
                            begin
                              if @global_lisp_binding.has_key?('_null_QUMARK') then
                                trampCall(@_null_QUMARK)
                              else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:751"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(_fallback)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:753"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     ))
                       ) then
                          begin raise RuntimeError, 
                            trampCall( self._sprintf_METHOD(  'sprintf',
                                begin
                                  if @global_lisp_binding.has_key?('_sprintf') then
                                    trampCall(@_sprintf)
                                  else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:393"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                "Error: imcomplete key list: %s
"                                ,
                                  trampCall( self._write_MIMARKto_MIMARKstring_METHOD(  'write-to-string',
                                      begin
                                        if @global_lisp_binding.has_key?('_write_MIMARKto_MIMARKstring') then
                                          trampCall(@_write_MIMARKto_MIMARKstring)
                                        else raise NameError.new( "Error: undefined variable _write_MIMARKto_MIMARKstring", "_write_MIMARKto_MIMARKstring" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:755"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(_kv_MIMARKlist)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:755"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                            ]
                                         ))
                          rescue => __e 
                            __e.set_backtrace( ["./lib/init.nnd:392"] + __e.backtrace )
                            raise __e
                          end 
                      else
                          delayCall( '_car',  'car',
                              begin
                                if @global_lisp_binding.has_key?('_car') then
                                  trampCall(@_car)
                                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:757"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_fallback)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:753"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       )
                      end
                  end
              else
                  if ( 
                  true
                   ) then
                      begin
                          begin
                            ___lambda = lambda { |_loop| 
                                _loop                                 = 
                                  Proc.new { |_k,_v,_rest| 
                                      if ( 
                                        trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                            begin
                                              if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                trampCall(@_eq_QUMARK)
                                              else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:747"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_k)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:747"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                              begin
                                                  trampCall(_key)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:752"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                       ) then
                                          begin
                                              trampCall(_v)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:748"] + __e.backtrace ) ; raise __e
                                          end
                                      else
                                          begin
                                            ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20216| 
                                                if ( 
                                                  begin
                                                    ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20220| 
                                                        if ( 
                                                          begin
                                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20220)
                                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                          end
                                                         ) then
                                                            begin
                                                                trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20220)
                                                              rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                            end
                                                        else
                                                          false
                                                        end
                                                    } ; ___lambda.call(
                                                          trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                  trampCall(@_eqv_QUMARK)
                                                                else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:662"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                              0                                                              ,
                                                                begin
                                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20216)
                                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))
                                                               )
                                                  end
                                                 ) then
                                                    begin
                                                        if ( 
                                                          trampCall( self._null_QUMARK_METHOD(  'null?',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_null_QUMARK') then
                                                                  trampCall(@_null_QUMARK)
                                                                else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:751"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                                begin
                                                                    trampCall(_fallback)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:753"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))
                                                         ) then
                                                            begin raise RuntimeError, 
                                                              trampCall( self._sprintf_METHOD(  'sprintf',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_sprintf') then
                                                                      trampCall(@_sprintf)
                                                                    else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:393"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                  "Error: value for key %s is not provided : %s
"                                                                  ,
                                                                    trampCall( self._write_MIMARKto_MIMARKstring_METHOD(  'write-to-string',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_write_MIMARKto_MIMARKstring') then
                                                                            trampCall(@_write_MIMARKto_MIMARKstring)
                                                                          else raise NameError.new( "Error: undefined variable _write_MIMARKto_MIMARKstring", "_write_MIMARKto_MIMARKstring" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:755"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          begin
                                                                              trampCall(_key)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:752"] + __e.backtrace ) ; raise __e
                                                                          end
                                                                    ]
                                                                                 ))                                                                  ,
                                                                    trampCall( self._write_MIMARKto_MIMARKstring_METHOD(  'write-to-string',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_write_MIMARKto_MIMARKstring') then
                                                                            trampCall(@_write_MIMARKto_MIMARKstring)
                                                                          else raise NameError.new( "Error: undefined variable _write_MIMARKto_MIMARKstring", "_write_MIMARKto_MIMARKstring" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:755"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          begin
                                                                              trampCall(_kv_MIMARKlist)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:755"] + __e.backtrace ) ; raise __e
                                                                          end
                                                                    ]
                                                                                 ))
                                                              ]
                                                                           ))
                                                            rescue => __e 
                                                              __e.set_backtrace( ["./lib/init.nnd:392"] + __e.backtrace )
                                                              raise __e
                                                            end 
                                                        else
                                                            delayCall( '_car',  'car',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_car') then
                                                                    trampCall(@_car)
                                                                  else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:757"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  begin
                                                                      trampCall(_fallback)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:753"] + __e.backtrace ) ; raise __e
                                                                  end
                                                            ]
                                                                         )
                                                        end
                                                    end
                                                else
                                                    if ( 
                                                      begin
                                                        ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20221| 
                                                            if ( 
                                                              begin
                                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20221)
                                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                              end
                                                             ) then
                                                                begin
                                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20221)
                                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                end
                                                            else
                                                              false
                                                            end
                                                        } ; ___lambda.call(
                                                              trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                      trampCall(@_eqv_QUMARK)
                                                                    else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:662"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                  1                                                                  ,
                                                                    begin
                                                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20216)
                                                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                    end
                                                              ]
                                                                           ))
                                                                   )
                                                      end
                                                     ) then
                                                        begin
                                                            begin raise RuntimeError, 
                                                              trampCall( self._sprintf_METHOD(  'sprintf',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_sprintf') then
                                                                      trampCall(@_sprintf)
                                                                    else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:393"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                  "Error: incomplete key list: %s
"                                                                  ,
                                                                    trampCall( self._write_MIMARKto_MIMARKstring_METHOD(  'write-to-string',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_write_MIMARKto_MIMARKstring') then
                                                                            trampCall(@_write_MIMARKto_MIMARKstring)
                                                                          else raise NameError.new( "Error: undefined variable _write_MIMARKto_MIMARKstring", "_write_MIMARKto_MIMARKstring" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:755"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          begin
                                                                              trampCall(_kv_MIMARKlist)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:755"] + __e.backtrace ) ; raise __e
                                                                          end
                                                                    ]
                                                                                 ))
                                                              ]
                                                                           ))
                                                            rescue => __e 
                                                              __e.set_backtrace( ["./lib/init.nnd:392"] + __e.backtrace )
                                                              raise __e
                                                            end 
                                                        end
                                                    else
                                                        if ( 
                                                        true
                                                         ) then
                                                            begin
                                                                delayCall( '_loop',  'loop',
                                                                    begin
                                                                        trampCall(_loop)
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:757"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                [
                                                                      trampCall( self._car_METHOD(  'car',
                                                                          begin
                                                                            if @global_lisp_binding.has_key?('_car') then
                                                                              trampCall(@_car)
                                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:757"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                      [
                                                                            begin
                                                                                trampCall(_rest)
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:759"] + __e.backtrace ) ; raise __e
                                                                            end
                                                                      ]
                                                                                   ))                                                                    ,
                                                                      trampCall( self._cadr_METHOD(  'cadr',
                                                                          begin
                                                                            if @global_lisp_binding.has_key?('_cadr') then
                                                                              trampCall(@_cadr)
                                                                            else raise NameError.new( "Error: undefined variable _cadr", "_cadr" ) end
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:758"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                      [
                                                                            begin
                                                                                trampCall(_rest)
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:759"] + __e.backtrace ) ; raise __e
                                                                            end
                                                                      ]
                                                                                   ))                                                                    ,
                                                                      trampCall( self._cddr_METHOD(  'cddr',
                                                                          begin
                                                                            if @global_lisp_binding.has_key?('_cddr') then
                                                                              trampCall(@_cddr)
                                                                            else raise NameError.new( "Error: undefined variable _cddr", "_cddr" ) end
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:759"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                      [
                                                                            begin
                                                                                trampCall(_rest)
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:759"] + __e.backtrace ) ; raise __e
                                                                            end
                                                                      ]
                                                                                   ))
                                                                ]
                                                                             )
                                                            end
                                                        else
                                                            Cell.new()
                                                        end
                                                    end
                                                end
                                            } ; ___lambda.call(
                                                  trampCall( self._length_METHOD(  'length',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_length') then
                                                          trampCall(@_length)
                                                        else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:749"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        begin
                                                            trampCall(_rest)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:759"] + __e.backtrace ) ; raise __e
                                                        end
                                                  ]
                                                               ))
                                                       )
                                          end
                                      end
                                  }
                                delayCall( '_loop',  'loop',
                                    begin
                                        trampCall(_loop)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:757"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      trampCall( self._car_METHOD(  'car',
                                          begin
                                            if @global_lisp_binding.has_key?('_car') then
                                              trampCall(@_car)
                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:757"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_kv_MIMARKlist)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:755"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))                                    ,
                                      trampCall( self._cadr_METHOD(  'cadr',
                                          begin
                                            if @global_lisp_binding.has_key?('_cadr') then
                                              trampCall(@_cadr)
                                            else raise NameError.new( "Error: undefined variable _cadr", "_cadr" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:758"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_kv_MIMARKlist)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:755"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))                                    ,
                                      trampCall( self._cddr_METHOD(  'cddr',
                                          begin
                                            if @global_lisp_binding.has_key?('_cddr') then
                                              trampCall(@_cddr)
                                            else raise NameError.new( "Error: undefined variable _cddr", "_cddr" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:759"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_kv_MIMARKlist)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:755"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                ]
                                             )
                            } ; ___lambda.call(
                            nil
                                       )
                          end
                      end
                  else
                      Cell.new()
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._dot_MIMARKoperator_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_dot_MIMARKoperator'] = self.method( :_dot_MIMARKoperator_METHOD )
    @_dot_MIMARKoperator = 
    trampCall(
          LispMacro.new { |*__rest__| _lst = __rest__[0] ;  
              begin
                ___lambda = lambda { |_generate_MIMARKmethod_MIMARKcall_MIMARKform| 
                    _generate_MIMARKmethod_MIMARKcall_MIMARKform                     = 
                      Proc.new { |_lst| 
                          begin
                            ___lambda = lambda { |_tmp| 
                                if ( 
                                  trampCall( self._symbol_QUMARK_METHOD(  'symbol?',
                                      begin
                                        if @global_lisp_binding.has_key?('_symbol_QUMARK') then
                                          trampCall(@_symbol_QUMARK)
                                        else raise NameError.new( "Error: undefined variable _symbol_QUMARK", "_symbol_QUMARK" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:778"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        trampCall( self._first_METHOD(  'first',
                                            begin
                                              if @global_lisp_binding.has_key?('_first') then
                                                trampCall(@_first)
                                              else raise NameError.new( "Error: undefined variable _first", "_first" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:771"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_lst)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:779"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                  ]
                                               ))
                                 ) then
                                    trampCall( self._cons_METHOD(  'cons',
                                        begin
                                          if @global_lisp_binding.has_key?('_cons') then
                                            trampCall(@_cons)
                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          trampCall( self._string_MIMARK_GTMARKsymbol_METHOD(  'string->symbol',
                                              begin
                                                if @global_lisp_binding.has_key?('_string_MIMARK_GTMARKsymbol') then
                                                  trampCall(@_string_MIMARK_GTMARKsymbol)
                                                else raise NameError.new( "Error: undefined variable _string_MIMARK_GTMARKsymbol", "_string_MIMARK_GTMARKsymbol" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:772"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                trampCall( self.__PLMARK_METHOD(  '+',
                                                    begin
                                                      if @global_lisp_binding.has_key?('__PLMARK') then
                                                        trampCall(@__PLMARK)
                                                      else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:772"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      trampCall( self._to_MIMARKs_METHOD(  'to-s',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_to_MIMARKs') then
                                                              trampCall(@_to_MIMARKs)
                                                            else raise NameError.new( "Error: undefined variable _to_MIMARKs", "_to_MIMARKs" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:772"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            trampCall( self._first_METHOD(  'first',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_first') then
                                                                    trampCall(@_first)
                                                                  else raise NameError.new( "Error: undefined variable _first", "_first" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:771"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  begin
                                                                      trampCall(_lst)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:779"] + __e.backtrace ) ; raise __e
                                                                  end
                                                            ]
                                                                         ))
                                                      ]
                                                                   ))                                                    ,
                                                    "."                                                    ,
                                                      trampCall( self._to_MIMARKs_METHOD(  'to-s',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_to_MIMARKs') then
                                                              trampCall(@_to_MIMARKs)
                                                            else raise NameError.new( "Error: undefined variable _to_MIMARKs", "_to_MIMARKs" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:772"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            trampCall( self._second_METHOD(  'second',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_second') then
                                                                    trampCall(@_second)
                                                                  else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:778"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  begin
                                                                      trampCall(_lst)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:779"] + __e.backtrace ) ; raise __e
                                                                  end
                                                            ]
                                                                         ))
                                                      ]
                                                                   ))
                                                ]
                                                             ))
                                          ]
                                                       ))                                        ,
                                          trampCall( self._cddr_METHOD(  'cddr',
                                              begin
                                                if @global_lisp_binding.has_key?('_cddr') then
                                                  trampCall(@_cddr)
                                                else raise NameError.new( "Error: undefined variable _cddr", "_cddr" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:773"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_lst)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:779"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))
                                    ]
                                                 ))
                                else
                                    trampCall( self._cons_METHOD(  'cons',
                                        begin
                                          if @global_lisp_binding.has_key?('_cons') then
                                            trampCall(@_cons)
                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                        :"let"                                        ,
                                          trampCall( self._cons_METHOD(  'cons',
                                              begin
                                                if @global_lisp_binding.has_key?('_cons') then
                                                  trampCall(@_cons)
                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                trampCall( self._cons_METHOD(  'cons',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_cons') then
                                                        trampCall(@_cons)
                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      trampCall( self._cons_METHOD(  'cons',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_cons') then
                                                              trampCall(@_cons)
                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_tmp)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:772"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                            trampCall( self._cons_METHOD(  'cons',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_cons') then
                                                                    trampCall(@_cons)
                                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  trampCall( self._first_METHOD(  'first',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('_first') then
                                                                          trampCall(@_first)
                                                                        else raise NameError.new( "Error: undefined variable _first", "_first" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:771"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        begin
                                                                            trampCall(_lst)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:779"] + __e.backtrace ) ; raise __e
                                                                        end
                                                                  ]
                                                                               ))                                                                ,
                                                                Cell.new()
                                                            ]
                                                                         ))
                                                      ]
                                                                   ))                                                    ,
                                                    Cell.new()
                                                ]
                                                             ))                                              ,
                                                trampCall( self._cons_METHOD(  'cons',
                                                    begin
                                                      if @global_lisp_binding.has_key?('_cons') then
                                                        trampCall(@_cons)
                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      trampCall( self._cons_METHOD(  'cons',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_cons') then
                                                              trampCall(@_cons)
                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:659"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            trampCall( self._string_MIMARK_GTMARKsymbol_METHOD(  'string->symbol',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_string_MIMARK_GTMARKsymbol') then
                                                                    trampCall(@_string_MIMARK_GTMARKsymbol)
                                                                  else raise NameError.new( "Error: undefined variable _string_MIMARK_GTMARKsymbol", "_string_MIMARK_GTMARKsymbol" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:772"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  trampCall( self.__PLMARK_METHOD(  '+',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('__PLMARK') then
                                                                          trampCall(@__PLMARK)
                                                                        else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:772"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        trampCall( self._to_MIMARKs_METHOD(  'to-s',
                                                                            begin
                                                                              if @global_lisp_binding.has_key?('_to_MIMARKs') then
                                                                                trampCall(@_to_MIMARKs)
                                                                              else raise NameError.new( "Error: undefined variable _to_MIMARKs", "_to_MIMARKs" ) end
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:772"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                        [
                                                                              begin
                                                                                  trampCall(_tmp)
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:772"] + __e.backtrace ) ; raise __e
                                                                              end
                                                                        ]
                                                                                     ))                                                                      ,
                                                                      "."                                                                      ,
                                                                        trampCall( self._to_MIMARKs_METHOD(  'to-s',
                                                                            begin
                                                                              if @global_lisp_binding.has_key?('_to_MIMARKs') then
                                                                                trampCall(@_to_MIMARKs)
                                                                              else raise NameError.new( "Error: undefined variable _to_MIMARKs", "_to_MIMARKs" ) end
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:772"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                        [
                                                                              trampCall( self._second_METHOD(  'second',
                                                                                  begin
                                                                                    if @global_lisp_binding.has_key?('_second') then
                                                                                      trampCall(@_second)
                                                                                    else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:778"] + __e.backtrace ) ; raise __e
                                                                                  end                                                                                ,
                                                                              [
                                                                                    begin
                                                                                        trampCall(_lst)
                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:779"] + __e.backtrace ) ; raise __e
                                                                                    end
                                                                              ]
                                                                                           ))
                                                                        ]
                                                                                     ))
                                                                  ]
                                                                               ))
                                                            ]
                                                                         ))                                                          ,
                                                            trampCall( self._cddr_METHOD(  'cddr',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_cddr') then
                                                                    trampCall(@_cddr)
                                                                  else raise NameError.new( "Error: undefined variable _cddr", "_cddr" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:773"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  begin
                                                                      trampCall(_lst)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:779"] + __e.backtrace ) ; raise __e
                                                                  end
                                                            ]
                                                                         ))
                                                      ]
                                                                   ))                                                    ,
                                                    Cell.new()
                                                ]
                                                             ))
                                          ]
                                                       ))
                                    ]
                                                 ))
                                end
                            } ; ___lambda.call(
                                  trampCall( self._gensym_METHOD(  'gensym',
                                      begin
                                        if @global_lisp_binding.has_key?('_gensym') then
                                          trampCall(@_gensym)
                                        else raise NameError.new( "Error: undefined variable _gensym", "_gensym" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:767"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                  ]
                                               ))
                                       )
                          end
                      }
                    if ( 
                      trampCall( self.__GTMARK_METHOD(  '>',
                          begin
                            if @global_lisp_binding.has_key?('__GTMARK') then
                              trampCall(@__GTMARK)
                            else raise NameError.new( "Error: undefined variable __GTMARK", "__GTMARK" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:775"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                          2                          ,
                            trampCall( self._length_METHOD(  'length',
                                begin
                                  if @global_lisp_binding.has_key?('_length') then
                                    trampCall(@_length)
                                  else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:775"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_lst)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:779"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                      ]
                                   ))
                     ) then
                        begin
                            trampCall( self._raise_METHOD(  'raise',
                                begin
                                  if @global_lisp_binding.has_key?('_raise') then
                                    trampCall(@_raise)
                                  else raise NameError.new( "Error: undefined variable _raise", "_raise" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:780"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(ArgumentError)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:776"] + __e.backtrace ) ; raise __e
                                  end                                ,
                                ". dot-operator requires 2+ arguments."                                ,
                                  trampCall( self._sprintf_METHOD(  'sprintf',
                                      begin
                                        if @global_lisp_binding.has_key?('_sprintf') then
                                          trampCall(@_sprintf)
                                        else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:780"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                      "%s:%s in dot-operator"                                      ,
                                        trampCall( self.__ASMARKFILE_ASMARK_METHOD(  '*FILE*',
                                            begin
                                              if @global_lisp_binding.has_key?('__ASMARKFILE_ASMARK') then
                                                trampCall(@__ASMARKFILE_ASMARK)
                                              else raise NameError.new( "Error: undefined variable __ASMARKFILE_ASMARK", "__ASMARKFILE_ASMARK" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:780"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                        ]
                                                     ))                                      ,
                                        trampCall( self.__ASMARKLINE_ASMARK_METHOD(  '*LINE*',
                                            begin
                                              if @global_lisp_binding.has_key?('__ASMARKLINE_ASMARK') then
                                                trampCall(@__ASMARKLINE_ASMARK)
                                              else raise NameError.new( "Error: undefined variable __ASMARKLINE_ASMARK", "__ASMARKLINE_ASMARK" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:780"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                        ]
                                                     ))
                                  ]
                                               ))
                            ]
                                         ))
                        end
                    else
                        if ( 
                        true
                         ) then
                            begin
                                if ( 
                                  trampCall( self._symbol_QUMARK_METHOD(  'symbol?',
                                      begin
                                        if @global_lisp_binding.has_key?('_symbol_QUMARK') then
                                          trampCall(@_symbol_QUMARK)
                                        else raise NameError.new( "Error: undefined variable _symbol_QUMARK", "_symbol_QUMARK" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:778"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        trampCall( self._second_METHOD(  'second',
                                            begin
                                              if @global_lisp_binding.has_key?('_second') then
                                                trampCall(@_second)
                                              else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:778"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_lst)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:779"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                  ]
                                               ))
                                 ) then
                                    trampCall( callProcedure(   'generate-method-call-form',
                                        begin
                                            trampCall(_generate_MIMARKmethod_MIMARKcall_MIMARKform)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:779"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_lst)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:779"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))
                                else
                                    trampCall( self._raise_METHOD(  'raise',
                                        begin
                                          if @global_lisp_binding.has_key?('_raise') then
                                            trampCall(@_raise)
                                          else raise NameError.new( "Error: undefined variable _raise", "_raise" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:780"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(TypeError)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:780"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                        ". dot-operator requires method name as symbol."                                        ,
                                          trampCall( self._sprintf_METHOD(  'sprintf',
                                              begin
                                                if @global_lisp_binding.has_key?('_sprintf') then
                                                  trampCall(@_sprintf)
                                                else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:780"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                              "%s:%s in dot-operator"                                              ,
                                                trampCall( self.__ASMARKFILE_ASMARK_METHOD(  '*FILE*',
                                                    begin
                                                      if @global_lisp_binding.has_key?('__ASMARKFILE_ASMARK') then
                                                        trampCall(@__ASMARKFILE_ASMARK)
                                                      else raise NameError.new( "Error: undefined variable __ASMARKFILE_ASMARK", "__ASMARKFILE_ASMARK" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:780"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                ]
                                                             ))                                              ,
                                                trampCall( self.__ASMARKLINE_ASMARK_METHOD(  '*LINE*',
                                                    begin
                                                      if @global_lisp_binding.has_key?('__ASMARKLINE_ASMARK') then
                                                        trampCall(@__ASMARKLINE_ASMARK)
                                                      else raise NameError.new( "Error: undefined variable __ASMARKLINE_ASMARK", "__ASMARKLINE_ASMARK" ) end
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:780"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                ]
                                                             ))
                                          ]
                                                       ))
                                    ]
                                                 ))
                                end
                            end
                        else
                            Cell.new()
                        end
                    end
                } ; ___lambda.call(
                nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._with_MIMARKopen_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_with_MIMARKopen'] = self.method( :_with_MIMARKopen_METHOD )
    @_with_MIMARKopen = 
    trampCall(
          Proc.new { |_filename,_pred,*__rest__| _lst = __rest__[0] ;  
              begin
                ___lambda = lambda { |_opt| 
                    if ( 
                      trampCall( self.__LTMARK_METHOD(  '<',
                          begin
                            if @global_lisp_binding.has_key?('__LTMARK') then
                              trampCall(@__LTMARK)
                            else raise NameError.new( "Error: undefined variable __LTMARK", "__LTMARK" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:785"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                          1                          ,
                            trampCall( self._length_METHOD(  'length',
                                begin
                                  if @global_lisp_binding.has_key?('_length') then
                                    trampCall(@_length)
                                  else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:785"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_lst)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:785"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                      ]
                                   ))
                     ) then
                        begin raise RuntimeError, 
                        "with-open requires 2 or 3 arguments."
                        rescue => __e 
                          __e.set_backtrace( ["./lib/init.nnd:786"] + __e.backtrace )
                          raise __e
                        end 
                    else
                        if ( 
                          begin
                              trampCall(_opt)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:788"] + __e.backtrace ) ; raise __e
                          end
                         ) then
                            begin
                                trampCall(Kernel).open(
                                      begin
                                          trampCall(_filename)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:789"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                      begin
                                          trampCall(_opt)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:788"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                      &Proc.new { |_f| 
                                          trampCall( callProcedure(   'pred',
                                              begin
                                                  trampCall(_pred)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:789"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_f)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:789"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))
                                      }
                                  )
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:789"] + __e.backtrace ) ; raise __e
                            end
                        else
                            begin
                                trampCall(Kernel).open(
                                      begin
                                          trampCall(_filename)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:789"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                      &Proc.new { |_f| 
                                          trampCall( callProcedure(   'pred',
                                              begin
                                                  trampCall(_pred)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:789"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_f)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:789"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))
                                      }
                                  )
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:789"] + __e.backtrace ) ; raise __e
                            end
                        end
                    end
                } ; ___lambda.call(
                      begin
                        ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20224| 
                            if ( 
                              trampCall( self._null_QUMARK_METHOD(  'null?',
                                  begin
                                    if @global_lisp_binding.has_key?('_null_QUMARK') then
                                      trampCall(@_null_QUMARK)
                                    else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:751"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20224)
                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                             ) then
                              false
                            else
                                delayCall( '_car',  'car',
                                    begin
                                      if @global_lisp_binding.has_key?('_car') then
                                        trampCall(@_car)
                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:757"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20224)
                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             )
                            end
                        } ; ___lambda.call(
                              begin
                                  trampCall(_lst)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:785"] + __e.backtrace ) ; raise __e
                              end
                                   )
                      end
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._last_MIMARKpair_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_last_MIMARKpair'] = self.method( :_last_MIMARKpair_METHOD )
    @_last_MIMARKpair = 
    trampCall(
          Proc.new { |_x| 
              if ( 
                trampCall( self._pair_QUMARK_METHOD(  'pair?',
                    begin
                      if @global_lisp_binding.has_key?('_pair_QUMARK') then
                        trampCall(@_pair_QUMARK)
                      else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:796"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      trampCall( self._cdr_METHOD(  'cdr',
                          begin
                            if @global_lisp_binding.has_key?('_cdr') then
                              trampCall(@_cdr)
                            else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:797"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_x)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:798"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                ]
                             ))
               ) then
                  delayCall( '_last_MIMARKpair',  'last-pair',
                      begin
                        if @global_lisp_binding.has_key?('_last_MIMARKpair') then
                          trampCall(@_last_MIMARKpair)
                        else raise NameError.new( "Error: undefined variable _last_MIMARKpair", "_last_MIMARKpair" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:797"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                        trampCall( self._cdr_METHOD(  'cdr',
                            begin
                              if @global_lisp_binding.has_key?('_cdr') then
                                trampCall(@_cdr)
                              else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:797"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(_x)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:798"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     ))
                  ]
                               )
              else
                  begin
                      trampCall(_x)
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:798"] + __e.backtrace ) ; raise __e
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._cons_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_cons_ASMARK'] = self.method( :_cons_ASMARK_METHOD )
    @_cons_ASMARK = 
    trampCall(
          Proc.new { |_arg,*__rest__| _args = __rest__[0] ;  
              if ( 
                trampCall( self._null_QUMARK_METHOD(  'null?',
                    begin
                      if @global_lisp_binding.has_key?('_null_QUMARK') then
                        trampCall(@_null_QUMARK)
                      else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:802"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      begin
                          trampCall(_args)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:804"] + __e.backtrace ) ; raise __e
                      end
                ]
                             ))
               ) then
                  begin
                      trampCall(_arg)
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:804"] + __e.backtrace ) ; raise __e
                  end
              else
                  delayCall( '_cons',  'cons',
                      begin
                        if @global_lisp_binding.has_key?('_cons') then
                          trampCall(@_cons)
                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:804"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                        begin
                            trampCall(_arg)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:804"] + __e.backtrace ) ; raise __e
                        end                      ,
                        trampCall( self._apply_METHOD(  'apply',
                            begin
                              if @global_lisp_binding.has_key?('_apply') then
                                trampCall(@_apply)
                              else raise NameError.new( "Error: undefined variable _apply", "_apply" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:804"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                if @global_lisp_binding.has_key?('_list_ASMARK') then
                                  trampCall(@_list_ASMARK)
                                else raise NameError.new( "Error: undefined variable _list_ASMARK", "_list_ASMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:804"] + __e.backtrace ) ; raise __e
                              end                            ,
                              begin
                                  trampCall(_args)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:804"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     ))
                  ]
                               )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._list_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_list_ASMARK'] = self.method( :_list_ASMARK_METHOD )
    @_list_ASMARK = 
    trampCall(
          begin
            if @global_lisp_binding.has_key?('_cons_ASMARK') then
              trampCall(@_cons_ASMARK)
            else raise NameError.new( "Error: undefined variable _cons_ASMARK", "_cons_ASMARK" ) end
            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:805"] + __e.backtrace ) ; raise __e
          end
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._make_MIMARKhash_MIMARKtable_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_make_MIMARKhash_MIMARKtable'] = self.method( :_make_MIMARKhash_MIMARKtable_METHOD )
    @_make_MIMARKhash_MIMARKtable = 
    trampCall(
          Proc.new { || 
              begin
                  trampCall(Hash).new(
                    )
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:812"] + __e.backtrace ) ; raise __e
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._hash_MIMARKtable_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_hash_MIMARKtable_QUMARK'] = self.method( :_hash_MIMARKtable_QUMARK_METHOD )
    @_hash_MIMARKtable_QUMARK = 
    trampCall(
          Proc.new { |_h| 
              begin
                  trampCall(_h).is_a?(
                        begin
                            trampCall(Hash)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:815"] + __e.backtrace ) ; raise __e
                        end
                    )
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:815"] + __e.backtrace ) ; raise __e
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._hash_MIMARKtable_MIMARKnum_MIMARKentries_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_hash_MIMARKtable_MIMARKnum_MIMARKentries'] = self.method( :_hash_MIMARKtable_MIMARKnum_MIMARKentries_METHOD )
    @_hash_MIMARKtable_MIMARKnum_MIMARKentries = 
    trampCall(
          Proc.new { |_h| 
              begin
                  trampCall(_h).length(
                    )
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:818"] + __e.backtrace ) ; raise __e
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._hash_MIMARKtable_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_hash_MIMARKtable'] = self.method( :_hash_MIMARKtable_METHOD )
    @_hash_MIMARKtable = 
    trampCall(
          Proc.new { |*__rest__| _kv_MIMARKlist = __rest__[0] ;  
              begin
                ___lambda = lambda { |_h| 
                    trampCall( self._for_MIMARKeach_METHOD(  'for-each',
                        begin
                          if @global_lisp_binding.has_key?('_for_MIMARKeach') then
                            trampCall(@_for_MIMARKeach)
                          else raise NameError.new( "Error: undefined variable _for_MIMARKeach", "_for_MIMARKeach" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:822"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          Proc.new { |_entry| 
                              trampCall( self._hash_MIMARKtable_MIMARKput_EXMARK_METHOD(  'hash-table-put!',
                                  begin
                                    if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKput_EXMARK') then
                                      trampCall(@_hash_MIMARKtable_MIMARKput_EXMARK)
                                    else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKput_EXMARK", "_hash_MIMARKtable_MIMARKput_EXMARK" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:824"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_h)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:826"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                    trampCall( self._car_METHOD(  'car',
                                        begin
                                          if @global_lisp_binding.has_key?('_car') then
                                            trampCall(@_car)
                                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:824"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_entry)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:824"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))                                  ,
                                    trampCall( self._cdr_METHOD(  'cdr',
                                        begin
                                          if @global_lisp_binding.has_key?('_cdr') then
                                            trampCall(@_cdr)
                                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:824"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_entry)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:824"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))
                              ]
                                           ))
                          }                        ,
                          begin
                              trampCall(_kv_MIMARKlist)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:825"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
                    begin
                        trampCall(_h)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:826"] + __e.backtrace ) ; raise __e
                    end
                } ; ___lambda.call(
                      trampCall( self._make_MIMARKhash_MIMARKtable_METHOD(  'make-hash-table',
                          begin
                            if @global_lisp_binding.has_key?('_make_MIMARKhash_MIMARKtable') then
                              trampCall(@_make_MIMARKhash_MIMARKtable)
                            else raise NameError.new( "Error: undefined variable _make_MIMARKhash_MIMARKtable", "_make_MIMARKhash_MIMARKtable" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:821"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                      ]
                                   ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._hash_MIMARKtable_MIMARKclear_EXMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_hash_MIMARKtable_MIMARKclear_EXMARK'] = self.method( :_hash_MIMARKtable_MIMARKclear_EXMARK_METHOD )
    @_hash_MIMARKtable_MIMARKclear_EXMARK = 
    trampCall(
          Proc.new { |_h| 
              begin
                  trampCall(_h).clear(
                    )
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:829"] + __e.backtrace ) ; raise __e
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._hash_MIMARKtable_MIMARKdelete_EXMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_hash_MIMARKtable_MIMARKdelete_EXMARK'] = self.method( :_hash_MIMARKtable_MIMARKdelete_EXMARK_METHOD )
    @_hash_MIMARKtable_MIMARKdelete_EXMARK = 
    trampCall(
          Proc.new { |_h,_key| 
              begin
                  trampCall(_h).delete(
                        begin
                            trampCall(_key)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:832"] + __e.backtrace ) ; raise __e
                        end
                    )
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:832"] + __e.backtrace ) ; raise __e
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._hash_MIMARKtable_MIMARKpush_EXMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_hash_MIMARKtable_MIMARKpush_EXMARK'] = self.method( :_hash_MIMARKtable_MIMARKpush_EXMARK_METHOD )
    @_hash_MIMARKtable_MIMARKpush_EXMARK = 
    trampCall(
          Proc.new { |_ht,_key,_value| 
              delayCall( '_hash_MIMARKtable_MIMARKput_EXMARK',  'hash-table-put!',
                  begin
                    if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKput_EXMARK') then
                      trampCall(@_hash_MIMARKtable_MIMARKput_EXMARK)
                    else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKput_EXMARK", "_hash_MIMARKtable_MIMARKput_EXMARK" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:835"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(_ht)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:838"] + __e.backtrace ) ; raise __e
                    end                  ,
                    begin
                        trampCall(_key)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:838"] + __e.backtrace ) ; raise __e
                    end                  ,
                    trampCall( self._cons_METHOD(  'cons',
                        begin
                          if @global_lisp_binding.has_key?('_cons') then
                            trampCall(@_cons)
                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:838"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_value)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:838"] + __e.backtrace ) ; raise __e
                          end                        ,
                          trampCall( self._hash_MIMARKtable_MIMARKget_METHOD(  'hash-table-get',
                              begin
                                if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKget') then
                                  trampCall(@_hash_MIMARKtable_MIMARKget)
                                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKget", "_hash_MIMARKtable_MIMARKget" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:838"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_ht)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:838"] + __e.backtrace ) ; raise __e
                                end                              ,
                                begin
                                    trampCall(_key)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:838"] + __e.backtrace ) ; raise __e
                                end                              ,
                              Cell.new()
                          ]
                                       ))
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._hash_MIMARKtable_MIMARKkeys_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_hash_MIMARKtable_MIMARKkeys'] = self.method( :_hash_MIMARKtable_MIMARKkeys_METHOD )
    @_hash_MIMARKtable_MIMARKkeys = 
    trampCall(
          Proc.new { |_h| 
              delayCall( '_to_MIMARKlist',  'to-list',
                  begin
                    if @global_lisp_binding.has_key?('_to_MIMARKlist') then
                      trampCall(@_to_MIMARKlist)
                    else raise NameError.new( "Error: undefined variable _to_MIMARKlist", "_to_MIMARKlist" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:841"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(_h).keys(
                          )
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:841"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._hash_MIMARKtable_MIMARKvalues_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_hash_MIMARKtable_MIMARKvalues'] = self.method( :_hash_MIMARKtable_MIMARKvalues_METHOD )
    @_hash_MIMARKtable_MIMARKvalues = 
    trampCall(
          Proc.new { |_h| 
              delayCall( '_to_MIMARKlist',  'to-list',
                  begin
                    if @global_lisp_binding.has_key?('_to_MIMARKlist') then
                      trampCall(@_to_MIMARKlist)
                    else raise NameError.new( "Error: undefined variable _to_MIMARKlist", "_to_MIMARKlist" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:844"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(_h).values(
                          )
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:844"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._hash_MIMARKtable_MIMARKmap_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_hash_MIMARKtable_MIMARKmap'] = self.method( :_hash_MIMARKtable_MIMARKmap_METHOD )
    @_hash_MIMARKtable_MIMARKmap = 
    trampCall(
          Proc.new { |_h,_pred| 
              begin
                ___lambda = lambda { |_keys| 
                    delayCall( '_map',  'map',
                        begin
                          if @global_lisp_binding.has_key?('_map') then
                            trampCall(@_map)
                          else raise NameError.new( "Error: undefined variable _map", "_map" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:848"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          Proc.new { |_key| 
                              trampCall( callProcedure(   'pred',
                                  begin
                                      trampCall(_pred)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:850"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_key)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:850"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                    trampCall( self._hash_MIMARKtable_MIMARKget_METHOD(  'hash-table-get',
                                        begin
                                          if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKget') then
                                            trampCall(@_hash_MIMARKtable_MIMARKget)
                                          else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKget", "_hash_MIMARKtable_MIMARKget" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:850"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_h)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:850"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                          begin
                                              trampCall(_key)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:850"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))
                              ]
                                           ))
                          }                        ,
                          begin
                              trampCall(_keys)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:851"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 )
                } ; ___lambda.call(
                      trampCall( self._hash_MIMARKtable_MIMARKkeys_METHOD(  'hash-table-keys',
                          begin
                            if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKkeys') then
                              trampCall(@_hash_MIMARKtable_MIMARKkeys)
                            else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKkeys", "_hash_MIMARKtable_MIMARKkeys" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:847"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_h)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:850"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._hash_MIMARKtable_MIMARKfor_MIMARKeach_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_hash_MIMARKtable_MIMARKfor_MIMARKeach'] = self.method( :_hash_MIMARKtable_MIMARKfor_MIMARKeach_METHOD )
    @_hash_MIMARKtable_MIMARKfor_MIMARKeach = 
    trampCall(
          begin
            if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKmap') then
              trampCall(@_hash_MIMARKtable_MIMARKmap)
            else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKmap", "_hash_MIMARKtable_MIMARKmap" ) end
            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:852"] + __e.backtrace ) ; raise __e
          end
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._hash_MIMARKtable_MIMARK_GTMARKalist_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_hash_MIMARKtable_MIMARK_GTMARKalist'] = self.method( :_hash_MIMARKtable_MIMARK_GTMARKalist_METHOD )
    @_hash_MIMARKtable_MIMARK_GTMARKalist = 
    trampCall(
          Proc.new { |_h| 
              if ( 
                trampCall( self._not_METHOD(  'not',
                    begin
                      if @global_lisp_binding.has_key?('_not') then
                        trampCall(@_not)
                      else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:855"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      begin
                          trampCall(_h).is_a?(
                                begin
                                    trampCall(Hash)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:855"] + __e.backtrace ) ; raise __e
                                end
                            )
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:855"] + __e.backtrace ) ; raise __e
                      end
                ]
                             ))
               ) then
                  begin raise RuntimeError, 
                  "Error: hash-table->alist expects Hash instance."
                  rescue => __e 
                    __e.set_backtrace( ["./lib/init.nnd:856"] + __e.backtrace )
                    raise __e
                  end 
              else
                  begin
                    ___lambda = lambda { |_keys| 
                        delayCall( '_map',  'map',
                            begin
                              if @global_lisp_binding.has_key?('_map') then
                                trampCall(@_map)
                              else raise NameError.new( "Error: undefined variable _map", "_map" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:858"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              Proc.new { |_key| 
                                  trampCall( self._cons_METHOD(  'cons',
                                      begin
                                        if @global_lisp_binding.has_key?('_cons') then
                                          trampCall(@_cons)
                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:860"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(_key)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:860"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                        trampCall( self._hash_MIMARKtable_MIMARKget_METHOD(  'hash-table-get',
                                            begin
                                              if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKget') then
                                                trampCall(@_hash_MIMARKtable_MIMARKget)
                                              else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKget", "_hash_MIMARKtable_MIMARKget" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:860"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_h)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:860"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                              begin
                                                  trampCall(_key)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:860"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                  ]
                                               ))
                              }                            ,
                              begin
                                  trampCall(_keys)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:861"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     )
                    } ; ___lambda.call(
                          trampCall( self._hash_MIMARKtable_MIMARKkeys_METHOD(  'hash-table-keys',
                              begin
                                if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKkeys') then
                                  trampCall(@_hash_MIMARKtable_MIMARKkeys)
                                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKkeys", "_hash_MIMARKtable_MIMARKkeys" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:857"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_h)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:860"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                               )
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._alist_MIMARK_GTMARKhash_MIMARKtable_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_alist_MIMARK_GTMARKhash_MIMARKtable'] = self.method( :_alist_MIMARK_GTMARKhash_MIMARKtable_METHOD )
    @_alist_MIMARK_GTMARKhash_MIMARKtable = 
    trampCall(
          Proc.new { |_alist| 
              if ( 
                trampCall( self._not_METHOD(  'not',
                    begin
                      if @global_lisp_binding.has_key?('_not') then
                        trampCall(@_not)
                      else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:864"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      trampCall( self.__PAMARKlist_QUMARK_METHOD(  '%list?',
                          begin
                            if @global_lisp_binding.has_key?('__PAMARKlist_QUMARK') then
                              trampCall(@__PAMARKlist_QUMARK)
                            else raise NameError.new( "Error: undefined variable __PAMARKlist_QUMARK", "__PAMARKlist_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:864"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_alist)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:866"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                ]
                             ))
               ) then
                  begin raise RuntimeError, 
                  "Error: alist->hash-table expects alist."
                  rescue => __e 
                    __e.set_backtrace( ["./lib/init.nnd:865"] + __e.backtrace )
                    raise __e
                  end 
              else
                  delayCall( '_apply',  'apply',
                      begin
                        if @global_lisp_binding.has_key?('_apply') then
                          trampCall(@_apply)
                        else raise NameError.new( "Error: undefined variable _apply", "_apply" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:866"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                        begin
                          if @global_lisp_binding.has_key?('_hash_MIMARKtable') then
                            trampCall(@_hash_MIMARKtable)
                          else raise NameError.new( "Error: undefined variable _hash_MIMARKtable", "_hash_MIMARKtable" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:866"] + __e.backtrace ) ; raise __e
                        end                      ,
                        begin
                            trampCall(_alist)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:866"] + __e.backtrace ) ; raise __e
                        end
                  ]
                               )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._vector_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_vector_QUMARK'] = self.method( :_vector_QUMARK_METHOD )
    @_vector_QUMARK = 
    trampCall(
          Proc.new { |_v| 
              begin
                  trampCall(_v).is_a?(
                        begin
                            trampCall(Array)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:873"] + __e.backtrace ) ; raise __e
                        end
                    )
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:873"] + __e.backtrace ) ; raise __e
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._make_MIMARKvector_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_make_MIMARKvector'] = self.method( :_make_MIMARKvector_METHOD )
    @_make_MIMARKvector = 
    trampCall(
          Proc.new { |_k,*__rest__| _rest = __rest__[0] ;  
              if ( 
                trampCall( self._null_QUMARK_METHOD(  'null?',
                    begin
                      if @global_lisp_binding.has_key?('_null_QUMARK') then
                        trampCall(@_null_QUMARK)
                      else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:876"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      begin
                          trampCall(_rest)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:878"] + __e.backtrace ) ; raise __e
                      end
                ]
                             ))
               ) then
                  begin
                      trampCall(Array).new(
                            begin
                                trampCall(_k)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:878"] + __e.backtrace ) ; raise __e
                            end
                        )
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:878"] + __e.backtrace ) ; raise __e
                  end
              else
                  begin
                      trampCall(Array).new(
                            begin
                                trampCall(_k)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:878"] + __e.backtrace ) ; raise __e
                            end                          ,
                            trampCall( self._car_METHOD(  'car',
                                begin
                                  if @global_lisp_binding.has_key?('_car') then
                                    trampCall(@_car)
                                  else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:878"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_rest)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:878"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                        )
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:878"] + __e.backtrace ) ; raise __e
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._vector_MIMARKlength_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_vector_MIMARKlength'] = self.method( :_vector_MIMARKlength_METHOD )
    @_vector_MIMARKlength = 
    trampCall(
          Proc.new { |_v| 
              begin
                  trampCall(_v).size(
                    )
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:881"] + __e.backtrace ) ; raise __e
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._vector_MIMARKcopy_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_vector_MIMARKcopy'] = self.method( :_vector_MIMARKcopy_METHOD )
    @_vector_MIMARKcopy = 
    trampCall(
          Proc.new { |_v| 
              begin
                  trampCall(_v).clone(
                    )
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:884"] + __e.backtrace ) ; raise __e
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._vector_MIMARKref_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_vector_MIMARKref'] = self.method( :_vector_MIMARKref_METHOD )
    @_vector_MIMARKref = 
    trampCall(
          Proc.new { |_v,_index,*__rest__| _fallback = __rest__[0] ;  
              if ( 
                if ( 
                  trampCall( self._not_METHOD(  'not',
                      begin
                        if @global_lisp_binding.has_key?('_not') then
                          trampCall(@_not)
                        else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:864"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                        trampCall( self._eq_QUMARK_METHOD(  'eq?',
                            begin
                              if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                trampCall(@_eq_QUMARK)
                              else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:747"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                            false                            ,
                              trampCall( self.__LTMARK_EQMARK_METHOD(  '<=',
                                  begin
                                    if @global_lisp_binding.has_key?('__LTMARK_EQMARK') then
                                      trampCall(@__LTMARK_EQMARK)
                                    else raise NameError.new( "Error: undefined variable __LTMARK_EQMARK", "__LTMARK_EQMARK" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:887"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                  0                                  ,
                                    begin
                                        trampCall(_index)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:890"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                        ]
                                     ))
                  ]
                               ))
                 ) then
                    trampCall( self.__LTMARK_METHOD(  '<',
                        begin
                          if @global_lisp_binding.has_key?('__LTMARK') then
                            trampCall(@__LTMARK)
                          else raise NameError.new( "Error: undefined variable __LTMARK", "__LTMARK" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:887"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_index)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:890"] + __e.backtrace ) ; raise __e
                          end                        ,
                          begin
                              trampCall(_v).size
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:887"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
                else
                  false
                end
               ) then
                  begin
                      trampCall(_v).fetch(
                            begin
                                trampCall(_index)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:890"] + __e.backtrace ) ; raise __e
                            end
                        )
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:888"] + __e.backtrace ) ; raise __e
                  end
              else
                  if ( 
                    trampCall( self._null_QUMARK_METHOD(  'null?',
                        begin
                          if @global_lisp_binding.has_key?('_null_QUMARK') then
                            trampCall(@_null_QUMARK)
                          else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:889"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_fallback)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:891"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
                   ) then
                      begin raise RuntimeError, 
                        trampCall( self._sprintf_METHOD(  'sprintf',
                            begin
                              if @global_lisp_binding.has_key?('_sprintf') then
                                trampCall(@_sprintf)
                              else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:780"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                            "Error: vector-ref  index value is overflow: %s
"                            ,
                              begin
                                  trampCall(_index)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:890"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     ))
                      rescue => __e 
                        __e.set_backtrace( ["./lib/init.nnd:865"] + __e.backtrace )
                        raise __e
                      end 
                  else
                      delayCall( '_car',  'car',
                          begin
                            if @global_lisp_binding.has_key?('_car') then
                              trampCall(@_car)
                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:891"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_fallback)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:891"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   )
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._vector_MIMARKequal_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_vector_MIMARKequal_QUMARK'] = self.method( :_vector_MIMARKequal_QUMARK_METHOD )
    @_vector_MIMARKequal_QUMARK = 
    trampCall(
          Proc.new { |_x,_y| 
              if ( 
                trampCall( self._not_METHOD(  'not',
                    begin
                      if @global_lisp_binding.has_key?('_not') then
                        trampCall(@_not)
                      else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:864"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      trampCall( self._eq_QUMARK_METHOD(  'eq?',
                          begin
                            if @global_lisp_binding.has_key?('_eq_QUMARK') then
                              trampCall(@_eq_QUMARK)
                            else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:747"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                          false                          ,
                            trampCall( self._vector_QUMARK_METHOD(  'vector?',
                                begin
                                  if @global_lisp_binding.has_key?('_vector_QUMARK') then
                                    trampCall(@_vector_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _vector_QUMARK", "_vector_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:897"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_x)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:902"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                      ]
                                   ))
                ]
                             ))
               ) then
                  if ( 
                    trampCall( self._not_METHOD(  'not',
                        begin
                          if @global_lisp_binding.has_key?('_not') then
                            trampCall(@_not)
                          else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:864"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._eq_QUMARK_METHOD(  'eq?',
                              begin
                                if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                  trampCall(@_eq_QUMARK)
                                else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:747"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                              false                              ,
                                trampCall( self._vector_QUMARK_METHOD(  'vector?',
                                    begin
                                      if @global_lisp_binding.has_key?('_vector_QUMARK') then
                                        trampCall(@_vector_QUMARK)
                                      else raise NameError.new( "Error: undefined variable _vector_QUMARK", "_vector_QUMARK" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:897"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_y)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:902"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
                   ) then
                      if ( 
                        trampCall( self._not_METHOD(  'not',
                            begin
                              if @global_lisp_binding.has_key?('_not') then
                                trampCall(@_not)
                              else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:864"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                  begin
                                    if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                      trampCall(@_eq_QUMARK)
                                    else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:747"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                  false                                  ,
                                    trampCall( self.__EQMARK_METHOD(  '=',
                                        begin
                                          if @global_lisp_binding.has_key?('__EQMARK') then
                                            trampCall(@__EQMARK)
                                          else raise NameError.new( "Error: undefined variable __EQMARK", "__EQMARK" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:900"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          trampCall( self._vector_MIMARKlength_METHOD(  'vector-length',
                                              begin
                                                if @global_lisp_binding.has_key?('_vector_MIMARKlength') then
                                                  trampCall(@_vector_MIMARKlength)
                                                else raise NameError.new( "Error: undefined variable _vector_MIMARKlength", "_vector_MIMARKlength" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:898"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_x)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:902"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))                                        ,
                                          trampCall( self._vector_MIMARKlength_METHOD(  'vector-length',
                                              begin
                                                if @global_lisp_binding.has_key?('_vector_MIMARKlength') then
                                                  trampCall(@_vector_MIMARKlength)
                                                else raise NameError.new( "Error: undefined variable _vector_MIMARKlength", "_vector_MIMARKlength" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:898"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_y)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:902"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))
                                    ]
                                                 ))
                              ]
                                           ))
                        ]
                                     ))
                       ) then
                          begin
                            ___lambda = lambda { |_n| 
                                begin
                                  ___lambda = lambda { |_loop| 
                                      _loop                                       = 
                                        Proc.new { |_i| 
                                            if ( 
                                              trampCall( self.__EQMARK_METHOD(  '=',
                                                  begin
                                                    if @global_lisp_binding.has_key?('__EQMARK') then
                                                      trampCall(@__EQMARK)
                                                    else raise NameError.new( "Error: undefined variable __EQMARK", "__EQMARK" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:900"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                    begin
                                                        trampCall(_i)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:903"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                    begin
                                                        trampCall(_n)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:900"] + __e.backtrace ) ; raise __e
                                                    end
                                              ]
                                                           ))
                                             ) then
                                              true
                                            else
                                                if ( 
                                                  trampCall( self._not_METHOD(  'not',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_not') then
                                                          trampCall(@_not)
                                                        else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:864"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                                trampCall(@_eq_QUMARK)
                                                              else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:747"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                            false                                                            ,
                                                              trampCall( self._equal_QUMARK_METHOD(  'equal?',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_equal_QUMARK') then
                                                                      trampCall(@_equal_QUMARK)
                                                                    else raise NameError.new( "Error: undefined variable _equal_QUMARK", "_equal_QUMARK" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:902"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                    trampCall( self._vector_MIMARKref_METHOD(  'vector-ref',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_vector_MIMARKref') then
                                                                            trampCall(@_vector_MIMARKref)
                                                                          else raise NameError.new( "Error: undefined variable _vector_MIMARKref", "_vector_MIMARKref" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:902"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          begin
                                                                              trampCall(_x)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:902"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                          begin
                                                                              trampCall(_i)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:903"] + __e.backtrace ) ; raise __e
                                                                          end
                                                                    ]
                                                                                 ))                                                                  ,
                                                                    trampCall( self._vector_MIMARKref_METHOD(  'vector-ref',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_vector_MIMARKref') then
                                                                            trampCall(@_vector_MIMARKref)
                                                                          else raise NameError.new( "Error: undefined variable _vector_MIMARKref", "_vector_MIMARKref" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:902"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          begin
                                                                              trampCall(_y)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:902"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                          begin
                                                                              trampCall(_i)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:903"] + __e.backtrace ) ; raise __e
                                                                          end
                                                                    ]
                                                                                 ))
                                                              ]
                                                                           ))
                                                        ]
                                                                     ))
                                                  ]
                                                               ))
                                                 ) then
                                                    delayCall( '_loop',  'loop',
                                                        begin
                                                            trampCall(_loop)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:903"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          trampCall( self._succ_METHOD(  'succ',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_succ') then
                                                                  trampCall(@_succ)
                                                                else raise NameError.new( "Error: undefined variable _succ", "_succ" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:903"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                                begin
                                                                    trampCall(_i)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:903"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))
                                                    ]
                                                                 )
                                                else
                                                  false
                                                end
                                            end
                                        }
                                      delayCall( '_loop',  'loop',
                                          begin
                                              trampCall(_loop)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:903"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                          0
                                      ]
                                                   )
                                  } ; ___lambda.call(
                                  nil
                                             )
                                end
                            } ; ___lambda.call(
                                  trampCall( self._vector_MIMARKlength_METHOD(  'vector-length',
                                      begin
                                        if @global_lisp_binding.has_key?('_vector_MIMARKlength') then
                                          trampCall(@_vector_MIMARKlength)
                                        else raise NameError.new( "Error: undefined variable _vector_MIMARKlength", "_vector_MIMARKlength" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:898"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(_x)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:902"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                                       )
                          end
                      else
                        false
                      end
                  else
                    false
                  end
              else
                false
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._list_MIMARK_GTMARKvector_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_list_MIMARK_GTMARKvector'] = self.method( :_list_MIMARK_GTMARKvector_METHOD )
    @_list_MIMARK_GTMARKvector = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_apply',  'apply',
                  begin
                    if @global_lisp_binding.has_key?('_apply') then
                      trampCall(@_apply)
                    else raise NameError.new( "Error: undefined variable _apply", "_apply" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:906"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                      if @global_lisp_binding.has_key?('_vector') then
                        trampCall(@_vector)
                      else raise NameError.new( "Error: undefined variable _vector", "_vector" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:906"] + __e.backtrace ) ; raise __e
                    end                  ,
                    begin
                        trampCall(_x)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:906"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._vector_MIMARKfill_EXMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_vector_MIMARKfill_EXMARK'] = self.method( :_vector_MIMARKfill_EXMARK_METHOD )
    @_vector_MIMARKfill_EXMARK = 
    trampCall(
          Proc.new { |_v,_e| 
              begin
                ___lambda = lambda { |_n| 
                    begin
                      ___lambda = lambda { |_loop| 
                          _loop                           = 
                            Proc.new { |_i| 
                                if ( 
                                  trampCall( self.__EQMARK_METHOD(  '=',
                                      begin
                                        if @global_lisp_binding.has_key?('__EQMARK') then
                                          trampCall(@__EQMARK)
                                        else raise NameError.new( "Error: undefined variable __EQMARK", "__EQMARK" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:911"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(_i)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:913"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                        begin
                                            trampCall(_n)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:911"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                                 ) then
                                    begin
                                        trampCall(_v)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:913"] + __e.backtrace ) ; raise __e
                                    end
                                else
                                    begin
                                        trampCall( self._vector_MIMARKset_EXMARK_METHOD(  'vector-set!',
                                            begin
                                              if @global_lisp_binding.has_key?('_vector_MIMARKset_EXMARK') then
                                                trampCall(@_vector_MIMARKset_EXMARK)
                                              else raise NameError.new( "Error: undefined variable _vector_MIMARKset_EXMARK", "_vector_MIMARKset_EXMARK" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:913"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_v)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:913"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                              begin
                                                  trampCall(_i)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:913"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                              begin
                                                  trampCall(_e)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:913"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                        delayCall( '_loop',  'loop',
                                            begin
                                                trampCall(_loop)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:913"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              trampCall( self._succ_METHOD(  'succ',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_succ') then
                                                      trampCall(@_succ)
                                                    else raise NameError.new( "Error: undefined variable _succ", "_succ" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:913"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                    begin
                                                        trampCall(_i)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:913"] + __e.backtrace ) ; raise __e
                                                    end
                                              ]
                                                           ))
                                        ]
                                                     )
                                    end
                                end
                            }
                          delayCall( '_loop',  'loop',
                              begin
                                  trampCall(_loop)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:913"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                              0
                          ]
                                       )
                      } ; ___lambda.call(
                      nil
                                 )
                    end
                } ; ___lambda.call(
                      trampCall( self._vector_MIMARKlength_METHOD(  'vector-length',
                          begin
                            if @global_lisp_binding.has_key?('_vector_MIMARKlength') then
                              trampCall(@_vector_MIMARKlength)
                            else raise NameError.new( "Error: undefined variable _vector_MIMARKlength", "_vector_MIMARKlength" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:909"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_v)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:913"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._vector_MIMARK_GTMARKlist_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_vector_MIMARK_GTMARKlist'] = self.method( :_vector_MIMARK_GTMARKlist_METHOD )
    @_vector_MIMARK_GTMARKlist = 
    trampCall(
          Proc.new { |_v| 
              begin
                ___lambda = lambda { |_loop| 
                    _loop                     = 
                      Proc.new { |_n,_l| 
                          if ( 
                            trampCall( self.__EQMARK_METHOD(  '=',
                                begin
                                  if @global_lisp_binding.has_key?('__EQMARK') then
                                    trampCall(@__EQMARK)
                                  else raise NameError.new( "Error: undefined variable __EQMARK", "__EQMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:917"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_n)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                  end                                ,
                                -1
                            ]
                                         ))
                           ) then
                              begin
                                  trampCall(_l)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                              end
                          else
                              delayCall( '_loop',  'loop',
                                  begin
                                      trampCall(_loop)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    trampCall( self._pred_METHOD(  'pred',
                                        begin
                                          if @global_lisp_binding.has_key?('_pred') then
                                            trampCall(@_pred)
                                          else raise NameError.new( "Error: undefined variable _pred", "_pred" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_n)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))                                  ,
                                    trampCall( self._cons_METHOD(  'cons',
                                        begin
                                          if @global_lisp_binding.has_key?('_cons') then
                                            trampCall(@_cons)
                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          trampCall( self._vector_MIMARKref_METHOD(  'vector-ref',
                                              begin
                                                if @global_lisp_binding.has_key?('_vector_MIMARKref') then
                                                  trampCall(@_vector_MIMARKref)
                                                else raise NameError.new( "Error: undefined variable _vector_MIMARKref", "_vector_MIMARKref" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_v)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                                begin
                                                    trampCall(_n)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))                                        ,
                                          begin
                                              trampCall(_l)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))
                              ]
                                           )
                          end
                      }
                    delayCall( '_loop',  'loop',
                        begin
                            trampCall(_loop)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          trampCall( self._pred_METHOD(  'pred',
                              begin
                                if @global_lisp_binding.has_key?('_pred') then
                                  trampCall(@_pred)
                                else raise NameError.new( "Error: undefined variable _pred", "_pred" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._vector_MIMARKlength_METHOD(  'vector-length',
                                    begin
                                      if @global_lisp_binding.has_key?('_vector_MIMARKlength') then
                                        trampCall(@_vector_MIMARKlength)
                                      else raise NameError.new( "Error: undefined variable _vector_MIMARKlength", "_vector_MIMARKlength" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:916"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_v)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))                        ,
                        Cell.new()
                    ]
                                 )
                } ; ___lambda.call(
                nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self.__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK'] = self.method( :__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK_METHOD )
    @__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK = 
    trampCall(
        63
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._debug_MIMARKprint_MIMARKlength_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_debug_MIMARKprint_MIMARKlength'] = self.method( :_debug_MIMARKprint_MIMARKlength_METHOD )
    @_debug_MIMARKprint_MIMARKlength = 
    trampCall(
          Proc.new { |*__rest__| _len = __rest__[0] ;  
              begin
                ___lambda = lambda { |_len| 
                    if ( 
                      trampCall( self._eq_QUMARK_METHOD(  'eq?',
                          begin
                            if @global_lisp_binding.has_key?('_eq_QUMARK') then
                              trampCall(@_eq_QUMARK)
                            else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:929"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_len)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:931"] + __e.backtrace ) ; raise __e
                            end                          ,
                          :"none"
                      ]
                                   ))
                     ) then
                        begin
                          if @global_lisp_binding.has_key?('__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK') then
                            trampCall(@__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK)
                          else raise NameError.new( "Error: undefined variable __ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK", "__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:931"] + __e.backtrace ) ; raise __e
                        end
                    else
                        begin
                            def self.__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
                            @global_lisp_binding['__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK'] = self.method( :__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK_METHOD )
                          @__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK = 
                          trampCall(
                                begin
                                    trampCall(_len)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:931"] + __e.backtrace ) ; raise __e
                                end
                          )
                        end
                    end
                } ; ___lambda.call(
                      begin
                        ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20225| 
                            if ( 
                              trampCall( self._null_QUMARK_METHOD(  'null?',
                                  begin
                                    if @global_lisp_binding.has_key?('_null_QUMARK') then
                                      trampCall(@_null_QUMARK)
                                    else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:889"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20225)
                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                             ) then
                              :"none"
                            else
                                delayCall( '_car',  'car',
                                    begin
                                      if @global_lisp_binding.has_key?('_car') then
                                        trampCall(@_car)
                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:891"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20225)
                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             )
                            end
                        } ; ___lambda.call(
                              begin
                                  trampCall(_len)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:931"] + __e.backtrace ) ; raise __e
                              end
                                   )
                      end
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._debug_MIMARKprint_MIMARKoutput_MIMARKfunc_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_debug_MIMARKprint_MIMARKoutput_MIMARKfunc'] = self.method( :_debug_MIMARKprint_MIMARKoutput_MIMARKfunc_METHOD )
    @_debug_MIMARKprint_MIMARKoutput_MIMARKfunc = 
    trampCall(
          Proc.new { |_str| 
              begin
                  trampCall(STDERR).print(
                        begin
                            trampCall(_str)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:933"] + __e.backtrace ) ; raise __e
                        end
                    )
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:933"] + __e.backtrace ) ; raise __e
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._debug_MIMARKlimit_MIMARKlength_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_debug_MIMARKlimit_MIMARKlength'] = self.method( :_debug_MIMARKlimit_MIMARKlength_METHOD )
    @_debug_MIMARKlimit_MIMARKlength = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '__PLMARK',  '+',
                  begin
                    if @global_lisp_binding.has_key?('__PLMARK') then
                      trampCall(@__PLMARK)
                    else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:941"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    if ( 
                      trampCall( self._not_METHOD(  'not',
                          begin
                            if @global_lisp_binding.has_key?('_not') then
                              trampCall(@_not)
                            else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:937"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                              if @global_lisp_binding.has_key?('__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK') then
                                trampCall(@__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK)
                              else raise NameError.new( "Error: undefined variable __ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK", "__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:939"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                     ) then
                        begin
                            begin
                                trampCall(_x)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:943"] + __e.backtrace ) ; raise __e
                            end
                        end
                    else
                        if ( 
                          trampCall( self.__LTMARK_METHOD(  '<',
                              begin
                                if @global_lisp_binding.has_key?('__LTMARK') then
                                  trampCall(@__LTMARK)
                                else raise NameError.new( "Error: undefined variable __LTMARK", "__LTMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:939"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                  if @global_lisp_binding.has_key?('__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK') then
                                    trampCall(@__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK)
                                  else raise NameError.new( "Error: undefined variable __ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK", "__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:939"] + __e.backtrace ) ; raise __e
                                end                              ,
                                begin
                                    trampCall(_x).length
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:939"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                         ) then
                            begin
                                begin
                                  ___lambda = lambda { |_n| 
                                      trampCall( self._sprintf_METHOD(  'sprintf',
                                          begin
                                            if @global_lisp_binding.has_key?('_sprintf') then
                                              trampCall(@_sprintf)
                                            else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:941"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            trampCall( self.__PLMARK_METHOD(  '+',
                                                begin
                                                  if @global_lisp_binding.has_key?('__PLMARK') then
                                                    trampCall(@__PLMARK)
                                                  else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:941"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                "%"                                                ,
                                                  begin
                                                      trampCall(_n)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:941"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                                "."                                                ,
                                                  begin
                                                      trampCall(_n)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:941"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                                "s ..."
                                            ]
                                                         ))                                          ,
                                            begin
                                                trampCall(_x)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:943"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                  } ; ___lambda.call(
                                        begin
                                          if @global_lisp_binding.has_key?('__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK') then
                                            trampCall(@__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK).to_s
                                          else raise NameError.new( "Error: undefined variable __ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK", "__ASMARKdebug_MIMARKprint_MIMARKlength_ASMARK" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:940"] + __e.backtrace ) ; raise __e
                                        end
                                             )
                                end
                            end
                        else
                            if ( 
                            true
                             ) then
                                begin
                                    begin
                                        trampCall(_x)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:943"] + __e.backtrace ) ; raise __e
                                    end
                                end
                            else
                                Cell.new()
                            end
                        end
                    end                  ,
                  "
"
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._debug_MIMARKprint_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_debug_MIMARKprint'] = self.method( :_debug_MIMARKprint_METHOD )
    @_debug_MIMARKprint = 
    trampCall(
          LispMacro.new { |__form,_sourcefile,_lineno,_sourcesexp| 
              begin
                ___lambda = lambda { |_val| 
                    trampCall( self._cons_METHOD(  'cons',
                        begin
                          if @global_lisp_binding.has_key?('_cons') then
                            trampCall(@_cons)
                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        :"let"                        ,
                          trampCall( self._cons_METHOD(  'cons',
                              begin
                                if @global_lisp_binding.has_key?('_cons') then
                                  trampCall(@_cons)
                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      trampCall( self._cons_METHOD(  'cons',
                                          begin
                                            if @global_lisp_binding.has_key?('_cons') then
                                              trampCall(@_cons)
                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_val)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:953"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                          Cell.new(nil)
                                      ]
                                                   ))                                    ,
                                    Cell.new()
                                ]
                                             ))                              ,
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      trampCall( self._cons_METHOD(  'cons',
                                          begin
                                            if @global_lisp_binding.has_key?('_cons') then
                                              trampCall(@_cons)
                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                          :"debug-print-output-func"                                          ,
                                            trampCall( self._cons_METHOD(  'cons',
                                                begin
                                                  if @global_lisp_binding.has_key?('_cons') then
                                                    trampCall(@_cons)
                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  trampCall( self._cons_METHOD(  'cons',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cons') then
                                                          trampCall(@_cons)
                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                      :"debug-limit-length"                                                      ,
                                                        trampCall( self._cons_METHOD(  'cons',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                trampCall(@_cons)
                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              trampCall( self._cons_METHOD(  'cons',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                      trampCall(@_cons)
                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                  :"sprintf"                                                                  ,
                                                                    trampCall( self._cons_METHOD(  'cons',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_cons') then
                                                                            trampCall(@_cons)
                                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                        "#?=\"%s\":%s:%s"                                                                        ,
                                                                          trampCall( self._cons_METHOD(  'cons',
                                                                              begin
                                                                                if @global_lisp_binding.has_key?('_cons') then
                                                                                  trampCall(@_cons)
                                                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                          [
                                                                                begin
                                                                                    trampCall(_sourcefile)
                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:950"] + __e.backtrace ) ; raise __e
                                                                                end                                                                              ,
                                                                                trampCall( self._cons_METHOD(  'cons',
                                                                                    begin
                                                                                      if @global_lisp_binding.has_key?('_cons') then
                                                                                        trampCall(@_cons)
                                                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                                                    end                                                                                  ,
                                                                                [
                                                                                      begin
                                                                                          trampCall(_lineno)
                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:950"] + __e.backtrace ) ; raise __e
                                                                                      end                                                                                    ,
                                                                                      trampCall( self._cons_METHOD(  'cons',
                                                                                          begin
                                                                                            if @global_lisp_binding.has_key?('_cons') then
                                                                                              trampCall(@_cons)
                                                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                                                          end                                                                                        ,
                                                                                      [
                                                                                            trampCall( self._cons_METHOD(  'cons',
                                                                                                begin
                                                                                                  if @global_lisp_binding.has_key?('_cons') then
                                                                                                    trampCall(@_cons)
                                                                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                                                                end                                                                                              ,
                                                                                            [
                                                                                                :"write-to-string"                                                                                                ,
                                                                                                  trampCall( self._cons_METHOD(  'cons',
                                                                                                      begin
                                                                                                        if @global_lisp_binding.has_key?('_cons') then
                                                                                                          trampCall(@_cons)
                                                                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                                                                      end                                                                                                    ,
                                                                                                  [
                                                                                                        begin
                                                                                                            trampCall(_sourcesexp)
                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:950"] + __e.backtrace ) ; raise __e
                                                                                                        end                                                                                                      ,
                                                                                                      Cell.new()
                                                                                                  ]
                                                                                                               ))
                                                                                            ]
                                                                                                         ))                                                                                          ,
                                                                                          Cell.new()
                                                                                      ]
                                                                                                   ))
                                                                                ]
                                                                                             ))
                                                                          ]
                                                                                       ))
                                                                    ]
                                                                                 ))
                                                              ]
                                                                           ))                                                            ,
                                                            Cell.new()
                                                        ]
                                                                     ))
                                                  ]
                                                               ))                                                ,
                                                Cell.new()
                                            ]
                                                         ))
                                      ]
                                                   ))                                    ,
                                      trampCall( self._cons_METHOD(  'cons',
                                          begin
                                            if @global_lisp_binding.has_key?('_cons') then
                                              trampCall(@_cons)
                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            trampCall( self._cons_METHOD(  'cons',
                                                begin
                                                  if @global_lisp_binding.has_key?('_cons') then
                                                    trampCall(@_cons)
                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                :"set!"                                                ,
                                                  trampCall( self._cons_METHOD(  'cons',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cons') then
                                                          trampCall(@_cons)
                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        begin
                                                            trampCall(_val)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:953"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                        trampCall( self._cons_METHOD(  'cons',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                trampCall(@_cons)
                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              begin
                                                                  trampCall(__form)
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:951"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                            Cell.new()
                                                        ]
                                                                     ))
                                                  ]
                                                               ))
                                            ]
                                                         ))                                          ,
                                            trampCall( self._cons_METHOD(  'cons',
                                                begin
                                                  if @global_lisp_binding.has_key?('_cons') then
                                                    trampCall(@_cons)
                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  trampCall( self._cons_METHOD(  'cons',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cons') then
                                                          trampCall(@_cons)
                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                      :"debug-print-output-func"                                                      ,
                                                        trampCall( self._cons_METHOD(  'cons',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                trampCall(@_cons)
                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              trampCall( self._cons_METHOD(  'cons',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                      trampCall(@_cons)
                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                  :"debug-limit-length"                                                                  ,
                                                                    trampCall( self._cons_METHOD(  'cons',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_cons') then
                                                                            trampCall(@_cons)
                                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          trampCall( self._cons_METHOD(  'cons',
                                                                              begin
                                                                                if @global_lisp_binding.has_key?('_cons') then
                                                                                  trampCall(@_cons)
                                                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                          [
                                                                              :"+"                                                                              ,
                                                                                trampCall( self._cons_METHOD(  'cons',
                                                                                    begin
                                                                                      if @global_lisp_binding.has_key?('_cons') then
                                                                                        trampCall(@_cons)
                                                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                                                    end                                                                                  ,
                                                                                [
                                                                                    "#?-    "                                                                                    ,
                                                                                      trampCall( self._cons_METHOD(  'cons',
                                                                                          begin
                                                                                            if @global_lisp_binding.has_key?('_cons') then
                                                                                              trampCall(@_cons)
                                                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                                                          end                                                                                        ,
                                                                                      [
                                                                                            trampCall( self._cons_METHOD(  'cons',
                                                                                                begin
                                                                                                  if @global_lisp_binding.has_key?('_cons') then
                                                                                                    trampCall(@_cons)
                                                                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                                                                end                                                                                              ,
                                                                                            [
                                                                                                :"write-to-string"                                                                                                ,
                                                                                                  trampCall( self._cons_METHOD(  'cons',
                                                                                                      begin
                                                                                                        if @global_lisp_binding.has_key?('_cons') then
                                                                                                          trampCall(@_cons)
                                                                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                                                                      end                                                                                                    ,
                                                                                                  [
                                                                                                        begin
                                                                                                            trampCall(_val)
                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:953"] + __e.backtrace ) ; raise __e
                                                                                                        end                                                                                                      ,
                                                                                                      Cell.new()
                                                                                                  ]
                                                                                                               ))
                                                                                            ]
                                                                                                         ))                                                                                          ,
                                                                                          Cell.new()
                                                                                      ]
                                                                                                   ))
                                                                                ]
                                                                                             ))
                                                                          ]
                                                                                       ))                                                                        ,
                                                                        Cell.new()
                                                                    ]
                                                                                 ))
                                                              ]
                                                                           ))                                                            ,
                                                            Cell.new()
                                                        ]
                                                                     ))
                                                  ]
                                                               ))                                                ,
                                                  trampCall( self._cons_METHOD(  'cons',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cons') then
                                                          trampCall(@_cons)
                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        begin
                                                            trampCall(_val)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:953"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                      Cell.new()
                                                  ]
                                                               ))
                                            ]
                                                         ))
                                      ]
                                                   ))
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
                } ; ___lambda.call(
                      trampCall( self._gensym_METHOD(  'gensym',
                          begin
                            if @global_lisp_binding.has_key?('_gensym') then
                              trampCall(@_gensym)
                            else raise NameError.new( "Error: undefined variable _gensym", "_gensym" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:948"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                      ]
                                   ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._pretty_MIMARKprint_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_pretty_MIMARKprint'] = self.method( :_pretty_MIMARKprint_METHOD )
    @_pretty_MIMARKprint = 
    trampCall(
          Proc.new { |_s,*__rest__| _f = __rest__[0] ;  
              begin
                ___lambda = lambda { |_do_MIMARKindent,_pp_MIMARKparenl,_pp_MIMARKparenr,_pp_MIMARKatom,_pp_MIMARKlist| 
                    _do_MIMARKindent                     = 
                      Proc.new { |_f,_level| 
                          delayCall( '_for_MIMARKeach',  'for-each',
                              begin
                                if @global_lisp_binding.has_key?('_for_MIMARKeach') then
                                  trampCall(@_for_MIMARKeach)
                                else raise NameError.new( "Error: undefined variable _for_MIMARKeach", "_for_MIMARKeach" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:963"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                Proc.new { |_x| 
                                    begin
                                        trampCall(_f).print(
                                            " "
                                          )
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:988"] + __e.backtrace ) ; raise __e
                                    end
                                }                              ,
                                trampCall( self._range_METHOD(  'range',
                                    begin
                                      if @global_lisp_binding.has_key?('_range') then
                                        trampCall(@_range)
                                      else raise NameError.new( "Error: undefined variable _range", "_range" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:963"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_level)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:981"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       )
                      }
                    _pp_MIMARKparenl                     = 
                      Proc.new { |_f| 
                          begin
                              trampCall(_f).print(
                                  "("
                                )
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:988"] + __e.backtrace ) ; raise __e
                          end
                      }
                    _pp_MIMARKparenr                     = 
                      Proc.new { |_f| 
                          begin
                              trampCall(_f).print(
                                  ")"
                                )
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:988"] + __e.backtrace ) ; raise __e
                          end
                      }
                    _pp_MIMARKatom                     = 
                      Proc.new { |_f,_e,_prefix| 
                          if ( 
                            begin
                                trampCall(_prefix)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:982"] + __e.backtrace ) ; raise __e
                            end
                           ) then
                              begin
                                  begin
                                      trampCall(_f).print(
                                          " "
                                        )
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:988"] + __e.backtrace ) ; raise __e
                                  end
                              end
                          end
                          begin
                              trampCall(_f).print(
                                    trampCall( self._write_MIMARKto_MIMARKstring_METHOD(  'write-to-string',
                                        begin
                                          if @global_lisp_binding.has_key?('_write_MIMARKto_MIMARKstring') then
                                            trampCall(@_write_MIMARKto_MIMARKstring)
                                          else raise NameError.new( "Error: undefined variable _write_MIMARKto_MIMARKstring", "_write_MIMARKto_MIMARKstring" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:987"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_e)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:982"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))
                                )
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:988"] + __e.backtrace ) ; raise __e
                          end
                      }
                    _pp_MIMARKlist                     = 
                      Proc.new { |_f,_s,_level,_prefix| 
                          if ( 
                            trampCall( self._not_METHOD(  'not',
                                begin
                                  if @global_lisp_binding.has_key?('_not') then
                                    trampCall(@_not)
                                  else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:937"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                      begin
                                        if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                          trampCall(@_eq_QUMARK)
                                        else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:929"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                      false                                      ,
                                        begin
                                            trampCall(_prefix)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:982"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                            ]
                                         ))
                           ) then
                              trampCall( callProcedure(   'do-indent',
                                  begin
                                      trampCall(_do_MIMARKindent)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:972"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_f)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:986"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                    begin
                                        trampCall(_level)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:981"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                          else
                            false
                          end
                          trampCall( callProcedure(   'pp-parenl',
                              begin
                                  trampCall(_pp_MIMARKparenl)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:973"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_f)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:986"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                          begin
                            ___lambda = lambda { |_loop| 
                                _loop                                 = 
                                  Proc.new { |_s,_prefix| 
                                      if ( 
                                        trampCall( self._null_QUMARK_METHOD(  'null?',
                                            begin
                                              if @global_lisp_binding.has_key?('_null_QUMARK') then
                                                trampCall(@_null_QUMARK)
                                              else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:976"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_s)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:987"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                       ) then
                                          delayCall( '_pp_MIMARKparenr',  'pp-parenr',
                                              begin
                                                  trampCall(_pp_MIMARKparenr)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:977"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_f)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:986"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       )
                                      else
                                          begin
                                            ___lambda = lambda { |_e| 
                                                if ( 
                                                  trampCall( self._list_QUMARK_METHOD(  'list?',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_list_QUMARK') then
                                                          trampCall(@_list_QUMARK)
                                                        else raise NameError.new( "Error: undefined variable _list_QUMARK", "_list_QUMARK" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:985"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        begin
                                                            trampCall(_e)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:982"] + __e.backtrace ) ; raise __e
                                                        end
                                                  ]
                                                               ))
                                                 ) then
                                                    begin
                                                        if ( 
                                                          trampCall( self._not_METHOD(  'not',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_not') then
                                                                  trampCall(@_not)
                                                                else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:937"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                                trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                                    begin
                                                                      if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                                        trampCall(@_eq_QUMARK)
                                                                      else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:929"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                [
                                                                    false                                                                    ,
                                                                      begin
                                                                          trampCall(_prefix)
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:982"] + __e.backtrace ) ; raise __e
                                                                      end
                                                                ]
                                                                             ))
                                                          ]
                                                                       ))
                                                         ) then
                                                            begin
                                                                trampCall(_f).print(
                                                                    "
"
                                                                  )
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:988"] + __e.backtrace ) ; raise __e
                                                            end
                                                        else
                                                          false
                                                        end
                                                        trampCall( callProcedure(   'pp-list',
                                                            begin
                                                                trampCall(_pp_MIMARKlist)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:986"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              begin
                                                                  trampCall(_f)
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:986"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                              begin
                                                                  trampCall(_e)
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:982"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                              trampCall( self.__PLMARK_METHOD(  '+',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('__PLMARK') then
                                                                      trampCall(@__PLMARK)
                                                                    else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:981"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                    begin
                                                                        trampCall(_level)
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:981"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                  1
                                                              ]
                                                                           ))                                                            ,
                                                              begin
                                                                  trampCall(_prefix)
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:982"] + __e.backtrace ) ; raise __e
                                                              end
                                                        ]
                                                                     ))
                                                    end
                                                else
                                                    trampCall( callProcedure(   'pp-atom',
                                                        begin
                                                            trampCall(_pp_MIMARKatom)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:982"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          begin
                                                              trampCall(_f)
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:986"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                          begin
                                                              trampCall(_e)
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:982"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                          begin
                                                              trampCall(_prefix)
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:982"] + __e.backtrace ) ; raise __e
                                                          end
                                                    ]
                                                                 ))
                                                end
                                                delayCall( '_loop',  'loop',
                                                    begin
                                                        trampCall(_loop)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:983"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      trampCall( self._cdr_METHOD(  'cdr',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_cdr') then
                                                              trampCall(@_cdr)
                                                            else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:983"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            begin
                                                                trampCall(_s)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:987"] + __e.backtrace ) ; raise __e
                                                            end
                                                      ]
                                                                   ))                                                    ,
                                                    true
                                                ]
                                                             )
                                            } ; ___lambda.call(
                                                  trampCall( self._car_METHOD(  'car',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_car') then
                                                          trampCall(@_car)
                                                        else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:978"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        begin
                                                            trampCall(_s)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:987"] + __e.backtrace ) ; raise __e
                                                        end
                                                  ]
                                                               ))
                                                       )
                                          end
                                      end
                                  }
                                delayCall( '_loop',  'loop',
                                    begin
                                        trampCall(_loop)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:983"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_s)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:987"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                    false
                                ]
                                             )
                            } ; ___lambda.call(
                            nil
                                       )
                          end
                      }
                    begin
                      ___lambda = lambda { |_f| 
                          if ( 
                            trampCall( self._list_QUMARK_METHOD(  'list?',
                                begin
                                  if @global_lisp_binding.has_key?('_list_QUMARK') then
                                    trampCall(@_list_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _list_QUMARK", "_list_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:985"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_s)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:987"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                           ) then
                              trampCall( callProcedure(   'pp-list',
                                  begin
                                      trampCall(_pp_MIMARKlist)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:986"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_f)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:986"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                    begin
                                        trampCall(_s)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:987"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                  0                                  ,
                                  false
                              ]
                                           ))
                          else
                              begin
                                  trampCall(_f).print(
                                        trampCall( self._write_MIMARKto_MIMARKstring_METHOD(  'write-to-string',
                                            begin
                                              if @global_lisp_binding.has_key?('_write_MIMARKto_MIMARKstring') then
                                                trampCall(@_write_MIMARKto_MIMARKstring)
                                              else raise NameError.new( "Error: undefined variable _write_MIMARKto_MIMARKstring", "_write_MIMARKto_MIMARKstring" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:987"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_s)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:987"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                    )
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:988"] + __e.backtrace ) ; raise __e
                              end
                          end
                          begin
                              trampCall(_f).print(
                                  "
"
                                )
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:988"] + __e.backtrace ) ; raise __e
                          end
                      } ; ___lambda.call(
                            begin
                              ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20229| 
                                  if ( 
                                    trampCall( self._null_QUMARK_METHOD(  'null?',
                                        begin
                                          if @global_lisp_binding.has_key?('_null_QUMARK') then
                                            trampCall(@_null_QUMARK)
                                          else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:976"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20229)
                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))
                                   ) then
                                      begin
                                          trampCall(STDOUT)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:984"] + __e.backtrace ) ; raise __e
                                      end
                                  else
                                      delayCall( '_car',  'car',
                                          begin
                                            if @global_lisp_binding.has_key?('_car') then
                                              trampCall(@_car)
                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:978"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20229)
                                              rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   )
                                  end
                              } ; ___lambda.call(
                                    begin
                                        trampCall(_f)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:986"] + __e.backtrace ) ; raise __e
                                    end
                                         )
                            end
                                 )
                    end
                } ; ___lambda.call(
                nil,nil,nil,nil,nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._pretty_MIMARKprint_MIMARKto_MIMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_pretty_MIMARKprint_MIMARKto_MIMARKstring'] = self.method( :_pretty_MIMARKprint_MIMARKto_MIMARKstring_METHOD )
    @_pretty_MIMARKprint_MIMARKto_MIMARKstring = 
    trampCall(
          Proc.new { |_s| 
              begin
                ___lambda = lambda { |_io| 
                    trampCall( self._pretty_MIMARKprint_METHOD(  'pretty-print',
                        begin
                          if @global_lisp_binding.has_key?('_pretty_MIMARKprint') then
                            trampCall(@_pretty_MIMARKprint)
                          else raise NameError.new( "Error: undefined variable _pretty_MIMARKprint", "_pretty_MIMARKprint" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:993"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_s)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:993"] + __e.backtrace ) ; raise __e
                          end                        ,
                          begin
                              trampCall(_io)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:993"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
                    begin
                        trampCall(_io).rewind(
                          )
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:994"] + __e.backtrace ) ; raise __e
                    end
                    begin
                        trampCall(_io).read(
                          )
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:995"] + __e.backtrace ) ; raise __e
                    end
                } ; ___lambda.call(
                      begin
                          trampCall(StringIO).new(
                            )
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:992"] + __e.backtrace ) ; raise __e
                      end
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._sort_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_sort'] = self.method( :_sort_METHOD )
    @_sort = 
    trampCall(
          Proc.new { |_lst,*__rest__| _cmpfn = __rest__[0] ;  
              if ( 
                trampCall( self._null_QUMARK_METHOD(  'null?',
                    begin
                      if @global_lisp_binding.has_key?('_null_QUMARK') then
                        trampCall(@_null_QUMARK)
                      else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1001"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      begin
                          trampCall(_lst)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1001"] + __e.backtrace ) ; raise __e
                      end
                ]
                             ))
               ) then
                Cell.new()
              else
                  begin
                    ___lambda = lambda { |_cmpfn| 
                        delayCall( '_to_MIMARKlist',  'to-list',
                            begin
                              if @global_lisp_binding.has_key?('_to_MIMARKlist') then
                                trampCall(@_to_MIMARKlist)
                              else raise NameError.new( "Error: undefined variable _to_MIMARKlist", "_to_MIMARKlist" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1004"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              if ( 
                                begin
                                    trampCall(_cmpfn)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1006"] + __e.backtrace ) ; raise __e
                                end
                               ) then
                                  begin
                                      trampCall(_lst).to_arr.sort(
                                            &Proc.new { |_a,_b| 
                                                trampCall( callProcedure(   'cmpfn',
                                                    begin
                                                        trampCall(_cmpfn)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1006"] + __e.backtrace ) ; raise __e
                                                    end                                                  ,
                                                [
                                                      begin
                                                          trampCall(_a)
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1006"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                      begin
                                                          trampCall(_b)
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1006"] + __e.backtrace ) ; raise __e
                                                      end
                                                ]
                                                             ))
                                            }
                                        )
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1007"] + __e.backtrace ) ; raise __e
                                  end
                              else
                                  begin
                                      trampCall(_lst).to_arr.sort(
                                        )
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1007"] + __e.backtrace ) ; raise __e
                                  end
                              end
                        ]
                                     )
                    } ; ___lambda.call(
                          begin
                            ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20230| 
                                if ( 
                                  trampCall( self._null_QUMARK_METHOD(  'null?',
                                      begin
                                        if @global_lisp_binding.has_key?('_null_QUMARK') then
                                          trampCall(@_null_QUMARK)
                                        else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1001"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20230)
                                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                                 ) then
                                  false
                                else
                                    delayCall( '_car',  'car',
                                        begin
                                          if @global_lisp_binding.has_key?('_car') then
                                            trampCall(@_car)
                                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:978"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20230)
                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 )
                                end
                            } ; ___lambda.call(
                                  begin
                                      trampCall(_cmpfn)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1006"] + __e.backtrace ) ; raise __e
                                  end
                                       )
                          end
                               )
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._sort_MIMARKby_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_sort_MIMARKby'] = self.method( :_sort_MIMARKby_METHOD )
    @_sort_MIMARKby = 
    trampCall(
          Proc.new { |_lst,_keyfn| 
              if ( 
                trampCall( self._null_QUMARK_METHOD(  'null?',
                    begin
                      if @global_lisp_binding.has_key?('_null_QUMARK') then
                        trampCall(@_null_QUMARK)
                      else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1011"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      begin
                          trampCall(_lst)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1011"] + __e.backtrace ) ; raise __e
                      end
                ]
                             ))
               ) then
                Cell.new()
              else
                  delayCall( '_to_MIMARKlist',  'to-list',
                      begin
                        if @global_lisp_binding.has_key?('_to_MIMARKlist') then
                          trampCall(@_to_MIMARKlist)
                        else raise NameError.new( "Error: undefined variable _to_MIMARKlist", "_to_MIMARKlist" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1013"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                        begin
                            trampCall(_lst).to_arr.sort_by(
                                  &Proc.new { |_item| 
                                      trampCall( callProcedure(   'keyfn',
                                          begin
                                              trampCall(_keyfn)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1014"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_item)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1014"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                  }
                              )
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1014"] + __e.backtrace ) ; raise __e
                        end
                  ]
                               )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._string_MIMARKlength_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_string_MIMARKlength'] = self.method( :_string_MIMARKlength_METHOD )
    @_string_MIMARKlength = 
    trampCall(
          Proc.new { |_str| 
              begin
                  trampCall(_str).size(
                    )
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1020"] + __e.backtrace ) ; raise __e
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._string_MIMARK_GTMARKregexp_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_string_MIMARK_GTMARKregexp'] = self.method( :_string_MIMARK_GTMARKregexp_METHOD )
    @_string_MIMARK_GTMARKregexp = 
    trampCall(
          Proc.new { |_str,*__rest__| _casefold = __rest__[0] ;  
              if ( 
                trampCall( self._not_METHOD(  'not',
                    begin
                      if @global_lisp_binding.has_key?('_not') then
                        trampCall(@_not)
                      else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1027"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      begin
                          trampCall(_str).is_a?(
                                begin
                                    trampCall(String)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1027"] + __e.backtrace ) ; raise __e
                                end
                            )
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1027"] + __e.backtrace ) ; raise __e
                      end
                ]
                             ))
               ) then
                  begin raise RuntimeError, 
                  "Error: string->regexp requires a String argument."
                  rescue => __e 
                    __e.set_backtrace( ["./lib/init.nnd:1028"] + __e.backtrace )
                    raise __e
                  end 
              else
                  if ( 
                    begin
                      ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20231| 
                          if ( 
                            trampCall( self._null_QUMARK_METHOD(  'null?',
                                begin
                                  if @global_lisp_binding.has_key?('_null_QUMARK') then
                                    trampCall(@_null_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1011"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20231)
                                    rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                           ) then
                            false
                          else
                              trampCall( self._car_METHOD(  'car',
                                  begin
                                    if @global_lisp_binding.has_key?('_car') then
                                      trampCall(@_car)
                                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:978"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20231)
                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                          end
                      } ; ___lambda.call(
                            begin
                                trampCall(_casefold)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1029"] + __e.backtrace ) ; raise __e
                            end
                                 )
                    end
                   ) then
                      begin
                          trampCall(Regexp).new(
                                begin
                                    trampCall(_str)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1031"] + __e.backtrace ) ; raise __e
                                end                              ,
                                begin
                                    trampCall(Regexp::IGNORECASE)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1030"] + __e.backtrace ) ; raise __e
                                end
                            )
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1031"] + __e.backtrace ) ; raise __e
                      end
                  else
                      begin
                          trampCall(Regexp).new(
                                begin
                                    trampCall(_str)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1031"] + __e.backtrace ) ; raise __e
                                end
                            )
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1031"] + __e.backtrace ) ; raise __e
                      end
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._regexp_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_regexp_QUMARK'] = self.method( :_regexp_QUMARK_METHOD )
    @_regexp_QUMARK = 
    trampCall(
          Proc.new { |_obj| 
              begin
                  trampCall(_obj).is_a?(
                        begin
                            trampCall(Regexp)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1034"] + __e.backtrace ) ; raise __e
                        end
                    )
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1034"] + __e.backtrace ) ; raise __e
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._regexp_MIMARK_GTMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_regexp_MIMARK_GTMARKstring'] = self.method( :_regexp_MIMARK_GTMARKstring_METHOD )
    @_regexp_MIMARK_GTMARKstring = 
    trampCall(
          Proc.new { |_regexp| 
              begin
                  trampCall(_regexp).source(
                    )
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1037"] + __e.backtrace ) ; raise __e
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._rxmatch_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_rxmatch'] = self.method( :_rxmatch_METHOD )
    @_rxmatch = 
    trampCall(
          Proc.new { |_regexp,_str| 
              begin
                ___lambda = lambda { |_m| 
                    if ( 
                      begin
                          trampCall(_m)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1042"] + __e.backtrace ) ; raise __e
                      end
                     ) then
                        begin
                            trampCall(_m)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1042"] + __e.backtrace ) ; raise __e
                        end
                    else
                      false
                    end
                } ; ___lambda.call(
                      begin
                          trampCall(_regexp).match(
                                begin
                                    trampCall(_str)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1041"] + __e.backtrace ) ; raise __e
                                end
                            )
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1041"] + __e.backtrace ) ; raise __e
                      end
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._rxmatch_MIMARKstart_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_rxmatch_MIMARKstart'] = self.method( :_rxmatch_MIMARKstart_METHOD )
    @_rxmatch_MIMARKstart = 
    trampCall(
          Proc.new { |_match,*__rest__| _index = __rest__[0] ;  
              begin
                ___lambda = lambda { |_index| 
                    begin
                        trampCall(_match).begin(
                              begin
                                  trampCall(_index)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1046"] + __e.backtrace ) ; raise __e
                              end
                          )
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1046"] + __e.backtrace ) ; raise __e
                    end
                } ; ___lambda.call(
                      begin
                        ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20232| 
                            if ( 
                              trampCall( self._null_QUMARK_METHOD(  'null?',
                                  begin
                                    if @global_lisp_binding.has_key?('_null_QUMARK') then
                                      trampCall(@_null_QUMARK)
                                    else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1011"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20232)
                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                             ) then
                              0
                            else
                                delayCall( '_car',  'car',
                                    begin
                                      if @global_lisp_binding.has_key?('_car') then
                                        trampCall(@_car)
                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:978"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20232)
                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             )
                            end
                        } ; ___lambda.call(
                              begin
                                  trampCall(_index)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1046"] + __e.backtrace ) ; raise __e
                              end
                                   )
                      end
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._rxmatch_MIMARKend_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_rxmatch_MIMARKend'] = self.method( :_rxmatch_MIMARKend_METHOD )
    @_rxmatch_MIMARKend = 
    trampCall(
          Proc.new { |_match,*__rest__| _index = __rest__[0] ;  
              begin
                ___lambda = lambda { |_index| 
                    begin
                        trampCall(_match).end(
                              begin
                                  trampCall(_index)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1050"] + __e.backtrace ) ; raise __e
                              end
                          )
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1050"] + __e.backtrace ) ; raise __e
                    end
                } ; ___lambda.call(
                      begin
                        ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20233| 
                            if ( 
                              trampCall( self._null_QUMARK_METHOD(  'null?',
                                  begin
                                    if @global_lisp_binding.has_key?('_null_QUMARK') then
                                      trampCall(@_null_QUMARK)
                                    else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1011"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20233)
                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                             ) then
                              0
                            else
                                delayCall( '_car',  'car',
                                    begin
                                      if @global_lisp_binding.has_key?('_car') then
                                        trampCall(@_car)
                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:978"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20233)
                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             )
                            end
                        } ; ___lambda.call(
                              begin
                                  trampCall(_index)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1050"] + __e.backtrace ) ; raise __e
                              end
                                   )
                      end
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._rxmatch_MIMARKsubstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_rxmatch_MIMARKsubstring'] = self.method( :_rxmatch_MIMARKsubstring_METHOD )
    @_rxmatch_MIMARKsubstring = 
    trampCall(
          Proc.new { |_match,*__rest__| _index = __rest__[0] ;  
              begin
                ___lambda = lambda { |_index| 
                    delayCall( '_nth',  'nth',
                        begin
                          if @global_lisp_binding.has_key?('_nth') then
                            trampCall(@_nth)
                          else raise NameError.new( "Error: undefined variable _nth", "_nth" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1054"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_index)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1054"] + __e.backtrace ) ; raise __e
                          end                        ,
                          begin
                              trampCall(_match).to_a.to_list(
                                )
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1054"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 )
                } ; ___lambda.call(
                      begin
                        ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20234| 
                            if ( 
                              trampCall( self._null_QUMARK_METHOD(  'null?',
                                  begin
                                    if @global_lisp_binding.has_key?('_null_QUMARK') then
                                      trampCall(@_null_QUMARK)
                                    else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1011"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20234)
                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                             ) then
                              0
                            else
                                delayCall( '_car',  'car',
                                    begin
                                      if @global_lisp_binding.has_key?('_car') then
                                        trampCall(@_car)
                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:978"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20234)
                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             )
                            end
                        } ; ___lambda.call(
                              begin
                                  trampCall(_index)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1054"] + __e.backtrace ) ; raise __e
                              end
                                   )
                      end
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._rxmatch_MIMARKnum_MIMARKmatches_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_rxmatch_MIMARKnum_MIMARKmatches'] = self.method( :_rxmatch_MIMARKnum_MIMARKmatches_METHOD )
    @_rxmatch_MIMARKnum_MIMARKmatches = 
    trampCall(
          Proc.new { |_match| 
              begin
                  trampCall(_match).size(
                    )
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1057"] + __e.backtrace ) ; raise __e
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._rxmatch_MIMARK_GTMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_rxmatch_MIMARK_GTMARKstring'] = self.method( :_rxmatch_MIMARK_GTMARKstring_METHOD )
    @_rxmatch_MIMARK_GTMARKstring = 
    trampCall(
          Proc.new { |_regexp,_str,*__rest__| _index = __rest__[0] ;  
              begin
                ___lambda = lambda { |_index| 
                    begin
                      ___lambda = lambda { |_m| 
                          if ( 
                            begin
                                trampCall(_m)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1063"] + __e.backtrace ) ; raise __e
                            end
                           ) then
                              delayCall( '_rxmatch_MIMARKsubstring',  'rxmatch-substring',
                                  begin
                                    if @global_lisp_binding.has_key?('_rxmatch_MIMARKsubstring') then
                                      trampCall(@_rxmatch_MIMARKsubstring)
                                    else raise NameError.new( "Error: undefined variable _rxmatch_MIMARKsubstring", "_rxmatch_MIMARKsubstring" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1063"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_m)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1063"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                    begin
                                        trampCall(_index)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1063"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           )
                          else
                            false
                          end
                      } ; ___lambda.call(
                            trampCall( self._rxmatch_METHOD(  'rxmatch',
                                begin
                                  if @global_lisp_binding.has_key?('_rxmatch') then
                                    trampCall(@_rxmatch)
                                  else raise NameError.new( "Error: undefined variable _rxmatch", "_rxmatch" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1061"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_regexp)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1061"] + __e.backtrace ) ; raise __e
                                  end                                ,
                                  begin
                                      trampCall(_str)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1061"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                                 )
                    end
                } ; ___lambda.call(
                      begin
                        ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20235| 
                            if ( 
                              trampCall( self._null_QUMARK_METHOD(  'null?',
                                  begin
                                    if @global_lisp_binding.has_key?('_null_QUMARK') then
                                      trampCall(@_null_QUMARK)
                                    else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1011"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20235)
                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                             ) then
                              0
                            else
                                delayCall( '_car',  'car',
                                    begin
                                      if @global_lisp_binding.has_key?('_car') then
                                        trampCall(@_car)
                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:978"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20235)
                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             )
                            end
                        } ; ___lambda.call(
                              begin
                                  trampCall(_index)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1063"] + __e.backtrace ) ; raise __e
                              end
                                   )
                      end
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._export_MIMARKto_MIMARKruby_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_export_MIMARKto_MIMARKruby'] = self.method( :_export_MIMARKto_MIMARKruby_METHOD )
    @_export_MIMARKto_MIMARKruby = 
    trampCall(
          LispMacro.new { |_funcname| 
              trampCall( self._cons_METHOD(  'cons',
                  begin
                    if @global_lisp_binding.has_key?('_cons') then
                      trampCall(@_cons)
                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  :"%export-to-ruby"                  ,
                    trampCall( self._cons_METHOD(  'cons',
                        begin
                          if @global_lisp_binding.has_key?('_cons') then
                            trampCall(@_cons)
                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_funcname).to_s
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1074"] + __e.backtrace ) ; raise __e
                          end                        ,
                          trampCall( self._cons_METHOD(  'cons',
                              begin
                                if @global_lisp_binding.has_key?('_cons') then
                                  trampCall(@_cons)
                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_funcname)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1074"] + __e.backtrace ) ; raise __e
                                end                              ,
                              Cell.new()
                          ]
                                       ))
                    ]
                                 ))
              ]
                           ))
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._load_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_load'] = self.method( :_load_METHOD )
    @_load = 
    trampCall(
          Proc.new { |_path| 
              if ( 
                trampCall( self._rxmatch_METHOD(  'rxmatch',
                    begin
                      if @global_lisp_binding.has_key?('_rxmatch') then
                        trampCall(@_rxmatch)
                      else raise NameError.new( "Error: undefined variable _rxmatch", "_rxmatch" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1086"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                    Regexp.new( "^([.]\\/|[.][.]\\/|\\/)")                    ,
                      begin
                          trampCall(_path)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1083"] + __e.backtrace ) ; raise __e
                      end
                ]
                             ))
               ) then
                  delayCall( '__PAMARKload',  '%load',
                      begin
                        if @global_lisp_binding.has_key?('__PAMARKload') then
                          trampCall(@__PAMARKload)
                        else raise NameError.new( "Error: undefined variable __PAMARKload", "__PAMARKload" ) end
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                      end                    ,
                  [
                        begin
                            trampCall(_path)
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1083"] + __e.backtrace ) ; raise __e
                        end
                  ]
                               )
              else
                  begin
                    ___lambda = lambda { |_loop| 
                        _loop                         = 
                          Proc.new { |_load_MIMARKpath| 
                              if ( 
                                trampCall( self._null_QUMARK_METHOD(  'null?',
                                    begin
                                      if @global_lisp_binding.has_key?('_null_QUMARK') then
                                        trampCall(@_null_QUMARK)
                                      else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1080"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_load_MIMARKpath)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1094"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                               ) then
                                  begin
                                      begin raise RuntimeError, 
                                        trampCall( self._sprintf_METHOD(  'sprintf',
                                            begin
                                              if @global_lisp_binding.has_key?('_sprintf') then
                                                trampCall(@_sprintf)
                                              else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:950"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                            "Error: can't load file [%s]
"                                            ,
                                              begin
                                                  trampCall(_path)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1083"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                      rescue => __e 
                                        __e.set_backtrace( ["./lib/init.nnd:1028"] + __e.backtrace )
                                        raise __e
                                      end 
                                  end
                              else
                                  if ( 
                                  true
                                   ) then
                                      begin
                                          begin
                                            ___lambda = lambda { |_full_MIMARKpath| 
                                                if ( 
                                                  begin
                                                      trampCall(File).exist?(
                                                            begin
                                                                trampCall(_full_MIMARKpath)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                                                            end
                                                        )
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1091"] + __e.backtrace ) ; raise __e
                                                  end
                                                 ) then
                                                    begin
                                                        if ( 
                                                          trampCall( self._rxmatch_METHOD(  'rxmatch',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_rxmatch') then
                                                                  trampCall(@_rxmatch)
                                                                else raise NameError.new( "Error: undefined variable _rxmatch", "_rxmatch" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1086"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                              Regexp.new( "[.]nndc$")                                                              ,
                                                                begin
                                                                    trampCall(_full_MIMARKpath)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))
                                                         ) then
                                                            delayCall( '__PAMARKload_MIMARKcompiled_MIMARKcode',  '%load-compiled-code',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('__PAMARKload_MIMARKcompiled_MIMARKcode') then
                                                                    trampCall(@__PAMARKload_MIMARKcompiled_MIMARKcode)
                                                                  else raise NameError.new( "Error: undefined variable __PAMARKload_MIMARKcompiled_MIMARKcode", "__PAMARKload_MIMARKcompiled_MIMARKcode" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1090"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  begin
                                                                      trampCall(_full_MIMARKpath)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                                                                  end
                                                            ]
                                                                         )
                                                        else
                                                            delayCall( '__PAMARKload',  '%load',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('__PAMARKload') then
                                                                    trampCall(@__PAMARKload)
                                                                  else raise NameError.new( "Error: undefined variable __PAMARKload", "__PAMARKload" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  begin
                                                                      trampCall(_full_MIMARKpath)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                                                                  end
                                                            ]
                                                                         )
                                                        end
                                                    end
                                                else
                                                    if ( 
                                                      begin
                                                          trampCall(File).exist?(
                                                                trampCall( self.__PLMARK_METHOD(  '+',
                                                                    begin
                                                                      if @global_lisp_binding.has_key?('__PLMARK') then
                                                                        trampCall(@__PLMARK)
                                                                      else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                [
                                                                      begin
                                                                          trampCall(_full_MIMARKpath)
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                    ".nndc"
                                                                ]
                                                                             ))
                                                            )
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1091"] + __e.backtrace ) ; raise __e
                                                      end
                                                     ) then
                                                        begin
                                                            delayCall( '__PAMARKload_MIMARKcompiled_MIMARKcode',  '%load-compiled-code',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('__PAMARKload_MIMARKcompiled_MIMARKcode') then
                                                                    trampCall(@__PAMARKload_MIMARKcompiled_MIMARKcode)
                                                                  else raise NameError.new( "Error: undefined variable __PAMARKload_MIMARKcompiled_MIMARKcode", "__PAMARKload_MIMARKcompiled_MIMARKcode" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1090"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  trampCall( self.__PLMARK_METHOD(  '+',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('__PLMARK') then
                                                                          trampCall(@__PLMARK)
                                                                        else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        begin
                                                                            trampCall(_full_MIMARKpath)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                      ".nndc"
                                                                  ]
                                                                               ))
                                                            ]
                                                                         )
                                                        end
                                                    else
                                                        if ( 
                                                          begin
                                                              trampCall(File).exist?(
                                                                    trampCall( self.__PLMARK_METHOD(  '+',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('__PLMARK') then
                                                                            trampCall(@__PLMARK)
                                                                          else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          begin
                                                                              trampCall(_full_MIMARKpath)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                        ".nnd"
                                                                    ]
                                                                                 ))
                                                                )
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1091"] + __e.backtrace ) ; raise __e
                                                          end
                                                         ) then
                                                            begin
                                                                delayCall( '__PAMARKload',  '%load',
                                                                    begin
                                                                      if @global_lisp_binding.has_key?('__PAMARKload') then
                                                                        trampCall(@__PAMARKload)
                                                                      else raise NameError.new( "Error: undefined variable __PAMARKload", "__PAMARKload" ) end
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                [
                                                                      trampCall( self.__PLMARK_METHOD(  '+',
                                                                          begin
                                                                            if @global_lisp_binding.has_key?('__PLMARK') then
                                                                              trampCall(@__PLMARK)
                                                                            else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                      [
                                                                            begin
                                                                                trampCall(_full_MIMARKpath)
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                          ".nnd"
                                                                      ]
                                                                                   ))
                                                                ]
                                                                             )
                                                            end
                                                        else
                                                            if ( 
                                                            true
                                                             ) then
                                                                begin
                                                                    delayCall( '_loop',  'loop',
                                                                        begin
                                                                            trampCall(_loop)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1094"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          trampCall( self._cdr_METHOD(  'cdr',
                                                                              begin
                                                                                if @global_lisp_binding.has_key?('_cdr') then
                                                                                  trampCall(@_cdr)
                                                                                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1094"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                          [
                                                                                begin
                                                                                    trampCall(_load_MIMARKpath)
                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1094"] + __e.backtrace ) ; raise __e
                                                                                end
                                                                          ]
                                                                                       ))
                                                                    ]
                                                                                 )
                                                                end
                                                            else
                                                                Cell.new()
                                                            end
                                                        end
                                                    end
                                                end
                                            } ; ___lambda.call(
                                                  trampCall( self.__PLMARK_METHOD(  '+',
                                                      begin
                                                        if @global_lisp_binding.has_key?('__PLMARK') then
                                                          trampCall(@__PLMARK)
                                                        else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1092"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        trampCall( self._car_METHOD(  'car',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_car') then
                                                                trampCall(@_car)
                                                              else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1083"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              begin
                                                                  trampCall(_load_MIMARKpath)
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1094"] + __e.backtrace ) ; raise __e
                                                              end
                                                        ]
                                                                     ))                                                      ,
                                                      "/"                                                      ,
                                                        begin
                                                            trampCall(_path)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1083"] + __e.backtrace ) ; raise __e
                                                        end
                                                  ]
                                                               ))
                                                       )
                                          end
                                      end
                                  else
                                      Cell.new()
                                  end
                              end
                          }
                        delayCall( '_loop',  'loop',
                            begin
                                trampCall(_loop)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1094"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                if @global_lisp_binding.has_key?('__ASMARKload_MIMARKpath_ASMARK') then
                                  trampCall(@__ASMARKload_MIMARKpath_ASMARK)
                                else raise NameError.new( "Error: undefined variable __ASMARKload_MIMARKpath_ASMARK", "__ASMARKload_MIMARKpath_ASMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1079"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     )
                    } ; ___lambda.call(
                    nil
                               )
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._add_MIMARKload_MIMARKpath_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_add_MIMARKload_MIMARKpath'] = self.method( :_add_MIMARKload_MIMARKpath_METHOD )
    @_add_MIMARKload_MIMARKpath = 
    trampCall(
          Proc.new { |_path,*__rest__| _afterp = __rest__[0] ;  
              begin
                  def self.__ASMARKload_MIMARKpath_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
                  @global_lisp_binding['__ASMARKload_MIMARKpath_ASMARK'] = self.method( :__ASMARKload_MIMARKpath_ASMARK_METHOD )
                @__ASMARKload_MIMARKpath_ASMARK = 
                trampCall(
                      if ( 
                        begin
                          ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20242| 
                              if ( 
                                trampCall( self._null_QUMARK_METHOD(  'null?',
                                    begin
                                      if @global_lisp_binding.has_key?('_null_QUMARK') then
                                        trampCall(@_null_QUMARK)
                                      else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1080"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20242)
                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                               ) then
                                false
                              else
                                  trampCall( self._car_METHOD(  'car',
                                      begin
                                        if @global_lisp_binding.has_key?('_car') then
                                          trampCall(@_car)
                                        else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1083"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20242)
                                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                              end
                          } ; ___lambda.call(
                                begin
                                    trampCall(_afterp)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1098"] + __e.backtrace ) ; raise __e
                                end
                                     )
                        end
                       ) then
                          trampCall( self._append_METHOD(  'append',
                              begin
                                if @global_lisp_binding.has_key?('_append') then
                                  trampCall(@_append)
                                else raise NameError.new( "Error: undefined variable _append", "_append" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1099"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                  if @global_lisp_binding.has_key?('__ASMARKload_MIMARKpath_ASMARK') then
                                    trampCall(@__ASMARKload_MIMARKpath_ASMARK)
                                  else raise NameError.new( "Error: undefined variable __ASMARKload_MIMARKpath_ASMARK", "__ASMARKload_MIMARKpath_ASMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1101"] + __e.backtrace ) ; raise __e
                                end                              ,
                                trampCall( self._list_METHOD(  'list',
                                    begin
                                      if @global_lisp_binding.has_key?('_list') then
                                        trampCall(@_list)
                                      else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1099"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_path)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       ))
                      else
                          trampCall( self._cons_METHOD(  'cons',
                              begin
                                if @global_lisp_binding.has_key?('_cons') then
                                  trampCall(@_cons)
                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_path)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                end                              ,
                                begin
                                  if @global_lisp_binding.has_key?('__ASMARKload_MIMARKpath_ASMARK') then
                                    trampCall(@__ASMARKload_MIMARKpath_ASMARK)
                                  else raise NameError.new( "Error: undefined variable __ASMARKload_MIMARKpath_ASMARK", "__ASMARKload_MIMARKpath_ASMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1101"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                      end
                )
              end
              begin
                if @global_lisp_binding.has_key?('__ASMARKload_MIMARKpath_ASMARK') then
                  trampCall(@__ASMARKload_MIMARKpath_ASMARK)
                else raise NameError.new( "Error: undefined variable __ASMARKload_MIMARKpath_ASMARK", "__ASMARKload_MIMARKpath_ASMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1101"] + __e.backtrace ) ; raise __e
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._use_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_use'] = self.method( :_use_METHOD )
    @_use = 
    trampCall(
          LispMacro.new { |_sym| 
              if ( 
                trampCall( self._symbol_QUMARK_METHOD(  'symbol?',
                    begin
                      if @global_lisp_binding.has_key?('_symbol_QUMARK') then
                        trampCall(@_symbol_QUMARK)
                      else raise NameError.new( "Error: undefined variable _symbol_QUMARK", "_symbol_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1106"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      begin
                          trampCall(_sym)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1108"] + __e.backtrace ) ; raise __e
                      end
                ]
                             ))
               ) then
                  begin
                    ___lambda = lambda { |_str| 
                        begin
                          ___lambda = lambda { |_pathname| 
                              trampCall( self._cons_METHOD(  'cons',
                                  begin
                                    if @global_lisp_binding.has_key?('_cons') then
                                      trampCall(@_cons)
                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                  :"load"                                  ,
                                    trampCall( self._cons_METHOD(  'cons',
                                        begin
                                          if @global_lisp_binding.has_key?('_cons') then
                                            trampCall(@_cons)
                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_pathname)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1110"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                        Cell.new()
                                    ]
                                                 ))
                              ]
                                           ))
                          } ; ___lambda.call(
                                begin
                                    trampCall(_str).gsub(
                                        "."                                        ,
                                        "/"
                                      )
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1109"] + __e.backtrace ) ; raise __e
                                end
                                     )
                        end
                    } ; ___lambda.call(
                          trampCall( self._symbol_MIMARK_GTMARKstring_METHOD(  'symbol->string',
                              begin
                                if @global_lisp_binding.has_key?('_symbol_MIMARK_GTMARKstring') then
                                  trampCall(@_symbol_MIMARK_GTMARKstring)
                                else raise NameError.new( "Error: undefined variable _symbol_MIMARK_GTMARKstring", "_symbol_MIMARK_GTMARKstring" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1108"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_sym)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1108"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                               )
                  end
              else
                  begin raise RuntimeError, 
                    trampCall( self._sprintf_METHOD(  'sprintf',
                        begin
                          if @global_lisp_binding.has_key?('_sprintf') then
                            trampCall(@_sprintf)
                          else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:950"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "Error: use macro requires a symbol argument."
                    ]
                                 ))
                  rescue => __e 
                    __e.set_backtrace( ["./lib/init.nnd:1028"] + __e.backtrace )
                    raise __e
                  end 
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._export_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_export'] = self.method( :_export_METHOD )
    @_export = 
    trampCall(
          LispMacro.new { |_name| 
              trampCall( self._cons_METHOD(  'cons',
                  begin
                    if @global_lisp_binding.has_key?('_cons') then
                      trampCall(@_cons)
                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  :"define"                  ,
                    trampCall( self._cons_METHOD(  'cons',
                        begin
                          if @global_lisp_binding.has_key?('_cons') then
                            trampCall(@_cons)
                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_name)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1116"] + __e.backtrace ) ; raise __e
                          end                        ,
                        Cell.new(nil)
                    ]
                                 ))
              ]
                           ))
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._global_MIMARKdefined_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_global_MIMARKdefined_QUMARK'] = self.method( :_global_MIMARKdefined_QUMARK_METHOD )
    @_global_MIMARKdefined_QUMARK = 
    trampCall(
          Proc.new { |_sym| 
              delayCall( '_find',  'find',
                  begin
                    if @global_lisp_binding.has_key?('_find') then
                      trampCall(@_find)
                    else raise NameError.new( "Error: undefined variable _find", "_find" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1124"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    Proc.new { |_x| 
                        trampCall( self._eq_QUMARK_METHOD(  'eq?',
                            begin
                              if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                trampCall(@_eq_QUMARK)
                              else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1126"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(_sym)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1126"] + __e.backtrace ) ; raise __e
                              end                            ,
                              begin
                                  trampCall(_x)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1126"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     ))
                    }                  ,
                    trampCall( self._global_MIMARKvariables_METHOD(  'global-variables',
                        begin
                          if @global_lisp_binding.has_key?('_global_MIMARKvariables') then
                            trampCall(@_global_MIMARKvariables)
                          else raise NameError.new( "Error: undefined variable _global_MIMARKvariables", "_global_MIMARKvariables" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1127"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                    ]
                                 ))
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._disasm_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_disasm'] = self.method( :_disasm_METHOD )
    @_disasm = 
    trampCall(
          Proc.new { |_varname,*__rest__| _opt = __rest__[0] ;  
              begin
                ___lambda = lambda { |_kind,_alist| 
                    if ( 
                      trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                          begin
                            if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                              trampCall(@_eqv_QUMARK)
                            else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_kind)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                            end                          ,
                          :"compiled"
                      ]
                                   ))
                     ) then
                        begin
                            delayCall( '_assv_MIMARKref',  'assv-ref',
                                begin
                                  if @global_lisp_binding.has_key?('_assv_MIMARKref') then
                                    trampCall(@_assv_MIMARKref)
                                  else raise NameError.new( "Error: undefined variable _assv_MIMARKref", "_assv_MIMARKref" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1153"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                "compiled_str"                                ,
                                  begin
                                      trampCall(_alist)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1153"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         )
                        end
                    else
                        if ( 
                          trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                              begin
                                if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                  trampCall(@_eqv_QUMARK)
                                else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_kind)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                end                              ,
                              :"source"
                          ]
                                       ))
                         ) then
                            begin
                                delayCall( '_assv_MIMARKref',  'assv-ref',
                                    begin
                                      if @global_lisp_binding.has_key?('_assv_MIMARKref') then
                                        trampCall(@_assv_MIMARKref)
                                      else raise NameError.new( "Error: undefined variable _assv_MIMARKref", "_assv_MIMARKref" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1153"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                    "source"                                    ,
                                      begin
                                          trampCall(_alist)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1153"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             )
                            end
                        else
                            if ( 
                              trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                  begin
                                    if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                      trampCall(@_eqv_QUMARK)
                                    else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_kind)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                  :"expanded"
                              ]
                                           ))
                             ) then
                                begin
                                    delayCall( '_assv_MIMARKref',  'assv-ref',
                                        begin
                                          if @global_lisp_binding.has_key?('_assv_MIMARKref') then
                                            trampCall(@_assv_MIMARKref)
                                          else raise NameError.new( "Error: undefined variable _assv_MIMARKref", "_assv_MIMARKref" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1153"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                        "expanded"                                        ,
                                          begin
                                              trampCall(_alist)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1153"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 )
                                end
                            else
                                if ( 
                                  trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                      begin
                                        if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                          trampCall(@_eqv_QUMARK)
                                        else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(_kind)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                      :"info"
                                  ]
                                               ))
                                 ) then
                                    begin
                                        delayCall( '_string_MIMARKjoin',  'string-join',
                                            begin
                                              if @global_lisp_binding.has_key?('_string_MIMARKjoin') then
                                                trampCall(@_string_MIMARKjoin)
                                              else raise NameError.new( "Error: undefined variable _string_MIMARKjoin", "_string_MIMARKjoin" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1144"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              trampCall( self._list_METHOD(  'list',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_list') then
                                                      trampCall(@_list)
                                                    else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1145"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                    trampCall( self._sprintf_METHOD(  'sprintf',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_sprintf') then
                                                            trampCall(@_sprintf)
                                                          else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1151"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                        " file:   %s 
"                                                        ,
                                                          trampCall( self._assv_MIMARKref_METHOD(  'assv-ref',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_assv_MIMARKref') then
                                                                  trampCall(@_assv_MIMARKref)
                                                                else raise NameError.new( "Error: undefined variable _assv_MIMARKref", "_assv_MIMARKref" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1153"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                              "sourcefile"                                                              ,
                                                                begin
                                                                    trampCall(_alist)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1153"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))
                                                    ]
                                                                 ))                                                  ,
                                                    trampCall( self._sprintf_METHOD(  'sprintf',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_sprintf') then
                                                            trampCall(@_sprintf)
                                                          else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1151"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                        " lineno: %s 
"                                                        ,
                                                          trampCall( self._assv_MIMARKref_METHOD(  'assv-ref',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_assv_MIMARKref') then
                                                                  trampCall(@_assv_MIMARKref)
                                                                else raise NameError.new( "Error: undefined variable _assv_MIMARKref", "_assv_MIMARKref" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1153"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                              "lineno"                                                              ,
                                                                begin
                                                                    trampCall(_alist)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1153"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))
                                                    ]
                                                                 ))                                                  ,
                                                    trampCall( self._sprintf_METHOD(  'sprintf',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_sprintf') then
                                                            trampCall(@_sprintf)
                                                          else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1151"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                        " source: 
"
                                                    ]
                                                                 ))                                                  ,
                                                    trampCall( self._pretty_MIMARKprint_MIMARKto_MIMARKstring_METHOD(  'pretty-print-to-string',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_pretty_MIMARKprint_MIMARKto_MIMARKstring') then
                                                            trampCall(@_pretty_MIMARKprint_MIMARKto_MIMARKstring)
                                                          else raise NameError.new( "Error: undefined variable _pretty_MIMARKprint_MIMARKto_MIMARKstring", "_pretty_MIMARKprint_MIMARKto_MIMARKstring" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1152"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          trampCall( self._assv_MIMARKref_METHOD(  'assv-ref',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_assv_MIMARKref') then
                                                                  trampCall(@_assv_MIMARKref)
                                                                else raise NameError.new( "Error: undefined variable _assv_MIMARKref", "_assv_MIMARKref" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1153"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                              "source"                                                              ,
                                                                begin
                                                                    trampCall(_alist)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1153"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))
                                                    ]
                                                                 ))                                                  ,
                                                    trampCall( self._sprintf_METHOD(  'sprintf',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_sprintf') then
                                                            trampCall(@_sprintf)
                                                          else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1151"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                        " expanded: 
"
                                                    ]
                                                                 ))                                                  ,
                                                    trampCall( self._pretty_MIMARKprint_MIMARKto_MIMARKstring_METHOD(  'pretty-print-to-string',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_pretty_MIMARKprint_MIMARKto_MIMARKstring') then
                                                            trampCall(@_pretty_MIMARKprint_MIMARKto_MIMARKstring)
                                                          else raise NameError.new( "Error: undefined variable _pretty_MIMARKprint_MIMARKto_MIMARKstring", "_pretty_MIMARKprint_MIMARKto_MIMARKstring" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1152"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          trampCall( self._assv_MIMARKref_METHOD(  'assv-ref',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_assv_MIMARKref') then
                                                                  trampCall(@_assv_MIMARKref)
                                                                else raise NameError.new( "Error: undefined variable _assv_MIMARKref", "_assv_MIMARKref" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1153"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                              "expanded"                                                              ,
                                                                begin
                                                                    trampCall(_alist)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1153"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))
                                                    ]
                                                                 ))
                                              ]
                                                           ))
                                        ]
                                                     )
                                    end
                                else
                                    Cell.new()
                                end
                            end
                        end
                    end
                } ; ___lambda.call(
                      begin
                        ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20243| 
                            if ( 
                              trampCall( self._null_QUMARK_METHOD(  'null?',
                                  begin
                                    if @global_lisp_binding.has_key?('_null_QUMARK') then
                                      trampCall(@_null_QUMARK)
                                    else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1080"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20243)
                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                             ) then
                              :"compiled"
                            else
                                delayCall( '_car',  'car',
                                    begin
                                      if @global_lisp_binding.has_key?('_car') then
                                        trampCall(@_car)
                                      else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1083"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20243)
                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             )
                            end
                        } ; ___lambda.call(
                              begin
                                  trampCall(_opt)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1134"] + __e.backtrace ) ; raise __e
                              end
                                   )
                      end                    ,
                      trampCall( self._get_MIMARKsource_MIMARKinfo_METHOD(  'get-source-info',
                          begin
                            if @global_lisp_binding.has_key?('_get_MIMARKsource_MIMARKinfo') then
                              trampCall(@_get_MIMARKsource_MIMARKinfo)
                            else raise NameError.new( "Error: undefined variable _get_MIMARKsource_MIMARKinfo", "_get_MIMARKsource_MIMARKinfo" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1135"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_varname).to_s(
                                  )
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1135"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._compiled_MIMARKcode_MIMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_compiled_MIMARKcode_MIMARKstring'] = self.method( :_compiled_MIMARKcode_MIMARKstring_METHOD )
    @_compiled_MIMARKcode_MIMARKstring = 
    trampCall(
          Proc.new { |_compiled_MIMARKcode,_filename| 
              begin
                ___lambda = lambda { |_compiled_MIMARKbody_MIMARKstring| 
                    _compiled_MIMARKbody_MIMARKstring                     = 
                      Proc.new { |_string_MIMARKlist,_filename| 
                          delayCall( '__PLMARK',  '+',
                              begin
                                if @global_lisp_binding.has_key?('__PLMARK') then
                                  trampCall(@__PLMARK)
                                else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1158"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( self._string_MIMARKjoin_METHOD(  'string-join',
                                    begin
                                      if @global_lisp_binding.has_key?('_string_MIMARKjoin') then
                                        trampCall(@_string_MIMARKjoin)
                                      else raise NameError.new( "Error: undefined variable _string_MIMARKjoin", "_string_MIMARKjoin" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1162"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_string_MIMARKlist)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1160"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                    "
#--------------------
"
                                ]
                                             ))                              ,
                                trampCall( self._string_MIMARKjoin_METHOD(  'string-join',
                                    begin
                                      if @global_lisp_binding.has_key?('_string_MIMARKjoin') then
                                        trampCall(@_string_MIMARKjoin)
                                      else raise NameError.new( "Error: undefined variable _string_MIMARKjoin", "_string_MIMARKjoin" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1162"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      trampCall( self._cons_METHOD(  'cons',
                                          begin
                                            if @global_lisp_binding.has_key?('_cons') then
                                              trampCall(@_cons)
                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                          "

"                                          ,
                                            trampCall( self._cons_METHOD(  'cons',
                                                begin
                                                  if @global_lisp_binding.has_key?('_cons') then
                                                    trampCall(@_cons)
                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                "# -------------------------------------------------------"                                                ,
                                                  trampCall( self._cons_METHOD(  'cons',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cons') then
                                                          trampCall(@_cons)
                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                      "# [EOF]"                                                      ,
                                                        trampCall( self._cons_METHOD(  'cons',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                trampCall(@_cons)
                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                            "# -------------------------------------------------------"                                                            ,
                                                            Cell.new()
                                                        ]
                                                                     ))
                                                  ]
                                                               ))
                                            ]
                                                         ))
                                      ]
                                                   ))                                    ,
                                    "
"
                                ]
                                             ))
                          ]
                                       )
                      }
                    begin
                      ___lambda = lambda { |_str_MIMARKlist,_script_MIMARKflag| 
                          delayCall( '_values',  'values',
                              begin
                                if @global_lisp_binding.has_key?('_values') then
                                  trampCall(@_values)
                                else raise NameError.new( "Error: undefined variable _values", "_values" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1172"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_script_MIMARKflag)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1173"] + __e.backtrace ) ; raise __e
                                end                              ,
                                trampCall( callProcedure(   'compiled-body-string',
                                    begin
                                        trampCall(_compiled_MIMARKbody_MIMARKstring)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1174"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_str_MIMARKlist)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1174"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                      begin
                                          trampCall(_filename)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1174"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))
                          ]
                                       )
                      } ; ___lambda.call(
                            trampCall( self._assv_MIMARKref_METHOD(  'assv-ref',
                                begin
                                  if @global_lisp_binding.has_key?('_assv_MIMARKref') then
                                    trampCall(@_assv_MIMARKref)
                                  else raise NameError.new( "Error: undefined variable _assv_MIMARKref", "_assv_MIMARKref" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1169"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_filename)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1174"] + __e.backtrace ) ; raise __e
                                  end                                ,
                                  begin
                                      trampCall(_compiled_MIMARKcode)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1169"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))                          ,
                            if ( 
                              trampCall( self._not_METHOD(  'not',
                                  begin
                                    if @global_lisp_binding.has_key?('_not') then
                                      trampCall(@_not)
                                    else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1027"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                        begin
                                          if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                            trampCall(@_eq_QUMARK)
                                          else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1126"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                        false                                        ,
                                          trampCall( self._global_MIMARKdefined_QUMARK_METHOD(  'global-defined?',
                                              begin
                                                if @global_lisp_binding.has_key?('_global_MIMARKdefined_QUMARK') then
                                                  trampCall(@_global_MIMARKdefined_QUMARK)
                                                else raise NameError.new( "Error: undefined variable _global_MIMARKdefined_QUMARK", "_global_MIMARKdefined_QUMARK" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1170"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                              :"main"
                                          ]
                                                       ))
                                    ]
                                                 ))
                              ]
                                           ))
                             ) then
                                delayCall( '_procedure_QUMARK',  'procedure?',
                                    begin
                                      if @global_lisp_binding.has_key?('_procedure_QUMARK') then
                                        trampCall(@_procedure_QUMARK)
                                      else raise NameError.new( "Error: undefined variable _procedure_QUMARK", "_procedure_QUMARK" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1171"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                        if @global_lisp_binding.has_key?('_main') then
                                          trampCall(@_main)
                                        else raise NameError.new( "Error: undefined variable _main", "_main" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1171"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             )
                            else
                              false
                            end
                                 )
                    end
                } ; ___lambda.call(
                nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._print_MIMARKcompiled_MIMARKcode_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_print_MIMARKcompiled_MIMARKcode'] = self.method( :_print_MIMARKcompiled_MIMARKcode_METHOD )
    @_print_MIMARKcompiled_MIMARKcode = 
    trampCall(
          Proc.new { |_src,*__rest__| _rest = __rest__[0] ;  
              begin
                ___lambda = lambda { |_print_MIMARKto_MIMARKfile| 
                    _print_MIMARKto_MIMARKfile                     = 
                      Proc.new { |_f| 
                          delayCall( '_call_MIMARKwith_MIMARKvalues',  'call-with-values',
                              begin
                                if @global_lisp_binding.has_key?('_call_MIMARKwith_MIMARKvalues') then
                                  trampCall(@_call_MIMARKwith_MIMARKvalues)
                                else raise NameError.new( "Error: undefined variable _call_MIMARKwith_MIMARKvalues", "_call_MIMARKwith_MIMARKvalues" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:729"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                Proc.new { || 
                                    trampCall( self._compiled_MIMARKcode_MIMARKstring_METHOD(  'compiled-code-string',
                                        begin
                                          if @global_lisp_binding.has_key?('_compiled_MIMARKcode_MIMARKstring') then
                                            trampCall(@_compiled_MIMARKcode_MIMARKstring)
                                          else raise NameError.new( "Error: undefined variable _compiled_MIMARKcode_MIMARKstring", "_compiled_MIMARKcode_MIMARKstring" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1180"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          trampCall( self._get_MIMARKcompiled_MIMARKcode_METHOD(  'get-compiled-code',
                                              begin
                                                if @global_lisp_binding.has_key?('_get_MIMARKcompiled_MIMARKcode') then
                                                  trampCall(@_get_MIMARKcompiled_MIMARKcode)
                                                else raise NameError.new( "Error: undefined variable _get_MIMARKcompiled_MIMARKcode", "_get_MIMARKcompiled_MIMARKcode" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1180"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                          ]
                                                       ))                                        ,
                                          begin
                                              trampCall(_src)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1216"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))
                                }                              ,
                                Proc.new { |_script_MIMARKflag,_str| 
                                    if ( 
                                      begin
                                          trampCall(_script_MIMARKflag)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1181"] + __e.backtrace ) ; raise __e
                                      end
                                     ) then
                                        begin
                                            begin
                                                trampCall(_f).puts(
                                                      trampCall( self._string_MIMARKjoin_METHOD(  'string-join',
                                                          begin
                                                            if @global_lisp_binding.has_key?('_string_MIMARKjoin') then
                                                              trampCall(@_string_MIMARKjoin)
                                                            else raise NameError.new( "Error: undefined variable _string_MIMARKjoin", "_string_MIMARKjoin" ) end
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1202"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            trampCall( self._cons_METHOD(  'cons',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_cons') then
                                                                    trampCall(@_cons)
                                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                "#!/usr/local/bin/ruby"                                                                ,
                                                                  trampCall( self._cons_METHOD(  'cons',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('_cons') then
                                                                          trampCall(@_cons)
                                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                      "# -*- encoding: utf-8 -*-"                                                                      ,
                                                                        trampCall( self._cons_METHOD(  'cons',
                                                                            begin
                                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                                trampCall(@_cons)
                                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                        [
                                                                            "#"                                                                            ,
                                                                              trampCall( self._cons_METHOD(  'cons',
                                                                                  begin
                                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                                      trampCall(@_cons)
                                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                                  end                                                                                ,
                                                                              [
                                                                                  "#    This file is nendo's compiled script file. "                                                                                  ,
                                                                                    trampCall( self._cons_METHOD(  'cons',
                                                                                        begin
                                                                                          if @global_lisp_binding.has_key?('_cons') then
                                                                                            trampCall(@_cons)
                                                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                                        end                                                                                      ,
                                                                                    [
                                                                                        "#    generated  \"nendo -c src\" command. "                                                                                        ,
                                                                                          trampCall( self._cons_METHOD(  'cons',
                                                                                              begin
                                                                                                if @global_lisp_binding.has_key?('_cons') then
                                                                                                  trampCall(@_cons)
                                                                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                                              end                                                                                            ,
                                                                                          [
                                                                                              "#"                                                                                              ,
                                                                                                trampCall( self._cons_METHOD(  'cons',
                                                                                                    begin
                                                                                                      if @global_lisp_binding.has_key?('_cons') then
                                                                                                        trampCall(@_cons)
                                                                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                                                    end                                                                                                  ,
                                                                                                [
                                                                                                    ""                                                                                                    ,
                                                                                                      trampCall( self._cons_METHOD(  'cons',
                                                                                                          begin
                                                                                                            if @global_lisp_binding.has_key?('_cons') then
                                                                                                              trampCall(@_cons)
                                                                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                                                          end                                                                                                        ,
                                                                                                      [
                                                                                                          "require 'rubygems'"                                                                                                          ,
                                                                                                            trampCall( self._cons_METHOD(  'cons',
                                                                                                                begin
                                                                                                                  if @global_lisp_binding.has_key?('_cons') then
                                                                                                                    trampCall(@_cons)
                                                                                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                                                                end                                                                                                              ,
                                                                                                            [
                                                                                                                "require 'nendo'"                                                                                                                ,
                                                                                                                  trampCall( self._cons_METHOD(  'cons',
                                                                                                                      begin
                                                                                                                        if @global_lisp_binding.has_key?('_cons') then
                                                                                                                          trampCall(@_cons)
                                                                                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                                                                      end                                                                                                                    ,
                                                                                                                  [
                                                                                                                      ""                                                                                                                      ,
                                                                                                                        trampCall( self._cons_METHOD(  'cons',
                                                                                                                            begin
                                                                                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                                                                                trampCall(@_cons)
                                                                                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                                                                            end                                                                                                                          ,
                                                                                                                        [
                                                                                                                            "core = Nendo::Core.new()"                                                                                                                            ,
                                                                                                                              trampCall( self._cons_METHOD(  'cons',
                                                                                                                                  begin
                                                                                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                                                                                      trampCall(@_cons)
                                                                                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                                                                                  end                                                                                                                                ,
                                                                                                                              [
                                                                                                                                  "core.loadInitFile()"                                                                                                                                  ,
                                                                                                                                    trampCall( self._cons_METHOD(  'cons',
                                                                                                                                        begin
                                                                                                                                          if @global_lisp_binding.has_key?('_cons') then
                                                                                                                                            trampCall(@_cons)
                                                                                                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                                                                                        end                                                                                                                                      ,
                                                                                                                                    [
                                                                                                                                        "core.setArgv( ARGV )"                                                                                                                                        ,
                                                                                                                                          trampCall( self._cons_METHOD(  'cons',
                                                                                                                                              begin
                                                                                                                                                if @global_lisp_binding.has_key?('_cons') then
                                                                                                                                                  trampCall(@_cons)
                                                                                                                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                                                                                              end                                                                                                                                            ,
                                                                                                                                          [
                                                                                                                                              "core.load_compiled_code_from_string( "                                                                                                                                              ,
                                                                                                                                                trampCall( self._cons_METHOD(  'cons',
                                                                                                                                                    begin
                                                                                                                                                      if @global_lisp_binding.has_key?('_cons') then
                                                                                                                                                        trampCall(@_cons)
                                                                                                                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                                                                                                    end                                                                                                                                                  ,
                                                                                                                                                [
                                                                                                                                                      trampCall( self._write_MIMARKto_MIMARKstring_METHOD(  'write-to-string',
                                                                                                                                                          begin
                                                                                                                                                            if @global_lisp_binding.has_key?('_write_MIMARKto_MIMARKstring') then
                                                                                                                                                              trampCall(@_write_MIMARKto_MIMARKstring)
                                                                                                                                                            else raise NameError.new( "Error: undefined variable _write_MIMARKto_MIMARKstring", "_write_MIMARKto_MIMARKstring" ) end
                                                                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1197"] + __e.backtrace ) ; raise __e
                                                                                                                                                          end                                                                                                                                                        ,
                                                                                                                                                      [
                                                                                                                                                            begin
                                                                                                                                                                trampCall(_str)
                                                                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1210"] + __e.backtrace ) ; raise __e
                                                                                                                                                            end
                                                                                                                                                      ]
                                                                                                                                                                   ))                                                                                                                                                    ,
                                                                                                                                                      trampCall( self._cons_METHOD(  'cons',
                                                                                                                                                          begin
                                                                                                                                                            if @global_lisp_binding.has_key?('_cons') then
                                                                                                                                                              trampCall(@_cons)
                                                                                                                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                                                                                                          end                                                                                                                                                        ,
                                                                                                                                                      [
                                                                                                                                                          " ) "                                                                                                                                                          ,
                                                                                                                                                            trampCall( self._cons_METHOD(  'cons',
                                                                                                                                                                begin
                                                                                                                                                                  if @global_lisp_binding.has_key?('_cons') then
                                                                                                                                                                    trampCall(@_cons)
                                                                                                                                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                                                                                                                end                                                                                                                                                              ,
                                                                                                                                                            [
                                                                                                                                                                "core.evalStr( \"(if (and (global-defined? 'main) (procedure? main)) (main *argv*) #f) \" )"                                                                                                                                                                ,
                                                                                                                                                                  trampCall( self._cons_METHOD(  'cons',
                                                                                                                                                                      begin
                                                                                                                                                                        if @global_lisp_binding.has_key?('_cons') then
                                                                                                                                                                          trampCall(@_cons)
                                                                                                                                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1100"] + __e.backtrace ) ; raise __e
                                                                                                                                                                      end                                                                                                                                                                    ,
                                                                                                                                                                  [
                                                                                                                                                                      ""                                                                                                                                                                      ,
                                                                                                                                                                      Cell.new()
                                                                                                                                                                  ]
                                                                                                                                                                               ))
                                                                                                                                                            ]
                                                                                                                                                                         ))
                                                                                                                                                      ]
                                                                                                                                                                   ))
                                                                                                                                                ]
                                                                                                                                                             ))
                                                                                                                                          ]
                                                                                                                                                       ))
                                                                                                                                    ]
                                                                                                                                                 ))
                                                                                                                              ]
                                                                                                                                           ))
                                                                                                                        ]
                                                                                                                                     ))
                                                                                                                  ]
                                                                                                                               ))
                                                                                                            ]
                                                                                                                         ))
                                                                                                      ]
                                                                                                                   ))
                                                                                                ]
                                                                                                             ))
                                                                                          ]
                                                                                                       ))
                                                                                    ]
                                                                                                 ))
                                                                              ]
                                                                                           ))
                                                                        ]
                                                                                     ))
                                                                  ]
                                                                               ))
                                                            ]
                                                                         ))                                                          ,
                                                          "
"
                                                      ]
                                                                   ))
                                                  )
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1202"] + __e.backtrace ) ; raise __e
                                            end
                                        end
                                    else
                                        if ( 
                                        true
                                         ) then
                                            begin
                                                begin
                                                    trampCall(_f).puts(
                                                          trampCall( self.__PLMARK_METHOD(  '+',
                                                              begin
                                                                if @global_lisp_binding.has_key?('__PLMARK') then
                                                                  trampCall(@__PLMARK)
                                                                else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1202"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                                trampCall( self._string_MIMARKjoin_METHOD(  'string-join',
                                                                    begin
                                                                      if @global_lisp_binding.has_key?('_string_MIMARKjoin') then
                                                                        trampCall(@_string_MIMARKjoin)
                                                                      else raise NameError.new( "Error: undefined variable _string_MIMARKjoin", "_string_MIMARKjoin" ) end
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1202"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                [
                                                                    Cell.new("#",Cell.new("#    This file is nendo's compiled library file. ",Cell.new("#    generated  \"nendo -c src\" command. ",Cell.new("# "))))                                                                    ,
                                                                    "
"
                                                                ]
                                                                             ))                                                              ,
                                                              "
"                                                              ,
                                                                begin
                                                                    trampCall(_str)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1210"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))
                                                      )
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1202"] + __e.backtrace ) ; raise __e
                                                end
                                            end
                                        else
                                            Cell.new()
                                        end
                                    end
                                }
                          ]
                                       )
                      }
                    if ( 
                      trampCall( self._not_METHOD(  'not',
                          begin
                            if @global_lisp_binding.has_key?('_not') then
                              trampCall(@_not)
                            else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1212"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(File).exist?(
                                      begin
                                          trampCall(_src)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1216"] + __e.backtrace ) ; raise __e
                                      end
                                  )
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1212"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                     ) then
                        begin
                            begin raise RuntimeError, 
                              trampCall( self._sprintf_METHOD(  'sprintf',
                                  begin
                                    if @global_lisp_binding.has_key?('_sprintf') then
                                      trampCall(@_sprintf)
                                    else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1151"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                  "Error: file [%s] not found."                                  ,
                                    begin
                                        trampCall(_src)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1216"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                            rescue => __e 
                              __e.set_backtrace( ["./lib/init.nnd:1028"] + __e.backtrace )
                              raise __e
                            end 
                            trampCall( self._exit_METHOD(  'exit',
                                begin
                                  if @global_lisp_binding.has_key?('_exit') then
                                    trampCall(@_exit)
                                  else raise NameError.new( "Error: undefined variable _exit", "_exit" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1214"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                1
                            ]
                                         ))
                        end
                    end
                    trampCall( self._clean_MIMARKcompiled_MIMARKcode_METHOD(  'clean-compiled-code',
                        begin
                          if @global_lisp_binding.has_key?('_clean_MIMARKcompiled_MIMARKcode') then
                            trampCall(@_clean_MIMARKcompiled_MIMARKcode)
                          else raise NameError.new( "Error: undefined variable _clean_MIMARKcompiled_MIMARKcode", "_clean_MIMARKcompiled_MIMARKcode" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1215"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                    ]
                                 ))
                    trampCall( self._load_METHOD(  'load',
                        begin
                          if @global_lisp_binding.has_key?('_load') then
                            trampCall(@_load)
                          else raise NameError.new( "Error: undefined variable _load", "_load" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1216"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                          begin
                              trampCall(_src)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1216"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
                    if ( 
                      trampCall( self._null_QUMARK_METHOD(  'null?',
                          begin
                            if @global_lisp_binding.has_key?('_null_QUMARK') then
                              trampCall(@_null_QUMARK)
                            else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1217"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_rest)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1219"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                     ) then
                        delayCall( '_print_MIMARKto_MIMARKfile',  'print-to-file',
                            begin
                                trampCall(_print_MIMARKto_MIMARKfile)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1221"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              begin
                                  trampCall(STDOUT)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1218"] + __e.backtrace ) ; raise __e
                              end
                        ]
                                     )
                    else
                        delayCall( '_with_MIMARKopen',  'with-open',
                            begin
                              if @global_lisp_binding.has_key?('_with_MIMARKopen') then
                                trampCall(@_with_MIMARKopen)
                              else raise NameError.new( "Error: undefined variable _with_MIMARKopen", "_with_MIMARKopen" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1219"] + __e.backtrace ) ; raise __e
                            end                          ,
                        [
                              trampCall( self._car_METHOD(  'car',
                                  begin
                                    if @global_lisp_binding.has_key?('_car') then
                                      trampCall(@_car)
                                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1219"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_rest)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1219"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))                            ,
                              Proc.new { |_f| 
                                  trampCall( callProcedure(   'print-to-file',
                                      begin
                                          trampCall(_print_MIMARKto_MIMARKfile)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1221"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(_f)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1221"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                              }                            ,
                            "w"
                        ]
                                     )
                    end
                } ; ___lambda.call(
                nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self.__PAMARKcompile_MIMARKphase_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['__PAMARKcompile_MIMARKphase'] = self.method( :__PAMARKcompile_MIMARKphase_METHOD )
    @__PAMARKcompile_MIMARKphase = 
    trampCall(
          Proc.new { |_sexp| 
              if ( 
                trampCall( self._list_QUMARK_METHOD(  'list?',
                    begin
                      if @global_lisp_binding.has_key?('_list_QUMARK') then
                        trampCall(@_list_QUMARK)
                      else raise NameError.new( "Error: undefined variable _list_QUMARK", "_list_QUMARK" ) end
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1236"] + __e.backtrace ) ; raise __e
                    end                  ,
                [
                      begin
                          trampCall(_sexp)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1243"] + __e.backtrace ) ; raise __e
                      end
                ]
                             ))
               ) then
                  begin
                      trampCall( self._for_MIMARKeach_METHOD(  'for-each',
                          begin
                            if @global_lisp_binding.has_key?('_for_MIMARKeach') then
                              trampCall(@_for_MIMARKeach)
                            else raise NameError.new( "Error: undefined variable _for_MIMARKeach", "_for_MIMARKeach" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1237"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            Proc.new { |_func| 
                                begin
                                  
                                  _sexp = 
                                  trampCall(
                                        trampCall( callProcedure(   'func',
                                            begin
                                                trampCall(_func)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1239"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_sexp)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1243"] + __e.backtrace ) ; raise __e
                                              end
                                        ]
                                                     ))
                                  )
                                end
                            }                          ,
                            begin
                              if @global_lisp_binding.has_key?('__PAMARKcompile_MIMARKphase_MIMARKfunctions') then
                                trampCall(@__PAMARKcompile_MIMARKphase_MIMARKfunctions)
                              else raise NameError.new( "Error: undefined variable __PAMARKcompile_MIMARKphase_MIMARKfunctions", "__PAMARKcompile_MIMARKphase_MIMARKfunctions" ) end
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1240"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                      begin
                          trampCall(_sexp)
                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1243"] + __e.backtrace ) ; raise __e
                      end
                  end
              else
                  if ( 
                  true
                   ) then
                      begin
                          begin
                              trampCall(_sexp)
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1243"] + __e.backtrace ) ; raise __e
                          end
                      end
                  else
                      Cell.new()
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._setup_MIMARKtailcall_MIMARKmark_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_setup_MIMARKtailcall_MIMARKmark'] = self.method( :_setup_MIMARKtailcall_MIMARKmark_METHOD )
    @_setup_MIMARKtailcall_MIMARKmark = 
    trampCall(
          Proc.new { |_sexp| 
              begin
                ___lambda = lambda { |_reserved_QUMARK,_setup_MIMARKlet_MIMARKargs,_setup_MIMARKproc,_setup_MIMARKproc_MIMARKbody| 
                    _reserved_QUMARK                     = 
                      Proc.new { |_sym| 
                          begin
                            ___lambda = lambda { |_reserved_MIMARKorig| 
                                begin
                                  ___lambda = lambda { |_reserved| 
                                      delayCall( '_memq',  'memq',
                                          begin
                                            if @global_lisp_binding.has_key?('_memq') then
                                              trampCall(@_memq)
                                            else raise NameError.new( "Error: undefined variable _memq", "_memq" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1257"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_sym)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1257"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                            begin
                                                trampCall(_reserved)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1257"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   )
                                  } ; ___lambda.call(
                                        trampCall( self._append_METHOD(  'append',
                                            begin
                                              if @global_lisp_binding.has_key?('_append') then
                                                trampCall(@_append)
                                              else raise NameError.new( "Error: undefined variable _append", "_append" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1252"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              begin
                                                  trampCall(_reserved_MIMARKorig)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1256"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                              trampCall( self._map_METHOD(  'map',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_map') then
                                                      trampCall(@_map)
                                                    else raise NameError.new( "Error: undefined variable _map", "_map" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1260"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                    Proc.new { |_orig| 
                                                        trampCall( self._string_MIMARK_GTMARKsymbol_METHOD(  'string->symbol',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_string_MIMARK_GTMARKsymbol') then
                                                                trampCall(@_string_MIMARK_GTMARKsymbol)
                                                              else raise NameError.new( "Error: undefined variable _string_MIMARK_GTMARKsymbol", "_string_MIMARK_GTMARKsymbol" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1255"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              trampCall( self.__PLMARK_METHOD(  '+',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('__PLMARK') then
                                                                      trampCall(@__PLMARK)
                                                                    else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1255"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                  "/nendo/macroenv/"                                                                  ,
                                                                    trampCall( self._symbol_MIMARK_GTMARKstring_METHOD(  'symbol->string',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_symbol_MIMARK_GTMARKstring') then
                                                                            trampCall(@_symbol_MIMARK_GTMARKstring)
                                                                          else raise NameError.new( "Error: undefined variable _symbol_MIMARK_GTMARKstring", "_symbol_MIMARK_GTMARKstring" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1255"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          begin
                                                                              trampCall(_orig)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1255"] + __e.backtrace ) ; raise __e
                                                                          end
                                                                    ]
                                                                                 ))
                                                              ]
                                                                           ))
                                                        ]
                                                                     ))
                                                    }                                                  ,
                                                    begin
                                                        trampCall(_reserved_MIMARKorig)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1256"] + __e.backtrace ) ; raise __e
                                                    end
                                              ]
                                                           ))
                                        ]
                                                     ))
                                             )
                                end
                            } ; ___lambda.call(
                                Cell.new(:"quote",Cell.new(:"syntax-quote",Cell.new(:"macro",Cell.new(:"%syntax",Cell.new(:"begin",Cell.new(:"lambda",Cell.new(:"if",Cell.new(:"let",Cell.new(:"letrec",Cell.new(:"define",Cell.new(:"define-syntax")))))))))))
                                       )
                          end
                      }
                    _setup_MIMARKlet_MIMARKargs                     = 
                      Proc.new { |_args| 
                          delayCall( '_map',  'map',
                              begin
                                if @global_lisp_binding.has_key?('_map') then
                                  trampCall(@_map)
                                else raise NameError.new( "Error: undefined variable _map", "_map" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1260"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                Proc.new { |_arg| 
                                    begin
                                      ___lambda = lambda { |_name,_body| 
                                          trampCall( self._list_METHOD(  'list',
                                              begin
                                                if @global_lisp_binding.has_key?('_list') then
                                                  trampCall(@_list)
                                                else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1264"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_name)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1264"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                                if ( 
                                                  trampCall( self._list_QUMARK_METHOD(  'list?',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_list_QUMARK') then
                                                          trampCall(@_list_QUMARK)
                                                        else raise NameError.new( "Error: undefined variable _list_QUMARK", "_list_QUMARK" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1359"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        begin
                                                            trampCall(_body)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1269"] + __e.backtrace ) ; raise __e
                                                        end
                                                  ]
                                                               ))
                                                 ) then
                                                    if ( 
                                                      trampCall( callProcedure(   'reserved?',
                                                          begin
                                                              trampCall(_reserved_QUMARK)
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1361"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                      [
                                                            trampCall( self._car_METHOD(  'car',
                                                                begin
                                                                  if @global_lisp_binding.has_key?('_car') then
                                                                    trampCall(@_car)
                                                                  else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1365"] + __e.backtrace ) ; raise __e
                                                                end                                                              ,
                                                            [
                                                                  begin
                                                                      trampCall(_body)
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1269"] + __e.backtrace ) ; raise __e
                                                                  end
                                                            ]
                                                                         ))
                                                      ]
                                                                   ))
                                                     ) then
                                                        trampCall( self._setup_MIMARKtailcall_MIMARKmark_METHOD(  'setup-tailcall-mark',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_setup_MIMARKtailcall_MIMARKmark') then
                                                                trampCall(@_setup_MIMARKtailcall_MIMARKmark)
                                                              else raise NameError.new( "Error: undefined variable _setup_MIMARKtailcall_MIMARKmark", "_setup_MIMARKtailcall_MIMARKmark" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1362"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              begin
                                                                  trampCall(_body)
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1269"] + __e.backtrace ) ; raise __e
                                                              end
                                                        ]
                                                                     ))
                                                    else
                                                        begin
                                                            trampCall(_body)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1269"] + __e.backtrace ) ; raise __e
                                                        end
                                                    end
                                                else
                                                    begin
                                                        trampCall(_body)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1269"] + __e.backtrace ) ; raise __e
                                                    end
                                                end
                                          ]
                                                       ))
                                      } ; ___lambda.call(
                                            trampCall( self._first_METHOD(  'first',
                                                begin
                                                  if @global_lisp_binding.has_key?('_first') then
                                                    trampCall(@_first)
                                                  else raise NameError.new( "Error: undefined variable _first", "_first" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1262"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_arg)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1263"] + __e.backtrace ) ; raise __e
                                                  end
                                            ]
                                                         ))                                          ,
                                            trampCall( self._second_METHOD(  'second',
                                                begin
                                                  if @global_lisp_binding.has_key?('_second') then
                                                    trampCall(@_second)
                                                  else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1358"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_arg)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1263"] + __e.backtrace ) ; raise __e
                                                  end
                                            ]
                                                         ))
                                                 )
                                    end
                                }                              ,
                                begin
                                    trampCall(_args)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1270"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       )
                      }
                    _setup_MIMARKproc                     = 
                      Proc.new { |_sexp| 
                          if ( 
                            trampCall( self._null_QUMARK_METHOD(  'null?',
                                begin
                                  if @global_lisp_binding.has_key?('_null_QUMARK') then
                                    trampCall(@_null_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_sexp)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                           ) then
                              begin
                                  begin
                                      trampCall(_sexp)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                  end
                              end
                          else
                              if ( 
                                if ( 
                                  trampCall( self._not_METHOD(  'not',
                                      begin
                                        if @global_lisp_binding.has_key?('_not') then
                                          trampCall(@_not)
                                        else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                            begin
                                              if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                trampCall(@_eq_QUMARK)
                                              else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1126"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                            false                                            ,
                                              trampCall( self._list_QUMARK_METHOD(  'list?',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_list_QUMARK') then
                                                      trampCall(@_list_QUMARK)
                                                    else raise NameError.new( "Error: undefined variable _list_QUMARK", "_list_QUMARK" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1359"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                    begin
                                                        trampCall(_sexp)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                    end
                                              ]
                                                           ))
                                        ]
                                                     ))
                                  ]
                                               ))
                                 ) then
                                    trampCall( self.__LTMARK_METHOD(  '<',
                                        begin
                                          if @global_lisp_binding.has_key?('__LTMARK') then
                                            trampCall(@__LTMARK)
                                          else raise NameError.new( "Error: undefined variable __LTMARK", "__LTMARK" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1277"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                        0                                        ,
                                          trampCall( self._length_METHOD(  'length',
                                              begin
                                                if @global_lisp_binding.has_key?('_length') then
                                                  trampCall(@_length)
                                                else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1328"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_sexp)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))
                                    ]
                                                 ))
                                else
                                  false
                                end
                               ) then
                                  begin
                                      if ( 
                                        trampCall( callProcedure(   'reserved?',
                                            begin
                                                trampCall(_reserved_QUMARK)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1361"] + __e.backtrace ) ; raise __e
                                            end                                          ,
                                        [
                                              trampCall( self._car_METHOD(  'car',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_car') then
                                                      trampCall(@_car)
                                                    else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1365"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                    begin
                                                        trampCall(_sexp)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                    end
                                              ]
                                                           ))
                                        ]
                                                     ))
                                       ) then
                                          delayCall( '_setup_MIMARKtailcall_MIMARKmark',  'setup-tailcall-mark',
                                              begin
                                                if @global_lisp_binding.has_key?('_setup_MIMARKtailcall_MIMARKmark') then
                                                  trampCall(@_setup_MIMARKtailcall_MIMARKmark)
                                                else raise NameError.new( "Error: undefined variable _setup_MIMARKtailcall_MIMARKmark", "_setup_MIMARKtailcall_MIMARKmark" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1362"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_sexp)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       )
                                      else
                                          if ( 
                                            trampCall( self._pair_QUMARK_METHOD(  'pair?',
                                                begin
                                                  if @global_lisp_binding.has_key?('_pair_QUMARK') then
                                                    trampCall(@_pair_QUMARK)
                                                  else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1305"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  trampCall( self._car_METHOD(  'car',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_car') then
                                                          trampCall(@_car)
                                                        else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1365"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        begin
                                                            trampCall(_sexp)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                        end
                                                  ]
                                                               ))
                                            ]
                                                         ))
                                           ) then
                                              begin
                                                  trampCall(_sexp)
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                              end
                                          else
                                              delayCall( '_cons',  'cons',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_cons') then
                                                      trampCall(@_cons)
                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                  :"%tailcall"                                                  ,
                                                    trampCall( self._cons_METHOD(  'cons',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_cons') then
                                                            trampCall(@_cons)
                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          begin
                                                              trampCall(_sexp)
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                          end                                                        ,
                                                        Cell.new()
                                                    ]
                                                                 ))
                                              ]
                                                           )
                                          end
                                      end
                                  end
                              else
                                  if ( 
                                  true
                                   ) then
                                      begin
                                          begin
                                              trampCall(_sexp)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                          end
                                      end
                                  else
                                      Cell.new()
                                  end
                              end
                          end
                      }
                    _setup_MIMARKproc_MIMARKbody                     = 
                      Proc.new { |_sexp| 
                          if ( 
                            begin
                              ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20255| 
                                  if ( 
                                    begin
                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20255)
                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                    end
                                   ) then
                                      begin
                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20255)
                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                      end
                                  else
                                      begin
                                        ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20256| 
                                            if ( 
                                              begin
                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20256)
                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                              end
                                             ) then
                                                begin
                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20256)
                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                end
                                            else
                                              false
                                            end
                                        } ; ___lambda.call(
                                              trampCall( self._null_QUMARK_METHOD(  'null?',
                                                  begin
                                                    if @global_lisp_binding.has_key?('_null_QUMARK') then
                                                      trampCall(@_null_QUMARK)
                                                    else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
                                                  end                                                ,
                                              [
                                                    begin
                                                        trampCall(_sexp)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                    end
                                              ]
                                                           ))
                                                   )
                                      end
                                  end
                              } ; ___lambda.call(
                                    trampCall( self._not_METHOD(  'not',
                                        begin
                                          if @global_lisp_binding.has_key?('_not') then
                                            trampCall(@_not)
                                          else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          trampCall( self._list_QUMARK_METHOD(  'list?',
                                              begin
                                                if @global_lisp_binding.has_key?('_list_QUMARK') then
                                                  trampCall(@_list_QUMARK)
                                                else raise NameError.new( "Error: undefined variable _list_QUMARK", "_list_QUMARK" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1359"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                                begin
                                                    trampCall(_sexp)
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))
                                    ]
                                                 ))
                                         )
                            end
                           ) then
                              begin
                                  trampCall(_sexp)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                              end
                          else
                              begin
                                ___lambda = lambda { |_r| 
                                    begin
                                      ___lambda = lambda { |_last| 
                                          begin
                                            ___lambda = lambda { |_other| 
                                                if ( 
                                                  trampCall( self._not_METHOD(  'not',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_not') then
                                                          trampCall(@_not)
                                                        else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        trampCall( self._pair_QUMARK_METHOD(  'pair?',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_pair_QUMARK') then
                                                                trampCall(@_pair_QUMARK)
                                                              else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1305"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              begin
                                                                  trampCall(_last)
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1301"] + __e.backtrace ) ; raise __e
                                                              end
                                                        ]
                                                                     ))
                                                  ]
                                                               ))
                                                 ) then
                                                    begin
                                                        trampCall(_sexp)
                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                    end
                                                else
                                                    delayCall( '_reverse',  'reverse',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_reverse') then
                                                            trampCall(@_reverse)
                                                          else raise NameError.new( "Error: undefined variable _reverse", "_reverse" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1295"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          trampCall( self._cons_METHOD(  'cons',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_cons') then
                                                                  trampCall(@_cons)
                                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                                if ( 
                                                                  trampCall( callProcedure(   'reserved?',
                                                                      begin
                                                                          trampCall(_reserved_QUMARK)
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1361"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                        trampCall( self._car_METHOD(  'car',
                                                                            begin
                                                                              if @global_lisp_binding.has_key?('_car') then
                                                                                trampCall(@_car)
                                                                              else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1365"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                        [
                                                                              begin
                                                                                  trampCall(_last)
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1301"] + __e.backtrace ) ; raise __e
                                                                              end
                                                                        ]
                                                                                     ))
                                                                  ]
                                                                               ))
                                                                 ) then
                                                                    trampCall( self._setup_MIMARKtailcall_MIMARKmark_METHOD(  'setup-tailcall-mark',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_setup_MIMARKtailcall_MIMARKmark') then
                                                                            trampCall(@_setup_MIMARKtailcall_MIMARKmark)
                                                                          else raise NameError.new( "Error: undefined variable _setup_MIMARKtailcall_MIMARKmark", "_setup_MIMARKtailcall_MIMARKmark" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1362"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          begin
                                                                              trampCall(_last)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1301"] + __e.backtrace ) ; raise __e
                                                                          end
                                                                    ]
                                                                                 ))
                                                                else
                                                                    trampCall( self._cons_METHOD(  'cons',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_cons') then
                                                                            trampCall(@_cons)
                                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                        :"%tailcall"                                                                        ,
                                                                          trampCall( self._cons_METHOD(  'cons',
                                                                              begin
                                                                                if @global_lisp_binding.has_key?('_cons') then
                                                                                  trampCall(@_cons)
                                                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                          [
                                                                                begin
                                                                                    trampCall(_last)
                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1301"] + __e.backtrace ) ; raise __e
                                                                                end                                                                              ,
                                                                              Cell.new()
                                                                          ]
                                                                                       ))
                                                                    ]
                                                                                 ))
                                                                end                                                              ,
                                                                begin
                                                                    trampCall(_other)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1302"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))
                                                    ]
                                                                 )
                                                end
                                            } ; ___lambda.call(
                                                  trampCall( self._cdr_METHOD(  'cdr',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cdr') then
                                                          trampCall(@_cdr)
                                                        else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1322"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        begin
                                                            trampCall(_r)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1292"] + __e.backtrace ) ; raise __e
                                                        end
                                                  ]
                                                               ))
                                                       )
                                          end
                                      } ; ___lambda.call(
                                            trampCall( self._car_METHOD(  'car',
                                                begin
                                                  if @global_lisp_binding.has_key?('_car') then
                                                    trampCall(@_car)
                                                  else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1365"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_r)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1292"] + __e.backtrace ) ; raise __e
                                                  end
                                            ]
                                                         ))
                                                 )
                                    end
                                } ; ___lambda.call(
                                      trampCall( self._reverse_METHOD(  'reverse',
                                          begin
                                            if @global_lisp_binding.has_key?('_reverse') then
                                              trampCall(@_reverse)
                                            else raise NameError.new( "Error: undefined variable _reverse", "_reverse" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1295"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                            begin
                                                trampCall(_sexp)
                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                            end
                                      ]
                                                   ))
                                           )
                              end
                          end
                      }
                    if ( 
                      trampCall( self._not_METHOD(  'not',
                          begin
                            if @global_lisp_binding.has_key?('_not') then
                              trampCall(@_not)
                            else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            trampCall( self._pair_QUMARK_METHOD(  'pair?',
                                begin
                                  if @global_lisp_binding.has_key?('_pair_QUMARK') then
                                    trampCall(@_pair_QUMARK)
                                  else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1305"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_sexp)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                      ]
                                   ))
                     ) then
                        begin
                            begin
                                trampCall(_sexp)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                            end
                        end
                    else
                        if ( 
                          trampCall( self._null_QUMARK_METHOD(  'null?',
                              begin
                                if @global_lisp_binding.has_key?('_null_QUMARK') then
                                  trampCall(@_null_QUMARK)
                                else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                begin
                                    trampCall(_sexp)
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                end
                          ]
                                       ))
                         ) then
                            begin
                              Cell.new()
                            end
                        else
                            if ( 
                              trampCall( self._list_QUMARK_METHOD(  'list?',
                                  begin
                                    if @global_lisp_binding.has_key?('_list_QUMARK') then
                                      trampCall(@_list_QUMARK)
                                    else raise NameError.new( "Error: undefined variable _list_QUMARK", "_list_QUMARK" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1359"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    begin
                                        trampCall(_sexp)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                    end
                              ]
                                           ))
                             ) then
                                begin
                                    begin
                                      ___lambda = lambda { |__car| 
                                          begin
                                            ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261| 
                                                if ( 
                                                  begin
                                                    ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20274| 
                                                        if ( 
                                                          begin
                                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20274)
                                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                          end
                                                         ) then
                                                            begin
                                                                trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20274)
                                                              rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                            end
                                                        else
                                                            begin
                                                              ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20275| 
                                                                  if ( 
                                                                    begin
                                                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20275)
                                                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                    end
                                                                   ) then
                                                                      begin
                                                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20275)
                                                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                      end
                                                                  else
                                                                    false
                                                                  end
                                                              } ; ___lambda.call(
                                                                    trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                            trampCall(@_eqv_QUMARK)
                                                                          else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                        :"/nendo/macroenv/quote"                                                                        ,
                                                                          begin
                                                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                          end
                                                                    ]
                                                                                 ))
                                                                         )
                                                            end
                                                        end
                                                    } ; ___lambda.call(
                                                          trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                              begin
                                                                if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                  trampCall(@_eqv_QUMARK)
                                                                else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                              :"quote"                                                              ,
                                                                begin
                                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                end
                                                          ]
                                                                       ))
                                                               )
                                                  end
                                                 ) then
                                                    begin
                                                        begin
                                                            trampCall(_sexp)
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                        end
                                                    end
                                                else
                                                    if ( 
                                                      begin
                                                        ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20276| 
                                                            if ( 
                                                              begin
                                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20276)
                                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                              end
                                                             ) then
                                                                begin
                                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20276)
                                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                end
                                                            else
                                                                begin
                                                                  ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20277| 
                                                                      if ( 
                                                                        begin
                                                                            trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20277)
                                                                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                        end
                                                                       ) then
                                                                          begin
                                                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20277)
                                                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                          end
                                                                      else
                                                                        false
                                                                      end
                                                                  } ; ___lambda.call(
                                                                        trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                            begin
                                                                              if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                trampCall(@_eqv_QUMARK)
                                                                              else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                        [
                                                                            :"/nendo/macroenv/syntax-quote"                                                                            ,
                                                                              begin
                                                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                              end
                                                                        ]
                                                                                     ))
                                                                             )
                                                                end
                                                            end
                                                        } ; ___lambda.call(
                                                              trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                      trampCall(@_eqv_QUMARK)
                                                                    else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                  :"syntax-quote"                                                                  ,
                                                                    begin
                                                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                    end
                                                              ]
                                                                           ))
                                                                   )
                                                      end
                                                     ) then
                                                        begin
                                                            begin
                                                                trampCall(_sexp)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                            end
                                                        end
                                                    else
                                                        if ( 
                                                          begin
                                                            ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20278| 
                                                                if ( 
                                                                  begin
                                                                      trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20278)
                                                                    rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                  end
                                                                 ) then
                                                                    begin
                                                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20278)
                                                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                    end
                                                                else
                                                                    begin
                                                                      ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20279| 
                                                                          if ( 
                                                                            begin
                                                                                trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20279)
                                                                              rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                            end
                                                                           ) then
                                                                              begin
                                                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20279)
                                                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                              end
                                                                          else
                                                                            false
                                                                          end
                                                                      } ; ___lambda.call(
                                                                            trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                begin
                                                                                  if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                    trampCall(@_eqv_QUMARK)
                                                                                  else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                end                                                                              ,
                                                                            [
                                                                                :"/nendo/macroenv/macro"                                                                                ,
                                                                                  begin
                                                                                      trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                    rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                  end
                                                                            ]
                                                                                         ))
                                                                                 )
                                                                    end
                                                                end
                                                            } ; ___lambda.call(
                                                                  trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                      begin
                                                                        if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                          trampCall(@_eqv_QUMARK)
                                                                        else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                      end                                                                    ,
                                                                  [
                                                                      :"macro"                                                                      ,
                                                                        begin
                                                                            trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                        end
                                                                  ]
                                                                               ))
                                                                       )
                                                          end
                                                         ) then
                                                            begin
                                                                begin
                                                                    trampCall(_sexp)
                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                end
                                                            end
                                                        else
                                                            if ( 
                                                              begin
                                                                ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20280| 
                                                                    if ( 
                                                                      begin
                                                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20280)
                                                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                      end
                                                                     ) then
                                                                        begin
                                                                            trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20280)
                                                                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                        end
                                                                    else
                                                                        begin
                                                                          ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20281| 
                                                                              if ( 
                                                                                begin
                                                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20281)
                                                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                end
                                                                               ) then
                                                                                  begin
                                                                                      trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20281)
                                                                                    rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                  end
                                                                              else
                                                                                false
                                                                              end
                                                                          } ; ___lambda.call(
                                                                                trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                    begin
                                                                                      if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                        trampCall(@_eqv_QUMARK)
                                                                                      else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                    end                                                                                  ,
                                                                                [
                                                                                    :"/nendo/macroenv/%syntax"                                                                                    ,
                                                                                      begin
                                                                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                      end
                                                                                ]
                                                                                             ))
                                                                                     )
                                                                        end
                                                                    end
                                                                } ; ___lambda.call(
                                                                      trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                          begin
                                                                            if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                              trampCall(@_eqv_QUMARK)
                                                                            else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                      [
                                                                          :"%syntax"                                                                          ,
                                                                            begin
                                                                                trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                              rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                            end
                                                                      ]
                                                                                   ))
                                                                           )
                                                              end
                                                             ) then
                                                                begin
                                                                    begin
                                                                        trampCall(_sexp)
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                    end
                                                                end
                                                            else
                                                                if ( 
                                                                  begin
                                                                    ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20282| 
                                                                        if ( 
                                                                          begin
                                                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20282)
                                                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                          end
                                                                         ) then
                                                                            begin
                                                                                trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20282)
                                                                              rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                            end
                                                                        else
                                                                            begin
                                                                              ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20283| 
                                                                                  if ( 
                                                                                    begin
                                                                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20283)
                                                                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                    end
                                                                                   ) then
                                                                                      begin
                                                                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20283)
                                                                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                      end
                                                                                  else
                                                                                    false
                                                                                  end
                                                                              } ; ___lambda.call(
                                                                                    trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                        begin
                                                                                          if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                            trampCall(@_eqv_QUMARK)
                                                                                          else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                        end                                                                                      ,
                                                                                    [
                                                                                        :"/nendo/macroenv/begin"                                                                                        ,
                                                                                          begin
                                                                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                          end
                                                                                    ]
                                                                                                 ))
                                                                                         )
                                                                            end
                                                                        end
                                                                    } ; ___lambda.call(
                                                                          trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                              begin
                                                                                if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                  trampCall(@_eqv_QUMARK)
                                                                                else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                          [
                                                                              :"begin"                                                                              ,
                                                                                begin
                                                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                end
                                                                          ]
                                                                                       ))
                                                                               )
                                                                  end
                                                                 ) then
                                                                    begin
                                                                        delayCall( '_cons',  'cons',
                                                                            begin
                                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                                trampCall(@_cons)
                                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                            end                                                                          ,
                                                                        [
                                                                              begin
                                                                                  trampCall(__car)
                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1357"] + __e.backtrace ) ; raise __e
                                                                              end                                                                            ,
                                                                              trampCall( callProcedure(   'setup-proc-body',
                                                                                  begin
                                                                                      trampCall(_setup_MIMARKproc_MIMARKbody)
                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1345"] + __e.backtrace ) ; raise __e
                                                                                  end                                                                                ,
                                                                              [
                                                                                    trampCall( self._cdr_METHOD(  'cdr',
                                                                                        begin
                                                                                          if @global_lisp_binding.has_key?('_cdr') then
                                                                                            trampCall(@_cdr)
                                                                                          else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1322"] + __e.backtrace ) ; raise __e
                                                                                        end                                                                                      ,
                                                                                    [
                                                                                          begin
                                                                                              trampCall(_sexp)
                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                          end
                                                                                    ]
                                                                                                 ))
                                                                              ]
                                                                                           ))
                                                                        ]
                                                                                     )
                                                                    end
                                                                else
                                                                    if ( 
                                                                      begin
                                                                        ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20284| 
                                                                            if ( 
                                                                              begin
                                                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20284)
                                                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                              end
                                                                             ) then
                                                                                begin
                                                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20284)
                                                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                end
                                                                            else
                                                                                begin
                                                                                  ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20285| 
                                                                                      if ( 
                                                                                        begin
                                                                                            trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20285)
                                                                                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                        end
                                                                                       ) then
                                                                                          begin
                                                                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20285)
                                                                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                          end
                                                                                      else
                                                                                        false
                                                                                      end
                                                                                  } ; ___lambda.call(
                                                                                        trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                            begin
                                                                                              if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                                trampCall(@_eqv_QUMARK)
                                                                                              else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                            end                                                                                          ,
                                                                                        [
                                                                                            :"/nendo/macroenv/lambda"                                                                                            ,
                                                                                              begin
                                                                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                              end
                                                                                        ]
                                                                                                     ))
                                                                                             )
                                                                                end
                                                                            end
                                                                        } ; ___lambda.call(
                                                                              trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                  begin
                                                                                    if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                      trampCall(@_eqv_QUMARK)
                                                                                    else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                  end                                                                                ,
                                                                              [
                                                                                  :"lambda"                                                                                  ,
                                                                                    begin
                                                                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                    end
                                                                              ]
                                                                                           ))
                                                                                   )
                                                                      end
                                                                     ) then
                                                                        begin
                                                                            delayCall( '_cons',  'cons',
                                                                                begin
                                                                                  if @global_lisp_binding.has_key?('_cons') then
                                                                                    trampCall(@_cons)
                                                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                end                                                                              ,
                                                                            [
                                                                                  begin
                                                                                      trampCall(__car)
                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1357"] + __e.backtrace ) ; raise __e
                                                                                  end                                                                                ,
                                                                                  trampCall( self._cons_METHOD(  'cons',
                                                                                      begin
                                                                                        if @global_lisp_binding.has_key?('_cons') then
                                                                                          trampCall(@_cons)
                                                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                      end                                                                                    ,
                                                                                  [
                                                                                        trampCall( self._second_METHOD(  'second',
                                                                                            begin
                                                                                              if @global_lisp_binding.has_key?('_second') then
                                                                                                trampCall(@_second)
                                                                                              else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1358"] + __e.backtrace ) ; raise __e
                                                                                            end                                                                                          ,
                                                                                        [
                                                                                              begin
                                                                                                  trampCall(_sexp)
                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                              end
                                                                                        ]
                                                                                                     ))                                                                                      ,
                                                                                        trampCall( callProcedure(   'setup-proc-body',
                                                                                            begin
                                                                                                trampCall(_setup_MIMARKproc_MIMARKbody)
                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1345"] + __e.backtrace ) ; raise __e
                                                                                            end                                                                                          ,
                                                                                        [
                                                                                              trampCall( self._cddr_METHOD(  'cddr',
                                                                                                  begin
                                                                                                    if @global_lisp_binding.has_key?('_cddr') then
                                                                                                      trampCall(@_cddr)
                                                                                                    else raise NameError.new( "Error: undefined variable _cddr", "_cddr" ) end
                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1345"] + __e.backtrace ) ; raise __e
                                                                                                  end                                                                                                ,
                                                                                              [
                                                                                                    begin
                                                                                                        trampCall(_sexp)
                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                    end
                                                                                              ]
                                                                                                           ))
                                                                                        ]
                                                                                                     ))
                                                                                  ]
                                                                                               ))
                                                                            ]
                                                                                         )
                                                                        end
                                                                    else
                                                                        if ( 
                                                                          begin
                                                                            ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20286| 
                                                                                if ( 
                                                                                  begin
                                                                                      trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20286)
                                                                                    rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                  end
                                                                                 ) then
                                                                                    begin
                                                                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20286)
                                                                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                    end
                                                                                else
                                                                                    begin
                                                                                      ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20287| 
                                                                                          if ( 
                                                                                            begin
                                                                                                trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20287)
                                                                                              rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                            end
                                                                                           ) then
                                                                                              begin
                                                                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20287)
                                                                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                              end
                                                                                          else
                                                                                            false
                                                                                          end
                                                                                      } ; ___lambda.call(
                                                                                            trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                                begin
                                                                                                  if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                                    trampCall(@_eqv_QUMARK)
                                                                                                  else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                                end                                                                                              ,
                                                                                            [
                                                                                                :"/nendo/macroenv/if"                                                                                                ,
                                                                                                  begin
                                                                                                      trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                                    rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                  end
                                                                                            ]
                                                                                                         ))
                                                                                                 )
                                                                                    end
                                                                                end
                                                                            } ; ___lambda.call(
                                                                                  trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                      begin
                                                                                        if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                          trampCall(@_eqv_QUMARK)
                                                                                        else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                      end                                                                                    ,
                                                                                  [
                                                                                      :"if"                                                                                      ,
                                                                                        begin
                                                                                            trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                        end
                                                                                  ]
                                                                                               ))
                                                                                       )
                                                                          end
                                                                         ) then
                                                                            begin
                                                                                begin
                                                                                  ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20288| 
                                                                                      if ( 
                                                                                        begin
                                                                                          ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20301| 
                                                                                              if ( 
                                                                                                begin
                                                                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20301)
                                                                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                end
                                                                                               ) then
                                                                                                  begin
                                                                                                      trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20301)
                                                                                                    rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                  end
                                                                                              else
                                                                                                false
                                                                                              end
                                                                                          } ; ___lambda.call(
                                                                                                trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                                    begin
                                                                                                      if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                                        trampCall(@_eqv_QUMARK)
                                                                                                      else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                                    end                                                                                                  ,
                                                                                                [
                                                                                                    3                                                                                                    ,
                                                                                                      begin
                                                                                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20288)
                                                                                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                      end
                                                                                                ]
                                                                                                             ))
                                                                                                     )
                                                                                        end
                                                                                       ) then
                                                                                          begin
                                                                                              delayCall( '_cons',  'cons',
                                                                                                  begin
                                                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                                                      trampCall(@_cons)
                                                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                  end                                                                                                ,
                                                                                              [
                                                                                                    begin
                                                                                                        trampCall(__car)
                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1357"] + __e.backtrace ) ; raise __e
                                                                                                    end                                                                                                  ,
                                                                                                    trampCall( self._cons_METHOD(  'cons',
                                                                                                        begin
                                                                                                          if @global_lisp_binding.has_key?('_cons') then
                                                                                                            trampCall(@_cons)
                                                                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                        end                                                                                                      ,
                                                                                                    [
                                                                                                          trampCall( self._second_METHOD(  'second',
                                                                                                              begin
                                                                                                                if @global_lisp_binding.has_key?('_second') then
                                                                                                                  trampCall(@_second)
                                                                                                                else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1358"] + __e.backtrace ) ; raise __e
                                                                                                              end                                                                                                            ,
                                                                                                          [
                                                                                                                begin
                                                                                                                    trampCall(_sexp)
                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                                end
                                                                                                          ]
                                                                                                                       ))                                                                                                        ,
                                                                                                          trampCall( self._cons_METHOD(  'cons',
                                                                                                              begin
                                                                                                                if @global_lisp_binding.has_key?('_cons') then
                                                                                                                  trampCall(@_cons)
                                                                                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                              end                                                                                                            ,
                                                                                                          [
                                                                                                                trampCall( callProcedure(   'setup-proc',
                                                                                                                    begin
                                                                                                                        trampCall(_setup_MIMARKproc)
                                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1337"] + __e.backtrace ) ; raise __e
                                                                                                                    end                                                                                                                  ,
                                                                                                                [
                                                                                                                      trampCall( self._third_METHOD(  'third',
                                                                                                                          begin
                                                                                                                            if @global_lisp_binding.has_key?('_third') then
                                                                                                                              trampCall(@_third)
                                                                                                                            else raise NameError.new( "Error: undefined variable _third", "_third" ) end
                                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1356"] + __e.backtrace ) ; raise __e
                                                                                                                          end                                                                                                                        ,
                                                                                                                      [
                                                                                                                            begin
                                                                                                                                trampCall(_sexp)
                                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                                            end
                                                                                                                      ]
                                                                                                                                   ))
                                                                                                                ]
                                                                                                                             ))                                                                                                              ,
                                                                                                              Cell.new()
                                                                                                          ]
                                                                                                                       ))
                                                                                                    ]
                                                                                                                 ))
                                                                                              ]
                                                                                                           )
                                                                                          end
                                                                                      else
                                                                                          if ( 
                                                                                            begin
                                                                                              ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20302| 
                                                                                                  if ( 
                                                                                                    begin
                                                                                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20302)
                                                                                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                    end
                                                                                                   ) then
                                                                                                      begin
                                                                                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20302)
                                                                                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                      end
                                                                                                  else
                                                                                                    false
                                                                                                  end
                                                                                              } ; ___lambda.call(
                                                                                                    trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                                        begin
                                                                                                          if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                                            trampCall(@_eqv_QUMARK)
                                                                                                          else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                                        end                                                                                                      ,
                                                                                                    [
                                                                                                        4                                                                                                        ,
                                                                                                          begin
                                                                                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20288)
                                                                                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                          end
                                                                                                    ]
                                                                                                                 ))
                                                                                                         )
                                                                                            end
                                                                                           ) then
                                                                                              begin
                                                                                                  delayCall( '_cons',  'cons',
                                                                                                      begin
                                                                                                        if @global_lisp_binding.has_key?('_cons') then
                                                                                                          trampCall(@_cons)
                                                                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                      end                                                                                                    ,
                                                                                                  [
                                                                                                        begin
                                                                                                            trampCall(__car)
                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1357"] + __e.backtrace ) ; raise __e
                                                                                                        end                                                                                                      ,
                                                                                                        trampCall( self._cons_METHOD(  'cons',
                                                                                                            begin
                                                                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                                                                trampCall(@_cons)
                                                                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                            end                                                                                                          ,
                                                                                                        [
                                                                                                              trampCall( self._second_METHOD(  'second',
                                                                                                                  begin
                                                                                                                    if @global_lisp_binding.has_key?('_second') then
                                                                                                                      trampCall(@_second)
                                                                                                                    else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1358"] + __e.backtrace ) ; raise __e
                                                                                                                  end                                                                                                                ,
                                                                                                              [
                                                                                                                    begin
                                                                                                                        trampCall(_sexp)
                                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                                    end
                                                                                                              ]
                                                                                                                           ))                                                                                                            ,
                                                                                                              trampCall( self._cons_METHOD(  'cons',
                                                                                                                  begin
                                                                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                                                                      trampCall(@_cons)
                                                                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                                  end                                                                                                                ,
                                                                                                              [
                                                                                                                    trampCall( callProcedure(   'setup-proc',
                                                                                                                        begin
                                                                                                                            trampCall(_setup_MIMARKproc)
                                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1337"] + __e.backtrace ) ; raise __e
                                                                                                                        end                                                                                                                      ,
                                                                                                                    [
                                                                                                                          trampCall( self._third_METHOD(  'third',
                                                                                                                              begin
                                                                                                                                if @global_lisp_binding.has_key?('_third') then
                                                                                                                                  trampCall(@_third)
                                                                                                                                else raise NameError.new( "Error: undefined variable _third", "_third" ) end
                                                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1356"] + __e.backtrace ) ; raise __e
                                                                                                                              end                                                                                                                            ,
                                                                                                                          [
                                                                                                                                begin
                                                                                                                                    trampCall(_sexp)
                                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                                                end
                                                                                                                          ]
                                                                                                                                       ))
                                                                                                                    ]
                                                                                                                                 ))                                                                                                                  ,
                                                                                                                    trampCall( self._cons_METHOD(  'cons',
                                                                                                                        begin
                                                                                                                          if @global_lisp_binding.has_key?('_cons') then
                                                                                                                            trampCall(@_cons)
                                                                                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                                        end                                                                                                                      ,
                                                                                                                    [
                                                                                                                          trampCall( callProcedure(   'setup-proc',
                                                                                                                              begin
                                                                                                                                  trampCall(_setup_MIMARKproc)
                                                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1337"] + __e.backtrace ) ; raise __e
                                                                                                                              end                                                                                                                            ,
                                                                                                                          [
                                                                                                                                trampCall( self._fourth_METHOD(  'fourth',
                                                                                                                                    begin
                                                                                                                                      if @global_lisp_binding.has_key?('_fourth') then
                                                                                                                                        trampCall(@_fourth)
                                                                                                                                      else raise NameError.new( "Error: undefined variable _fourth", "_fourth" ) end
                                                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1337"] + __e.backtrace ) ; raise __e
                                                                                                                                    end                                                                                                                                  ,
                                                                                                                                [
                                                                                                                                      begin
                                                                                                                                          trampCall(_sexp)
                                                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                                                      end
                                                                                                                                ]
                                                                                                                                             ))
                                                                                                                          ]
                                                                                                                                       ))                                                                                                                        ,
                                                                                                                        Cell.new()
                                                                                                                    ]
                                                                                                                                 ))
                                                                                                              ]
                                                                                                                           ))
                                                                                                        ]
                                                                                                                     ))
                                                                                                  ]
                                                                                                               )
                                                                                              end
                                                                                          else
                                                                                              Cell.new()
                                                                                          end
                                                                                      end
                                                                                  } ; ___lambda.call(
                                                                                        trampCall( self._length_METHOD(  'length',
                                                                                            begin
                                                                                              if @global_lisp_binding.has_key?('_length') then
                                                                                                trampCall(@_length)
                                                                                              else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1328"] + __e.backtrace ) ; raise __e
                                                                                            end                                                                                          ,
                                                                                        [
                                                                                              begin
                                                                                                  trampCall(_sexp)
                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                              end
                                                                                        ]
                                                                                                     ))
                                                                                             )
                                                                                end
                                                                            end
                                                                        else
                                                                            if ( 
                                                                              begin
                                                                                ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20289| 
                                                                                    if ( 
                                                                                      begin
                                                                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20289)
                                                                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                      end
                                                                                     ) then
                                                                                        begin
                                                                                            trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20289)
                                                                                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                        end
                                                                                    else
                                                                                        begin
                                                                                          ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20290| 
                                                                                              if ( 
                                                                                                begin
                                                                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20290)
                                                                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                end
                                                                                               ) then
                                                                                                  begin
                                                                                                      trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20290)
                                                                                                    rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                  end
                                                                                              else
                                                                                                false
                                                                                              end
                                                                                          } ; ___lambda.call(
                                                                                                trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                                    begin
                                                                                                      if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                                        trampCall(@_eqv_QUMARK)
                                                                                                      else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                                    end                                                                                                  ,
                                                                                                [
                                                                                                    :"/nendo/macroenv/let"                                                                                                    ,
                                                                                                      begin
                                                                                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                      end
                                                                                                ]
                                                                                                             ))
                                                                                                     )
                                                                                        end
                                                                                    end
                                                                                } ; ___lambda.call(
                                                                                      trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                          begin
                                                                                            if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                              trampCall(@_eqv_QUMARK)
                                                                                            else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                          end                                                                                        ,
                                                                                      [
                                                                                          :"let"                                                                                          ,
                                                                                            begin
                                                                                                trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                              rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                            end
                                                                                      ]
                                                                                                   ))
                                                                                           )
                                                                              end
                                                                             ) then
                                                                                begin
                                                                                    delayCall( '_cons',  'cons',
                                                                                        begin
                                                                                          if @global_lisp_binding.has_key?('_cons') then
                                                                                            trampCall(@_cons)
                                                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                        end                                                                                      ,
                                                                                    [
                                                                                          begin
                                                                                              trampCall(__car)
                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1357"] + __e.backtrace ) ; raise __e
                                                                                          end                                                                                        ,
                                                                                          trampCall( self._cons_METHOD(  'cons',
                                                                                              begin
                                                                                                if @global_lisp_binding.has_key?('_cons') then
                                                                                                  trampCall(@_cons)
                                                                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                              end                                                                                            ,
                                                                                          [
                                                                                                trampCall( callProcedure(   'setup-let-args',
                                                                                                    begin
                                                                                                        trampCall(_setup_MIMARKlet_MIMARKargs)
                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1344"] + __e.backtrace ) ; raise __e
                                                                                                    end                                                                                                  ,
                                                                                                [
                                                                                                      trampCall( self._second_METHOD(  'second',
                                                                                                          begin
                                                                                                            if @global_lisp_binding.has_key?('_second') then
                                                                                                              trampCall(@_second)
                                                                                                            else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1358"] + __e.backtrace ) ; raise __e
                                                                                                          end                                                                                                        ,
                                                                                                      [
                                                                                                            begin
                                                                                                                trampCall(_sexp)
                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                            end
                                                                                                      ]
                                                                                                                   ))
                                                                                                ]
                                                                                                             ))                                                                                              ,
                                                                                                trampCall( callProcedure(   'setup-proc-body',
                                                                                                    begin
                                                                                                        trampCall(_setup_MIMARKproc_MIMARKbody)
                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1345"] + __e.backtrace ) ; raise __e
                                                                                                    end                                                                                                  ,
                                                                                                [
                                                                                                      trampCall( self._cddr_METHOD(  'cddr',
                                                                                                          begin
                                                                                                            if @global_lisp_binding.has_key?('_cddr') then
                                                                                                              trampCall(@_cddr)
                                                                                                            else raise NameError.new( "Error: undefined variable _cddr", "_cddr" ) end
                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1345"] + __e.backtrace ) ; raise __e
                                                                                                          end                                                                                                        ,
                                                                                                      [
                                                                                                            begin
                                                                                                                trampCall(_sexp)
                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                            end
                                                                                                      ]
                                                                                                                   ))
                                                                                                ]
                                                                                                             ))
                                                                                          ]
                                                                                                       ))
                                                                                    ]
                                                                                                 )
                                                                                end
                                                                            else
                                                                                if ( 
                                                                                  begin
                                                                                    ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20291| 
                                                                                        if ( 
                                                                                          begin
                                                                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20291)
                                                                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                          end
                                                                                         ) then
                                                                                            begin
                                                                                                trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20291)
                                                                                              rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                            end
                                                                                        else
                                                                                            begin
                                                                                              ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20292| 
                                                                                                  if ( 
                                                                                                    begin
                                                                                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20292)
                                                                                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                    end
                                                                                                   ) then
                                                                                                      begin
                                                                                                          trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20292)
                                                                                                        rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                      end
                                                                                                  else
                                                                                                    false
                                                                                                  end
                                                                                              } ; ___lambda.call(
                                                                                                    trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                                        begin
                                                                                                          if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                                            trampCall(@_eqv_QUMARK)
                                                                                                          else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                                        end                                                                                                      ,
                                                                                                    [
                                                                                                        :"/nendo/macroenv/letrec"                                                                                                        ,
                                                                                                          begin
                                                                                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                          end
                                                                                                    ]
                                                                                                                 ))
                                                                                                         )
                                                                                            end
                                                                                        end
                                                                                    } ; ___lambda.call(
                                                                                          trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                              begin
                                                                                                if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                                  trampCall(@_eqv_QUMARK)
                                                                                                else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                              end                                                                                            ,
                                                                                          [
                                                                                              :"letrec"                                                                                              ,
                                                                                                begin
                                                                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                end
                                                                                          ]
                                                                                                       ))
                                                                                               )
                                                                                  end
                                                                                 ) then
                                                                                    begin
                                                                                        delayCall( '_cons',  'cons',
                                                                                            begin
                                                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                                                trampCall(@_cons)
                                                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                            end                                                                                          ,
                                                                                        [
                                                                                              begin
                                                                                                  trampCall(__car)
                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1357"] + __e.backtrace ) ; raise __e
                                                                                              end                                                                                            ,
                                                                                              trampCall( self._cons_METHOD(  'cons',
                                                                                                  begin
                                                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                                                      trampCall(@_cons)
                                                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                  end                                                                                                ,
                                                                                              [
                                                                                                    trampCall( callProcedure(   'setup-let-args',
                                                                                                        begin
                                                                                                            trampCall(_setup_MIMARKlet_MIMARKargs)
                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1344"] + __e.backtrace ) ; raise __e
                                                                                                        end                                                                                                      ,
                                                                                                    [
                                                                                                          trampCall( self._second_METHOD(  'second',
                                                                                                              begin
                                                                                                                if @global_lisp_binding.has_key?('_second') then
                                                                                                                  trampCall(@_second)
                                                                                                                else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1358"] + __e.backtrace ) ; raise __e
                                                                                                              end                                                                                                            ,
                                                                                                          [
                                                                                                                begin
                                                                                                                    trampCall(_sexp)
                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                                end
                                                                                                          ]
                                                                                                                       ))
                                                                                                    ]
                                                                                                                 ))                                                                                                  ,
                                                                                                    trampCall( callProcedure(   'setup-proc-body',
                                                                                                        begin
                                                                                                            trampCall(_setup_MIMARKproc_MIMARKbody)
                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1345"] + __e.backtrace ) ; raise __e
                                                                                                        end                                                                                                      ,
                                                                                                    [
                                                                                                          trampCall( self._cddr_METHOD(  'cddr',
                                                                                                              begin
                                                                                                                if @global_lisp_binding.has_key?('_cddr') then
                                                                                                                  trampCall(@_cddr)
                                                                                                                else raise NameError.new( "Error: undefined variable _cddr", "_cddr" ) end
                                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1345"] + __e.backtrace ) ; raise __e
                                                                                                              end                                                                                                            ,
                                                                                                          [
                                                                                                                begin
                                                                                                                    trampCall(_sexp)
                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                                end
                                                                                                          ]
                                                                                                                       ))
                                                                                                    ]
                                                                                                                 ))
                                                                                              ]
                                                                                                           ))
                                                                                        ]
                                                                                                     )
                                                                                    end
                                                                                else
                                                                                    if ( 
                                                                                      begin
                                                                                        ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20293| 
                                                                                            if ( 
                                                                                              begin
                                                                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20293)
                                                                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                              end
                                                                                             ) then
                                                                                                begin
                                                                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20293)
                                                                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                end
                                                                                            else
                                                                                                begin
                                                                                                  ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20294| 
                                                                                                      if ( 
                                                                                                        begin
                                                                                                            trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20294)
                                                                                                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                        end
                                                                                                       ) then
                                                                                                          begin
                                                                                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20294)
                                                                                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                          end
                                                                                                      else
                                                                                                          begin
                                                                                                            ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20295| 
                                                                                                                if ( 
                                                                                                                  begin
                                                                                                                      trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20295)
                                                                                                                    rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                                  end
                                                                                                                 ) then
                                                                                                                    begin
                                                                                                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20295)
                                                                                                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                                    end
                                                                                                                else
                                                                                                                    begin
                                                                                                                      ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20296| 
                                                                                                                          if ( 
                                                                                                                            begin
                                                                                                                                trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20296)
                                                                                                                              rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                                            end
                                                                                                                           ) then
                                                                                                                              begin
                                                                                                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20296)
                                                                                                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                                              end
                                                                                                                          else
                                                                                                                            false
                                                                                                                          end
                                                                                                                      } ; ___lambda.call(
                                                                                                                            trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                                                                begin
                                                                                                                                  if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                                                                    trampCall(@_eqv_QUMARK)
                                                                                                                                  else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                                                                end                                                                                                                              ,
                                                                                                                            [
                                                                                                                                :"/nendo/macroenv/define-syntax"                                                                                                                                ,
                                                                                                                                  begin
                                                                                                                                      trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                                                                    rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                                                  end
                                                                                                                            ]
                                                                                                                                         ))
                                                                                                                                 )
                                                                                                                    end
                                                                                                                end
                                                                                                            } ; ___lambda.call(
                                                                                                                  trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                                                      begin
                                                                                                                        if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                                                          trampCall(@_eqv_QUMARK)
                                                                                                                        else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                                                      end                                                                                                                    ,
                                                                                                                  [
                                                                                                                      :"define-syntax"                                                                                                                      ,
                                                                                                                        begin
                                                                                                                            trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                                                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                                        end
                                                                                                                  ]
                                                                                                                               ))
                                                                                                                       )
                                                                                                          end
                                                                                                      end
                                                                                                  } ; ___lambda.call(
                                                                                                        trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                                            begin
                                                                                                              if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                                                trampCall(@_eqv_QUMARK)
                                                                                                              else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                                            end                                                                                                          ,
                                                                                                        [
                                                                                                            :"/nendo/macroenv/define"                                                                                                            ,
                                                                                                              begin
                                                                                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                              end
                                                                                                        ]
                                                                                                                     ))
                                                                                                             )
                                                                                                end
                                                                                            end
                                                                                        } ; ___lambda.call(
                                                                                              trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                                  begin
                                                                                                    if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                                      trampCall(@_eqv_QUMARK)
                                                                                                    else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                                  end                                                                                                ,
                                                                                              [
                                                                                                  :"define"                                                                                                  ,
                                                                                                    begin
                                                                                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                    end
                                                                                              ]
                                                                                                           ))
                                                                                                   )
                                                                                      end
                                                                                     ) then
                                                                                        begin
                                                                                            begin
                                                                                              ___lambda = lambda { |_val| 
                                                                                                  delayCall( '_cons',  'cons',
                                                                                                      begin
                                                                                                        if @global_lisp_binding.has_key?('_cons') then
                                                                                                          trampCall(@_cons)
                                                                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                      end                                                                                                    ,
                                                                                                  [
                                                                                                        begin
                                                                                                            trampCall(__car)
                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1357"] + __e.backtrace ) ; raise __e
                                                                                                        end                                                                                                      ,
                                                                                                        trampCall( self._cons_METHOD(  'cons',
                                                                                                            begin
                                                                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                                                                trampCall(@_cons)
                                                                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                            end                                                                                                          ,
                                                                                                        [
                                                                                                              trampCall( self._second_METHOD(  'second',
                                                                                                                  begin
                                                                                                                    if @global_lisp_binding.has_key?('_second') then
                                                                                                                      trampCall(@_second)
                                                                                                                    else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1358"] + __e.backtrace ) ; raise __e
                                                                                                                  end                                                                                                                ,
                                                                                                              [
                                                                                                                    begin
                                                                                                                        trampCall(_sexp)
                                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                                    end
                                                                                                              ]
                                                                                                                           ))                                                                                                            ,
                                                                                                              trampCall( self._cons_METHOD(  'cons',
                                                                                                                  begin
                                                                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                                                                      trampCall(@_cons)
                                                                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                                  end                                                                                                                ,
                                                                                                              [
                                                                                                                    if ( 
                                                                                                                      if ( 
                                                                                                                        trampCall( self._not_METHOD(  'not',
                                                                                                                            begin
                                                                                                                              if @global_lisp_binding.has_key?('_not') then
                                                                                                                                trampCall(@_not)
                                                                                                                              else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
                                                                                                                            end                                                                                                                          ,
                                                                                                                        [
                                                                                                                              trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                                                                                                  begin
                                                                                                                                    if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                                                                                                      trampCall(@_eq_QUMARK)
                                                                                                                                    else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1126"] + __e.backtrace ) ; raise __e
                                                                                                                                  end                                                                                                                                ,
                                                                                                                              [
                                                                                                                                  false                                                                                                                                  ,
                                                                                                                                    trampCall( self._list_QUMARK_METHOD(  'list?',
                                                                                                                                        begin
                                                                                                                                          if @global_lisp_binding.has_key?('_list_QUMARK') then
                                                                                                                                            trampCall(@_list_QUMARK)
                                                                                                                                          else raise NameError.new( "Error: undefined variable _list_QUMARK", "_list_QUMARK" ) end
                                                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1359"] + __e.backtrace ) ; raise __e
                                                                                                                                        end                                                                                                                                      ,
                                                                                                                                    [
                                                                                                                                          begin
                                                                                                                                              trampCall(_val)
                                                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1363"] + __e.backtrace ) ; raise __e
                                                                                                                                          end
                                                                                                                                    ]
                                                                                                                                                 ))
                                                                                                                              ]
                                                                                                                                           ))
                                                                                                                        ]
                                                                                                                                     ))
                                                                                                                       ) then
                                                                                                                          if ( 
                                                                                                                            trampCall( self._not_METHOD(  'not',
                                                                                                                                begin
                                                                                                                                  if @global_lisp_binding.has_key?('_not') then
                                                                                                                                    trampCall(@_not)
                                                                                                                                  else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
                                                                                                                                end                                                                                                                              ,
                                                                                                                            [
                                                                                                                                  trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                                                                                                      begin
                                                                                                                                        if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                                                                                                          trampCall(@_eq_QUMARK)
                                                                                                                                        else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1126"] + __e.backtrace ) ; raise __e
                                                                                                                                      end                                                                                                                                    ,
                                                                                                                                  [
                                                                                                                                      false                                                                                                                                      ,
                                                                                                                                        trampCall( self._not_METHOD(  'not',
                                                                                                                                            begin
                                                                                                                                              if @global_lisp_binding.has_key?('_not') then
                                                                                                                                                trampCall(@_not)
                                                                                                                                              else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
                                                                                                                                            end                                                                                                                                          ,
                                                                                                                                        [
                                                                                                                                              trampCall( self._null_QUMARK_METHOD(  'null?',
                                                                                                                                                  begin
                                                                                                                                                    if @global_lisp_binding.has_key?('_null_QUMARK') then
                                                                                                                                                      trampCall(@_null_QUMARK)
                                                                                                                                                    else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                                                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
                                                                                                                                                  end                                                                                                                                                ,
                                                                                                                                              [
                                                                                                                                                    begin
                                                                                                                                                        trampCall(_val)
                                                                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1363"] + __e.backtrace ) ; raise __e
                                                                                                                                                    end
                                                                                                                                              ]
                                                                                                                                                           ))
                                                                                                                                        ]
                                                                                                                                                     ))
                                                                                                                                  ]
                                                                                                                                               ))
                                                                                                                            ]
                                                                                                                                         ))
                                                                                                                           ) then
                                                                                                                              trampCall( callProcedure(   'reserved?',
                                                                                                                                  begin
                                                                                                                                      trampCall(_reserved_QUMARK)
                                                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1361"] + __e.backtrace ) ; raise __e
                                                                                                                                  end                                                                                                                                ,
                                                                                                                              [
                                                                                                                                    trampCall( self._car_METHOD(  'car',
                                                                                                                                        begin
                                                                                                                                          if @global_lisp_binding.has_key?('_car') then
                                                                                                                                            trampCall(@_car)
                                                                                                                                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1365"] + __e.backtrace ) ; raise __e
                                                                                                                                        end                                                                                                                                      ,
                                                                                                                                    [
                                                                                                                                          begin
                                                                                                                                              trampCall(_val)
                                                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1363"] + __e.backtrace ) ; raise __e
                                                                                                                                          end
                                                                                                                                    ]
                                                                                                                                                 ))
                                                                                                                              ]
                                                                                                                                           ))
                                                                                                                          else
                                                                                                                            false
                                                                                                                          end
                                                                                                                      else
                                                                                                                        false
                                                                                                                      end
                                                                                                                     ) then
                                                                                                                        trampCall( self._setup_MIMARKtailcall_MIMARKmark_METHOD(  'setup-tailcall-mark',
                                                                                                                            begin
                                                                                                                              if @global_lisp_binding.has_key?('_setup_MIMARKtailcall_MIMARKmark') then
                                                                                                                                trampCall(@_setup_MIMARKtailcall_MIMARKmark)
                                                                                                                              else raise NameError.new( "Error: undefined variable _setup_MIMARKtailcall_MIMARKmark", "_setup_MIMARKtailcall_MIMARKmark" ) end
                                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1362"] + __e.backtrace ) ; raise __e
                                                                                                                            end                                                                                                                          ,
                                                                                                                        [
                                                                                                                              begin
                                                                                                                                  trampCall(_val)
                                                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1363"] + __e.backtrace ) ; raise __e
                                                                                                                              end
                                                                                                                        ]
                                                                                                                                     ))
                                                                                                                    else
                                                                                                                        begin
                                                                                                                            trampCall(_val)
                                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1363"] + __e.backtrace ) ; raise __e
                                                                                                                        end
                                                                                                                    end                                                                                                                  ,
                                                                                                                  Cell.new()
                                                                                                              ]
                                                                                                                           ))
                                                                                                        ]
                                                                                                                     ))
                                                                                                  ]
                                                                                                               )
                                                                                              } ; ___lambda.call(
                                                                                                    trampCall( self._third_METHOD(  'third',
                                                                                                        begin
                                                                                                          if @global_lisp_binding.has_key?('_third') then
                                                                                                            trampCall(@_third)
                                                                                                          else raise NameError.new( "Error: undefined variable _third", "_third" ) end
                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1356"] + __e.backtrace ) ; raise __e
                                                                                                        end                                                                                                      ,
                                                                                                    [
                                                                                                          begin
                                                                                                              trampCall(_sexp)
                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                          end
                                                                                                    ]
                                                                                                                 ))
                                                                                                         )
                                                                                            end
                                                                                        end
                                                                                    else
                                                                                        if ( 
                                                                                          begin
                                                                                            ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20297| 
                                                                                                if ( 
                                                                                                  begin
                                                                                                      trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20297)
                                                                                                    rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                  end
                                                                                                 ) then
                                                                                                    begin
                                                                                                        trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20297)
                                                                                                      rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                    end
                                                                                                else
                                                                                                    begin
                                                                                                      ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20298| 
                                                                                                          if ( 
                                                                                                            begin
                                                                                                                trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20298)
                                                                                                              rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                            end
                                                                                                           ) then
                                                                                                              begin
                                                                                                                  trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20298)
                                                                                                                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                              end
                                                                                                          else
                                                                                                            false
                                                                                                          end
                                                                                                      } ; ___lambda.call(
                                                                                                            trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                                                begin
                                                                                                                  if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                                                    trampCall(@_eqv_QUMARK)
                                                                                                                  else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                                                end                                                                                                              ,
                                                                                                            [
                                                                                                                :"/nendo/macroenv/set!"                                                                                                                ,
                                                                                                                  begin
                                                                                                                      trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                                                    rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                                  end
                                                                                                            ]
                                                                                                                         ))
                                                                                                                 )
                                                                                                    end
                                                                                                end
                                                                                            } ; ___lambda.call(
                                                                                                  trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                                                                                      begin
                                                                                                        if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                                                                          trampCall(@_eqv_QUMARK)
                                                                                                        else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                                                                                      end                                                                                                    ,
                                                                                                  [
                                                                                                      :"set!"                                                                                                      ,
                                                                                                        begin
                                                                                                            trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20261)
                                                                                                          rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                                                                        end
                                                                                                  ]
                                                                                                               ))
                                                                                                       )
                                                                                          end
                                                                                         ) then
                                                                                            begin
                                                                                                begin
                                                                                                  ___lambda = lambda { |_val| 
                                                                                                      delayCall( '_cons',  'cons',
                                                                                                          begin
                                                                                                            if @global_lisp_binding.has_key?('_cons') then
                                                                                                              trampCall(@_cons)
                                                                                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                          end                                                                                                        ,
                                                                                                      [
                                                                                                            begin
                                                                                                                trampCall(__car)
                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1357"] + __e.backtrace ) ; raise __e
                                                                                                            end                                                                                                          ,
                                                                                                            trampCall( self._cons_METHOD(  'cons',
                                                                                                                begin
                                                                                                                  if @global_lisp_binding.has_key?('_cons') then
                                                                                                                    trampCall(@_cons)
                                                                                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                                end                                                                                                              ,
                                                                                                            [
                                                                                                                  trampCall( self._second_METHOD(  'second',
                                                                                                                      begin
                                                                                                                        if @global_lisp_binding.has_key?('_second') then
                                                                                                                          trampCall(@_second)
                                                                                                                        else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1358"] + __e.backtrace ) ; raise __e
                                                                                                                      end                                                                                                                    ,
                                                                                                                  [
                                                                                                                        begin
                                                                                                                            trampCall(_sexp)
                                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                                        end
                                                                                                                  ]
                                                                                                                               ))                                                                                                                ,
                                                                                                                  trampCall( self._cons_METHOD(  'cons',
                                                                                                                      begin
                                                                                                                        if @global_lisp_binding.has_key?('_cons') then
                                                                                                                          trampCall(@_cons)
                                                                                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                                      end                                                                                                                    ,
                                                                                                                  [
                                                                                                                        if ( 
                                                                                                                          if ( 
                                                                                                                            trampCall( self._not_METHOD(  'not',
                                                                                                                                begin
                                                                                                                                  if @global_lisp_binding.has_key?('_not') then
                                                                                                                                    trampCall(@_not)
                                                                                                                                  else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
                                                                                                                                end                                                                                                                              ,
                                                                                                                            [
                                                                                                                                  trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                                                                                                      begin
                                                                                                                                        if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                                                                                                          trampCall(@_eq_QUMARK)
                                                                                                                                        else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1126"] + __e.backtrace ) ; raise __e
                                                                                                                                      end                                                                                                                                    ,
                                                                                                                                  [
                                                                                                                                      false                                                                                                                                      ,
                                                                                                                                        trampCall( self._list_QUMARK_METHOD(  'list?',
                                                                                                                                            begin
                                                                                                                                              if @global_lisp_binding.has_key?('_list_QUMARK') then
                                                                                                                                                trampCall(@_list_QUMARK)
                                                                                                                                              else raise NameError.new( "Error: undefined variable _list_QUMARK", "_list_QUMARK" ) end
                                                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1359"] + __e.backtrace ) ; raise __e
                                                                                                                                            end                                                                                                                                          ,
                                                                                                                                        [
                                                                                                                                              begin
                                                                                                                                                  trampCall(_val)
                                                                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1363"] + __e.backtrace ) ; raise __e
                                                                                                                                              end
                                                                                                                                        ]
                                                                                                                                                     ))
                                                                                                                                  ]
                                                                                                                                               ))
                                                                                                                            ]
                                                                                                                                         ))
                                                                                                                           ) then
                                                                                                                              if ( 
                                                                                                                                trampCall( self._not_METHOD(  'not',
                                                                                                                                    begin
                                                                                                                                      if @global_lisp_binding.has_key?('_not') then
                                                                                                                                        trampCall(@_not)
                                                                                                                                      else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
                                                                                                                                    end                                                                                                                                  ,
                                                                                                                                [
                                                                                                                                      trampCall( self._eq_QUMARK_METHOD(  'eq?',
                                                                                                                                          begin
                                                                                                                                            if @global_lisp_binding.has_key?('_eq_QUMARK') then
                                                                                                                                              trampCall(@_eq_QUMARK)
                                                                                                                                            else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                                                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1126"] + __e.backtrace ) ; raise __e
                                                                                                                                          end                                                                                                                                        ,
                                                                                                                                      [
                                                                                                                                          false                                                                                                                                          ,
                                                                                                                                            trampCall( self._not_METHOD(  'not',
                                                                                                                                                begin
                                                                                                                                                  if @global_lisp_binding.has_key?('_not') then
                                                                                                                                                    trampCall(@_not)
                                                                                                                                                  else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                                                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
                                                                                                                                                end                                                                                                                                              ,
                                                                                                                                            [
                                                                                                                                                  trampCall( self._null_QUMARK_METHOD(  'null?',
                                                                                                                                                      begin
                                                                                                                                                        if @global_lisp_binding.has_key?('_null_QUMARK') then
                                                                                                                                                          trampCall(@_null_QUMARK)
                                                                                                                                                        else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                                                                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
                                                                                                                                                      end                                                                                                                                                    ,
                                                                                                                                                  [
                                                                                                                                                        begin
                                                                                                                                                            trampCall(_val)
                                                                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1363"] + __e.backtrace ) ; raise __e
                                                                                                                                                        end
                                                                                                                                                  ]
                                                                                                                                                               ))
                                                                                                                                            ]
                                                                                                                                                         ))
                                                                                                                                      ]
                                                                                                                                                   ))
                                                                                                                                ]
                                                                                                                                             ))
                                                                                                                               ) then
                                                                                                                                  trampCall( callProcedure(   'reserved?',
                                                                                                                                      begin
                                                                                                                                          trampCall(_reserved_QUMARK)
                                                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1361"] + __e.backtrace ) ; raise __e
                                                                                                                                      end                                                                                                                                    ,
                                                                                                                                  [
                                                                                                                                        trampCall( self._car_METHOD(  'car',
                                                                                                                                            begin
                                                                                                                                              if @global_lisp_binding.has_key?('_car') then
                                                                                                                                                trampCall(@_car)
                                                                                                                                              else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1365"] + __e.backtrace ) ; raise __e
                                                                                                                                            end                                                                                                                                          ,
                                                                                                                                        [
                                                                                                                                              begin
                                                                                                                                                  trampCall(_val)
                                                                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1363"] + __e.backtrace ) ; raise __e
                                                                                                                                              end
                                                                                                                                        ]
                                                                                                                                                     ))
                                                                                                                                  ]
                                                                                                                                               ))
                                                                                                                              else
                                                                                                                                false
                                                                                                                              end
                                                                                                                          else
                                                                                                                            false
                                                                                                                          end
                                                                                                                         ) then
                                                                                                                            trampCall( self._setup_MIMARKtailcall_MIMARKmark_METHOD(  'setup-tailcall-mark',
                                                                                                                                begin
                                                                                                                                  if @global_lisp_binding.has_key?('_setup_MIMARKtailcall_MIMARKmark') then
                                                                                                                                    trampCall(@_setup_MIMARKtailcall_MIMARKmark)
                                                                                                                                  else raise NameError.new( "Error: undefined variable _setup_MIMARKtailcall_MIMARKmark", "_setup_MIMARKtailcall_MIMARKmark" ) end
                                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1362"] + __e.backtrace ) ; raise __e
                                                                                                                                end                                                                                                                              ,
                                                                                                                            [
                                                                                                                                  begin
                                                                                                                                      trampCall(_val)
                                                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1363"] + __e.backtrace ) ; raise __e
                                                                                                                                  end
                                                                                                                            ]
                                                                                                                                         ))
                                                                                                                        else
                                                                                                                            begin
                                                                                                                                trampCall(_val)
                                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1363"] + __e.backtrace ) ; raise __e
                                                                                                                            end
                                                                                                                        end                                                                                                                      ,
                                                                                                                      Cell.new()
                                                                                                                  ]
                                                                                                                               ))
                                                                                                            ]
                                                                                                                         ))
                                                                                                      ]
                                                                                                                   )
                                                                                                  } ; ___lambda.call(
                                                                                                        trampCall( self._third_METHOD(  'third',
                                                                                                            begin
                                                                                                              if @global_lisp_binding.has_key?('_third') then
                                                                                                                trampCall(@_third)
                                                                                                              else raise NameError.new( "Error: undefined variable _third", "_third" ) end
                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1356"] + __e.backtrace ) ; raise __e
                                                                                                            end                                                                                                          ,
                                                                                                        [
                                                                                                              begin
                                                                                                                  trampCall(_sexp)
                                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                              end
                                                                                                        ]
                                                                                                                     ))
                                                                                                             )
                                                                                                end
                                                                                            end
                                                                                        else
                                                                                            if ( 
                                                                                            true
                                                                                             ) then
                                                                                                begin
                                                                                                    if ( 
                                                                                                      trampCall( self._symbol_QUMARK_METHOD(  'symbol?',
                                                                                                          begin
                                                                                                            if @global_lisp_binding.has_key?('_symbol_QUMARK') then
                                                                                                              trampCall(@_symbol_QUMARK)
                                                                                                            else raise NameError.new( "Error: undefined variable _symbol_QUMARK", "_symbol_QUMARK" ) end
                                                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1365"] + __e.backtrace ) ; raise __e
                                                                                                          end                                                                                                        ,
                                                                                                      [
                                                                                                            trampCall( self._car_METHOD(  'car',
                                                                                                                begin
                                                                                                                  if @global_lisp_binding.has_key?('_car') then
                                                                                                                    trampCall(@_car)
                                                                                                                  else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1365"] + __e.backtrace ) ; raise __e
                                                                                                                end                                                                                                              ,
                                                                                                            [
                                                                                                                  begin
                                                                                                                      trampCall(_sexp)
                                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                                  end
                                                                                                            ]
                                                                                                                         ))
                                                                                                      ]
                                                                                                                   ))
                                                                                                     ) then
                                                                                                        delayCall( '_cons',  'cons',
                                                                                                            begin
                                                                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                                                                trampCall(@_cons)
                                                                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                            end                                                                                                          ,
                                                                                                        [
                                                                                                            :"%tailcall"                                                                                                            ,
                                                                                                              trampCall( self._cons_METHOD(  'cons',
                                                                                                                  begin
                                                                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                                                                      trampCall(@_cons)
                                                                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1296"] + __e.backtrace ) ; raise __e
                                                                                                                  end                                                                                                                ,
                                                                                                              [
                                                                                                                    begin
                                                                                                                        trampCall(_sexp)
                                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                                    end                                                                                                                  ,
                                                                                                                  Cell.new()
                                                                                                              ]
                                                                                                                           ))
                                                                                                        ]
                                                                                                                     )
                                                                                                    else
                                                                                                        begin
                                                                                                            trampCall(_sexp)
                                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                                                                        end
                                                                                                    end
                                                                                                end
                                                                                            else
                                                                                                Cell.new()
                                                                                            end
                                                                                        end
                                                                                    end
                                                                                end
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            } ; ___lambda.call(
                                                  begin
                                                      trampCall(__car)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1357"] + __e.backtrace ) ; raise __e
                                                  end
                                                       )
                                          end
                                      } ; ___lambda.call(
                                            trampCall( self._car_METHOD(  'car',
                                                begin
                                                  if @global_lisp_binding.has_key?('_car') then
                                                    trampCall(@_car)
                                                  else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1365"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                  begin
                                                      trampCall(_sexp)
                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                                  end
                                            ]
                                                         ))
                                                 )
                                    end
                                end
                            else
                                if ( 
                                true
                                 ) then
                                    begin
                                        begin
                                            trampCall(_sexp)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1369"] + __e.backtrace ) ; raise __e
                                        end
                                    end
                                else
                                    Cell.new()
                                end
                            end
                        end
                    end
                } ; ___lambda.call(
                nil,nil,nil,nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self.__PAMARKcompile_MIMARKphase_MIMARKfunctions_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['__PAMARKcompile_MIMARKphase_MIMARKfunctions'] = self.method( :__PAMARKcompile_MIMARKphase_MIMARKfunctions_METHOD )
    @__PAMARKcompile_MIMARKphase_MIMARKfunctions = 
    trampCall(
          trampCall( self._list_METHOD(  'list',
              begin
                if @global_lisp_binding.has_key?('_list') then
                  trampCall(@_list)
                else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1374"] + __e.backtrace ) ; raise __e
              end            ,
          [
                begin
                  if @global_lisp_binding.has_key?('_setup_MIMARKtailcall_MIMARKmark') then
                    trampCall(@_setup_MIMARKtailcall_MIMARKmark)
                  else raise NameError.new( "Error: undefined variable _setup_MIMARKtailcall_MIMARKmark", "_setup_MIMARKtailcall_MIMARKmark" ) end
                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1375"] + __e.backtrace ) ; raise __e
                end
          ]
                       ))
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._make_MIMARKsyntactic_MIMARKclosure_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_make_MIMARKsyntactic_MIMARKclosure'] = self.method( :_make_MIMARKsyntactic_MIMARKclosure_METHOD )
    @_make_MIMARKsyntactic_MIMARKclosure = 
    trampCall(
          Proc.new { |_mac_MIMARKenv,_use_MIMARKenv,_identifier| 
              begin
                ___lambda = lambda { |_id_MIMARKstr| 
                    begin
                      ___lambda = lambda { |_alias_MIMARKdata| 
                          if ( 
                            begin
                                trampCall(_alias_MIMARKdata)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1385"] + __e.backtrace ) ; raise __e
                            end
                           ) then
                              delayCall( '_string_MIMARK_GTMARKsymbol',  'string->symbol',
                                  begin
                                    if @global_lisp_binding.has_key?('_string_MIMARK_GTMARKsymbol') then
                                      trampCall(@_string_MIMARK_GTMARKsymbol)
                                    else raise NameError.new( "Error: undefined variable _string_MIMARK_GTMARKsymbol", "_string_MIMARK_GTMARKsymbol" ) end
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1385"] + __e.backtrace ) ; raise __e
                                  end                                ,
                              [
                                    trampCall( self._car_METHOD(  'car',
                                        begin
                                          if @global_lisp_binding.has_key?('_car') then
                                            trampCall(@_car)
                                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1385"] + __e.backtrace ) ; raise __e
                                        end                                      ,
                                    [
                                          begin
                                              trampCall(_alias_MIMARKdata)
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1385"] + __e.backtrace ) ; raise __e
                                          end
                                    ]
                                                 ))
                              ]
                                           )
                          else
                              begin
                                  trampCall(_identifier)
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1386"] + __e.backtrace ) ; raise __e
                              end
                          end
                      } ; ___lambda.call(
                            trampCall( self._assq_MIMARKref_METHOD(  'assq-ref',
                                begin
                                  if @global_lisp_binding.has_key?('_assq_MIMARKref') then
                                    trampCall(@_assq_MIMARKref)
                                  else raise NameError.new( "Error: undefined variable _assq_MIMARKref", "_assq_MIMARKref" ) end
                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1383"] + __e.backtrace ) ; raise __e
                                end                              ,
                            [
                                  begin
                                      trampCall(_id_MIMARKstr)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1383"] + __e.backtrace ) ; raise __e
                                  end                                ,
                                  begin
                                      trampCall(_mac_MIMARKenv)
                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1383"] + __e.backtrace ) ; raise __e
                                  end
                            ]
                                         ))
                                 )
                    end
                } ; ___lambda.call(
                      trampCall( self._symbol_MIMARK_GTMARKstring_METHOD(  'symbol->string',
                          begin
                            if @global_lisp_binding.has_key?('_symbol_MIMARK_GTMARKstring') then
                              trampCall(@_symbol_MIMARK_GTMARKstring)
                            else raise NameError.new( "Error: undefined variable _symbol_MIMARK_GTMARKstring", "_symbol_MIMARK_GTMARKstring" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1382"] + __e.backtrace ) ; raise __e
                          end                        ,
                      [
                            begin
                                trampCall(_identifier)
                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1386"] + __e.backtrace ) ; raise __e
                            end
                      ]
                                   ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._identifier_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_identifier_QUMARK'] = self.method( :_identifier_QUMARK_METHOD )
    @_identifier_QUMARK = 
    trampCall(
          Proc.new { |_x| 
              delayCall( '_symbol_QUMARK',  'symbol?',
                  begin
                    if @global_lisp_binding.has_key?('_symbol_QUMARK') then
                      trampCall(@_symbol_QUMARK)
                    else raise NameError.new( "Error: undefined variable _symbol_QUMARK", "_symbol_QUMARK" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1389"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(_x)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1389"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._identifier_EQMARK_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_identifier_EQMARK_QUMARK'] = self.method( :_identifier_EQMARK_QUMARK_METHOD )
    @_identifier_EQMARK_QUMARK = 
    trampCall(
          Proc.new { |_use_MIMARKenv_MIMARKx,_x,_use_MIMARKenv_MIMARKy,_y| 
              delayCall( '_eq_QUMARK',  'eq?',
                  begin
                    if @global_lisp_binding.has_key?('_eq_QUMARK') then
                      trampCall(@_eq_QUMARK)
                    else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1392"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    begin
                        trampCall(_x)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1392"] + __e.backtrace ) ; raise __e
                    end                  ,
                    begin
                        trampCall(_y)
                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1392"] + __e.backtrace ) ; raise __e
                    end
              ]
                           )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self.__PAMARKdefine_MIMARKrenamed_MIMARKsymbols_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['__PAMARKdefine_MIMARKrenamed_MIMARKsymbols'] = self.method( :__PAMARKdefine_MIMARKrenamed_MIMARKsymbols_METHOD )
    @__PAMARKdefine_MIMARKrenamed_MIMARKsymbols = 
    trampCall(
          LispMacro.new { |*__rest__| _lst = __rest__[0] ;  
              begin
                ___lambda = lambda { |_define_MIMARKiter| 
                    _define_MIMARKiter                     = 
                      Proc.new { |__lst| 
                          begin
                            ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20303| 
                                if ( 
                                  begin
                                    ___lambda = lambda { |___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20306| 
                                        if ( 
                                          begin
                                              trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20306)
                                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                          end
                                         ) then
                                            begin
                                                trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20306)
                                              rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                            end
                                        else
                                          false
                                        end
                                    } ; ___lambda.call(
                                          trampCall( self._eqv_QUMARK_METHOD(  'eqv?',
                                              begin
                                                if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                                                  trampCall(@_eqv_QUMARK)
                                                else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
                                              end                                            ,
                                          [
                                              0                                              ,
                                                begin
                                                    trampCall(___gensym__a6500e12401f98f446352dd5341558873f6aaa73_20303)
                                                  rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                                                end
                                          ]
                                                       ))
                                               )
                                  end
                                 ) then
                                    begin
                                      Cell.new()
                                    end
                                else
                                    if ( 
                                    true
                                     ) then
                                        begin
                                            begin
                                              ___lambda = lambda { |__to,__from| 
                                                  trampCall( self._cons_METHOD(  'cons',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cons') then
                                                          trampCall(@_cons)
                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        trampCall( self._cons_METHOD(  'cons',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                trampCall(@_cons)
                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                            :"define"                                                            ,
                                                              trampCall( self._cons_METHOD(  'cons',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                      trampCall(@_cons)
                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                    begin
                                                                        trampCall(__to)
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1419"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                    trampCall( self._cons_METHOD(  'cons',
                                                                        begin
                                                                          if @global_lisp_binding.has_key?('_cons') then
                                                                            trampCall(@_cons)
                                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          begin
                                                                              trampCall(__from)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                        Cell.new()
                                                                    ]
                                                                                 ))
                                                              ]
                                                                           ))
                                                        ]
                                                                     ))                                                      ,
                                                        trampCall( callProcedure(   'define-iter',
                                                            begin
                                                                trampCall(_define_MIMARKiter)
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1420"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                              trampCall( self._cdr_METHOD(  'cdr',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_cdr') then
                                                                      trampCall(@_cdr)
                                                                    else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1409"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                    begin
                                                                        trampCall(__lst)
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1409"] + __e.backtrace ) ; raise __e
                                                                    end
                                                              ]
                                                                           ))
                                                        ]
                                                                     ))
                                                  ]
                                                               ))
                                              } ; ___lambda.call(
                                                    trampCall( self._string_MIMARK_GTMARKsymbol_METHOD(  'string->symbol',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_string_MIMARK_GTMARKsymbol') then
                                                            trampCall(@_string_MIMARK_GTMARKsymbol)
                                                          else raise NameError.new( "Error: undefined variable _string_MIMARK_GTMARKsymbol", "_string_MIMARK_GTMARKsymbol" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1405"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          trampCall( self.__PLMARK_METHOD(  '+',
                                                              begin
                                                                if @global_lisp_binding.has_key?('__PLMARK') then
                                                                  trampCall(@__PLMARK)
                                                                else raise NameError.new( "Error: undefined variable __PLMARK", "__PLMARK" ) end
                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1406"] + __e.backtrace ) ; raise __e
                                                              end                                                            ,
                                                          [
                                                              "/nendo/macroenv/"                                                              ,
                                                                trampCall( self._symbol_MIMARK_GTMARKstring_METHOD(  'symbol->string',
                                                                    begin
                                                                      if @global_lisp_binding.has_key?('_symbol_MIMARK_GTMARKstring') then
                                                                        trampCall(@_symbol_MIMARK_GTMARKstring)
                                                                      else raise NameError.new( "Error: undefined variable _symbol_MIMARK_GTMARKstring", "_symbol_MIMARK_GTMARKstring" ) end
                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1418"] + __e.backtrace ) ; raise __e
                                                                    end                                                                  ,
                                                                [
                                                                      trampCall( self._car_METHOD(  'car',
                                                                          begin
                                                                            if @global_lisp_binding.has_key?('_car') then
                                                                              trampCall(@_car)
                                                                            else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1407"] + __e.backtrace ) ; raise __e
                                                                          end                                                                        ,
                                                                      [
                                                                            begin
                                                                                trampCall(__lst)
                                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1409"] + __e.backtrace ) ; raise __e
                                                                            end
                                                                      ]
                                                                                   ))
                                                                ]
                                                                             ))
                                                          ]
                                                                       ))
                                                    ]
                                                                 ))                                                  ,
                                                    trampCall( self._car_METHOD(  'car',
                                                        begin
                                                          if @global_lisp_binding.has_key?('_car') then
                                                            trampCall(@_car)
                                                          else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1407"] + __e.backtrace ) ; raise __e
                                                        end                                                      ,
                                                    [
                                                          begin
                                                              trampCall(__lst)
                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1409"] + __e.backtrace ) ; raise __e
                                                          end
                                                    ]
                                                                 ))
                                                         )
                                            end
                                        end
                                    else
                                        Cell.new()
                                    end
                                end
                            } ; ___lambda.call(
                                  trampCall( self._length_METHOD(  'length',
                                      begin
                                        if @global_lisp_binding.has_key?('_length') then
                                          trampCall(@_length)
                                        else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1401"] + __e.backtrace ) ; raise __e
                                      end                                    ,
                                  [
                                        begin
                                            trampCall(__lst)
                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1409"] + __e.backtrace ) ; raise __e
                                        end
                                  ]
                                               ))
                                       )
                          end
                      }
                    trampCall( self._cons_METHOD(  'cons',
                        begin
                          if @global_lisp_binding.has_key?('_cons') then
                            trampCall(@_cons)
                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        :"begin"                        ,
                          trampCall( self._append_METHOD(  'append',
                              begin
                                if @global_lisp_binding.has_key?('_append') then
                                  trampCall(@_append)
                                else raise NameError.new( "Error: undefined variable _append", "_append" ) end
                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1252"] + __e.backtrace ) ; raise __e
                              end                            ,
                          [
                                trampCall( callProcedure(   'define-iter',
                                    begin
                                        trampCall(_define_MIMARKiter)
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1420"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      begin
                                          trampCall(_lst)
                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1420"] + __e.backtrace ) ; raise __e
                                      end
                                ]
                                             ))                              ,
                                trampCall( self._cons_METHOD(  'cons',
                                    begin
                                      if @global_lisp_binding.has_key?('_cons') then
                                        trampCall(@_cons)
                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
                                    end                                  ,
                                [
                                      trampCall( self._cons_METHOD(  'cons',
                                          begin
                                            if @global_lisp_binding.has_key?('_cons') then
                                              trampCall(@_cons)
                                            else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
                                          end                                        ,
                                      [
                                          :"define"                                          ,
                                            trampCall( self._cons_METHOD(  'cons',
                                                begin
                                                  if @global_lisp_binding.has_key?('_cons') then
                                                    trampCall(@_cons)
                                                  else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
                                                end                                              ,
                                            [
                                                :"%macro-env-snapshot"                                                ,
                                                  trampCall( self._cons_METHOD(  'cons',
                                                      begin
                                                        if @global_lisp_binding.has_key?('_cons') then
                                                          trampCall(@_cons)
                                                        else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
                                                      end                                                    ,
                                                  [
                                                        trampCall( self._cons_METHOD(  'cons',
                                                            begin
                                                              if @global_lisp_binding.has_key?('_cons') then
                                                                trampCall(@_cons)
                                                              else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                              rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
                                                            end                                                          ,
                                                        [
                                                            :"list"                                                            ,
                                                              trampCall( self._map_METHOD(  'map',
                                                                  begin
                                                                    if @global_lisp_binding.has_key?('_map') then
                                                                      trampCall(@_map)
                                                                    else raise NameError.new( "Error: undefined variable _map", "_map" ) end
                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1413"] + __e.backtrace ) ; raise __e
                                                                  end                                                                ,
                                                              [
                                                                    Proc.new { |_x| 
                                                                        begin
                                                                          ___lambda = lambda { |__to,__from| 
                                                                              trampCall( self._cons_METHOD(  'cons',
                                                                                  begin
                                                                                    if @global_lisp_binding.has_key?('_cons') then
                                                                                      trampCall(@_cons)
                                                                                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
                                                                                  end                                                                                ,
                                                                              [
                                                                                  :"list"                                                                                  ,
                                                                                    trampCall( self._cons_METHOD(  'cons',
                                                                                        begin
                                                                                          if @global_lisp_binding.has_key?('_cons') then
                                                                                            trampCall(@_cons)
                                                                                          else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
                                                                                        end                                                                                      ,
                                                                                    [
                                                                                          trampCall( self._symbol_MIMARK_GTMARKstring_METHOD(  'symbol->string',
                                                                                              begin
                                                                                                if @global_lisp_binding.has_key?('_symbol_MIMARK_GTMARKstring') then
                                                                                                  trampCall(@_symbol_MIMARK_GTMARKstring)
                                                                                                else raise NameError.new( "Error: undefined variable _symbol_MIMARK_GTMARKstring", "_symbol_MIMARK_GTMARKstring" ) end
                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1418"] + __e.backtrace ) ; raise __e
                                                                                              end                                                                                            ,
                                                                                          [
                                                                                                begin
                                                                                                    trampCall(__from)
                                                                                                  rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                                                                                                end
                                                                                          ]
                                                                                                       ))                                                                                        ,
                                                                                          trampCall( self._cons_METHOD(  'cons',
                                                                                              begin
                                                                                                if @global_lisp_binding.has_key?('_cons') then
                                                                                                  trampCall(@_cons)
                                                                                                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
                                                                                              end                                                                                            ,
                                                                                          [
                                                                                                trampCall( self._symbol_MIMARK_GTMARKstring_METHOD(  'symbol->string',
                                                                                                    begin
                                                                                                      if @global_lisp_binding.has_key?('_symbol_MIMARK_GTMARKstring') then
                                                                                                        trampCall(@_symbol_MIMARK_GTMARKstring)
                                                                                                      else raise NameError.new( "Error: undefined variable _symbol_MIMARK_GTMARKstring", "_symbol_MIMARK_GTMARKstring" ) end
                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1418"] + __e.backtrace ) ; raise __e
                                                                                                    end                                                                                                  ,
                                                                                                [
                                                                                                      begin
                                                                                                          trampCall(__to)
                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1419"] + __e.backtrace ) ; raise __e
                                                                                                      end
                                                                                                ]
                                                                                                             ))                                                                                              ,
                                                                                                trampCall( self._cons_METHOD(  'cons',
                                                                                                    begin
                                                                                                      if @global_lisp_binding.has_key?('_cons') then
                                                                                                        trampCall(@_cons)
                                                                                                      else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
                                                                                                    end                                                                                                  ,
                                                                                                [
                                                                                                      begin
                                                                                                          trampCall(__to)
                                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1419"] + __e.backtrace ) ; raise __e
                                                                                                      end                                                                                                    ,
                                                                                                    Cell.new()
                                                                                                ]
                                                                                                             ))
                                                                                          ]
                                                                                                       ))
                                                                                    ]
                                                                                                 ))
                                                                              ]
                                                                                           ))
                                                                          } ; ___lambda.call(
                                                                                trampCall( self._second_METHOD(  'second',
                                                                                    begin
                                                                                      if @global_lisp_binding.has_key?('_second') then
                                                                                        trampCall(@_second)
                                                                                      else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1415"] + __e.backtrace ) ; raise __e
                                                                                    end                                                                                  ,
                                                                                [
                                                                                      begin
                                                                                          trampCall(_x)
                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1416"] + __e.backtrace ) ; raise __e
                                                                                      end
                                                                                ]
                                                                                             ))                                                                              ,
                                                                                trampCall( self._third_METHOD(  'third',
                                                                                    begin
                                                                                      if @global_lisp_binding.has_key?('_third') then
                                                                                        trampCall(@_third)
                                                                                      else raise NameError.new( "Error: undefined variable _third", "_third" ) end
                                                                                      rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1416"] + __e.backtrace ) ; raise __e
                                                                                    end                                                                                  ,
                                                                                [
                                                                                      begin
                                                                                          trampCall(_x)
                                                                                        rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1416"] + __e.backtrace ) ; raise __e
                                                                                      end
                                                                                ]
                                                                                             ))
                                                                                     )
                                                                        end
                                                                    }                                                                  ,
                                                                    trampCall( callProcedure(   'define-iter',
                                                                        begin
                                                                            trampCall(_define_MIMARKiter)
                                                                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1420"] + __e.backtrace ) ; raise __e
                                                                        end                                                                      ,
                                                                    [
                                                                          begin
                                                                              trampCall(_lst)
                                                                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1420"] + __e.backtrace ) ; raise __e
                                                                          end
                                                                    ]
                                                                                 ))
                                                              ]
                                                                           ))
                                                        ]
                                                                     ))                                                      ,
                                                      Cell.new()
                                                  ]
                                                               ))
                                            ]
                                                         ))
                                      ]
                                                   ))                                    ,
                                    Cell.new()
                                ]
                                             ))
                          ]
                                       ))
                    ]
                                 ))
                } ; ___lambda.call(
                nil
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      def self._define_MIMARKall_MIMARKrenamed_MIMARKsymbols_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_define_MIMARKall_MIMARKrenamed_MIMARKsymbols'] = self.method( :_define_MIMARKall_MIMARKrenamed_MIMARKsymbols_METHOD )
    @_define_MIMARKall_MIMARKrenamed_MIMARKsymbols = 
    trampCall(
          LispMacro.new { || 
              trampCall( self._cons_METHOD(  'cons',
                  begin
                    if @global_lisp_binding.has_key?('_cons') then
                      trampCall(@_cons)
                    else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                  :"%define-renamed-symbols"                  ,
                    trampCall( self._global_MIMARKvariables_METHOD(  'global-variables',
                        begin
                          if @global_lisp_binding.has_key?('_global_MIMARKvariables') then
                            trampCall(@_global_MIMARKvariables)
                          else raise NameError.new( "Error: undefined variable _global_MIMARKvariables", "_global_MIMARKvariables" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1424"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                    ]
                                 ))
              ]
                           ))
          }
    )
  end
 )
#--------------------

trampCall( 
  begin
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKgensym_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKgensym'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKgensym_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKgensym = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_gensym') then
                  trampCall(@_gensym)
                else raise NameError.new( "Error: undefined variable _gensym", "_gensym" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:948"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKload_MIMARKcompiled_MIMARKcode_MIMARKfrom_MIMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKload_MIMARKcompiled_MIMARKcode_MIMARKfrom_MIMARKstring'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKload_MIMARKcompiled_MIMARKcode_MIMARKfrom_MIMARKstring_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKload_MIMARKcompiled_MIMARKcode_MIMARKfrom_MIMARKstring = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_load_MIMARKcompiled_MIMARKcode_MIMARKfrom_MIMARKstring') then
                  trampCall(@_load_MIMARKcompiled_MIMARKcode_MIMARKfrom_MIMARKstring)
                else raise NameError.new( "Error: undefined variable _load_MIMARKcompiled_MIMARKcode_MIMARKfrom_MIMARKstring", "_load_MIMARKcompiled_MIMARKcode_MIMARKfrom_MIMARKstring" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKclean_MIMARKcompiled_MIMARKcode_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKclean_MIMARKcompiled_MIMARKcode'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKclean_MIMARKcompiled_MIMARKcode_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKclean_MIMARKcompiled_MIMARKcode = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_clean_MIMARKcompiled_MIMARKcode') then
                  trampCall(@_clean_MIMARKcompiled_MIMARKcode)
                else raise NameError.new( "Error: undefined variable _clean_MIMARKcompiled_MIMARKcode", "_clean_MIMARKcompiled_MIMARKcode" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1215"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKcompiled_MIMARKcode_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKcompiled_MIMARKcode'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKcompiled_MIMARKcode_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKcompiled_MIMARKcode = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_get_MIMARKcompiled_MIMARKcode') then
                  trampCall(@_get_MIMARKcompiled_MIMARKcode)
                else raise NameError.new( "Error: undefined variable _get_MIMARKcompiled_MIMARKcode", "_get_MIMARKcompiled_MIMARKcode" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1180"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKeval_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKeval'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKeval_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKeval = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_eval') then
                  trampCall(@_eval)
                else raise NameError.new( "Error: undefined variable _eval", "_eval" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:285"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKidebug_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKidebug'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKidebug_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKidebug = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_enable_MIMARKidebug') then
                  trampCall(@_enable_MIMARKidebug)
                else raise NameError.new( "Error: undefined variable _enable_MIMARKidebug", "_enable_MIMARKidebug" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKidebug_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKidebug'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKidebug_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKidebug = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_disable_MIMARKidebug') then
                  trampCall(@_disable_MIMARKidebug)
                else raise NameError.new( "Error: undefined variable _disable_MIMARKidebug", "_disable_MIMARKidebug" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKtrace_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKtrace'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKtrace_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKtrace = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_enable_MIMARKtrace') then
                  trampCall(@_enable_MIMARKtrace)
                else raise NameError.new( "Error: undefined variable _enable_MIMARKtrace", "_enable_MIMARKtrace" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKtrace_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKtrace'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKtrace_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKtrace = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_disable_MIMARKtrace') then
                  trampCall(@_disable_MIMARKtrace)
                else raise NameError.new( "Error: undefined variable _disable_MIMARKtrace", "_disable_MIMARKtrace" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKoptimize_MIMARKlevel_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKoptimize_MIMARKlevel'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKoptimize_MIMARKlevel_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKoptimize_MIMARKlevel = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_set_MIMARKoptimize_MIMARKlevel') then
                  trampCall(@_set_MIMARKoptimize_MIMARKlevel)
                else raise NameError.new( "Error: undefined variable _set_MIMARKoptimize_MIMARKlevel", "_set_MIMARKoptimize_MIMARKlevel" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptimize_MIMARKlevel_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptimize_MIMARKlevel'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptimize_MIMARKlevel_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptimize_MIMARKlevel = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_get_MIMARKoptimize_MIMARKlevel') then
                  trampCall(@_get_MIMARKoptimize_MIMARKlevel)
                else raise NameError.new( "Error: undefined variable _get_MIMARKoptimize_MIMARKlevel", "_get_MIMARKoptimize_MIMARKlevel" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKsource_MIMARKinfo_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKsource_MIMARKinfo'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKsource_MIMARKinfo_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKsource_MIMARKinfo = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_get_MIMARKsource_MIMARKinfo') then
                  trampCall(@_get_MIMARKsource_MIMARKinfo)
                else raise NameError.new( "Error: undefined variable _get_MIMARKsource_MIMARKinfo", "_get_MIMARKsource_MIMARKinfo" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1135"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKequal_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKequal_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKequal_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKequal_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_equal_QUMARK') then
                  trampCall(@_equal_QUMARK)
                else raise NameError.new( "Error: undefined variable _equal_QUMARK", "_equal_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:902"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKquotient_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKquotient'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKquotient_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKquotient = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_quotient') then
                  trampCall(@_quotient)
                else raise NameError.new( "Error: undefined variable _quotient", "_quotient" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKremainder_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKremainder'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKremainder_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKremainder = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_remainder') then
                  trampCall(@_remainder)
                else raise NameError.new( "Error: undefined variable _remainder", "_remainder" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmodulo_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmodulo'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmodulo_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmodulo = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_modulo') then
                  trampCall(@_modulo)
                else raise NameError.new( "Error: undefined variable _modulo", "_modulo" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKnot_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKnot'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKnot_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKnot = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_not') then
                  trampCall(@_not)
                else raise NameError.new( "Error: undefined variable _not", "_not" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcons_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcons'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcons_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcons = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cons') then
                  trampCall(@_cons)
                else raise NameError.new( "Error: undefined variable _cons", "_cons" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1408"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcar_EXMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcar_EXMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcar_EXMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcar_EXMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_set_MIMARKcar_EXMARK') then
                  trampCall(@_set_MIMARKcar_EXMARK)
                else raise NameError.new( "Error: undefined variable _set_MIMARKcar_EXMARK", "_set_MIMARKcar_EXMARK" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcdr_EXMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcdr_EXMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcdr_EXMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcdr_EXMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_set_MIMARKcdr_EXMARK') then
                  trampCall(@_set_MIMARKcdr_EXMARK)
                else raise NameError.new( "Error: undefined variable _set_MIMARKcdr_EXMARK", "_set_MIMARKcdr_EXMARK" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKexit_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKexit'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKexit_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKexit = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_exit') then
                  trampCall(@_exit)
                else raise NameError.new( "Error: undefined variable _exit", "_exit" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1214"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKprint_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKprint'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKprint_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKprint = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_print') then
                  trampCall(@_print)
                else raise NameError.new( "Error: undefined variable _print", "_print" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKprintf_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKprintf'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKprintf_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKprintf = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_printf') then
                  trampCall(@_printf)
                else raise NameError.new( "Error: undefined variable _printf", "_printf" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKsprintf_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKsprintf'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKsprintf_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKsprintf = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_sprintf') then
                  trampCall(@_sprintf)
                else raise NameError.new( "Error: undefined variable _sprintf", "_sprintf" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1151"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKnull_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKnull_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKnull_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKnull_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_null_QUMARK') then
                  trampCall(@_null_QUMARK)
                else raise NameError.new( "Error: undefined variable _null_QUMARK", "_null_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1360"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKlength_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKlength'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKlength_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKlength = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_length') then
                  trampCall(@_length)
                else raise NameError.new( "Error: undefined variable _length", "_length" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1401"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKlist_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKlist'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKlist_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKlist = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_list') then
                  trampCall(@_list)
                else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKreverse_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKreverse'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKreverse_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKreverse = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_reverse') then
                  trampCall(@_reverse)
                else raise NameError.new( "Error: undefined variable _reverse", "_reverse" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1295"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKuniq_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKuniq'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKuniq_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKuniq = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_uniq') then
                  trampCall(@_uniq)
                else raise NameError.new( "Error: undefined variable _uniq", "_uniq" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKrange_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKrange'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKrange_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKrange = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_range') then
                  trampCall(@_range)
                else raise NameError.new( "Error: undefined variable _range", "_range" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:963"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKeq_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKeq_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKeq_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKeq_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_eq_QUMARK') then
                  trampCall(@_eq_QUMARK)
                else raise NameError.new( "Error: undefined variable _eq_QUMARK", "_eq_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1392"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKgt_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKgt_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKgt_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKgt_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_gt_QUMARK') then
                  trampCall(@_gt_QUMARK)
                else raise NameError.new( "Error: undefined variable _gt_QUMARK", "_gt_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKge_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKge_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKge_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKge_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_ge_QUMARK') then
                  trampCall(@_ge_QUMARK)
                else raise NameError.new( "Error: undefined variable _ge_QUMARK", "_ge_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKlt_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKlt_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKlt_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKlt_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_lt_QUMARK') then
                  trampCall(@_lt_QUMARK)
                else raise NameError.new( "Error: undefined variable _lt_QUMARK", "_lt_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKle_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKle_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKle_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKle_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_le_QUMARK') then
                  trampCall(@_le_QUMARK)
                else raise NameError.new( "Error: undefined variable _le_QUMARK", "_le_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKeqv_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKeqv_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKeqv_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKeqv_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_eqv_QUMARK') then
                  trampCall(@_eqv_QUMARK)
                else raise NameError.new( "Error: undefined variable _eqv_QUMARK", "_eqv_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1143"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcar'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcar_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcar = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_car') then
                  trampCall(@_car)
                else raise NameError.new( "Error: undefined variable _car", "_car" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1407"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcdr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcdr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcdr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcdr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cdr') then
                  trampCall(@_cdr)
                else raise NameError.new( "Error: undefined variable _cdr", "_cdr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1409"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKwrite_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKwrite'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKwrite_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKwrite = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_write') then
                  trampCall(@_write)
                else raise NameError.new( "Error: undefined variable _write", "_write" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKwrite_MIMARKto_MIMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKwrite_MIMARKto_MIMARKstring'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKwrite_MIMARKto_MIMARKstring_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKwrite_MIMARKto_MIMARKstring = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_write_MIMARKto_MIMARKstring') then
                  trampCall(@_write_MIMARKto_MIMARKstring)
                else raise NameError.new( "Error: undefined variable _write_MIMARKto_MIMARKstring", "_write_MIMARKto_MIMARKstring" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1197"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKdisplay_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKdisplay'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKdisplay_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKdisplay = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_display') then
                  trampCall(@_display)
                else raise NameError.new( "Error: undefined variable _display", "_display" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKnewline_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKnewline'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKnewline_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKnewline = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_newline') then
                  trampCall(@_newline)
                else raise NameError.new( "Error: undefined variable _newline", "_newline" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKprocedure_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKprocedure_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKprocedure_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKprocedure_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_procedure_QUMARK') then
                  trampCall(@_procedure_QUMARK)
                else raise NameError.new( "Error: undefined variable _procedure_QUMARK", "_procedure_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1171"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmacro_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmacro_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmacro_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmacro_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_macro_QUMARK') then
                  trampCall(@_macro_QUMARK)
                else raise NameError.new( "Error: undefined variable _macro_QUMARK", "_macro_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_symbol_QUMARK') then
                  trampCall(@_symbol_QUMARK)
                else raise NameError.new( "Error: undefined variable _symbol_QUMARK", "_symbol_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1389"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_keyword_QUMARK') then
                  trampCall(@_keyword_QUMARK)
                else raise NameError.new( "Error: undefined variable _keyword_QUMARK", "_keyword_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_syntax_QUMARK') then
                  trampCall(@_syntax_QUMARK)
                else raise NameError.new( "Error: undefined variable _syntax_QUMARK", "_syntax_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcore_MIMARKsyntax_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcore_MIMARKsyntax_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcore_MIMARKsyntax_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcore_MIMARKsyntax_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_core_MIMARKsyntax_QUMARK') then
                  trampCall(@_core_MIMARKsyntax_QUMARK)
                else raise NameError.new( "Error: undefined variable _core_MIMARKsyntax_QUMARK", "_core_MIMARKsyntax_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKpair_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKpair_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKpair_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKpair_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_pair_QUMARK') then
                  trampCall(@_pair_QUMARK)
                else raise NameError.new( "Error: undefined variable _pair_QUMARK", "_pair_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1305"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKinteger_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKinteger_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKinteger_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKinteger_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_integer_QUMARK') then
                  trampCall(@_integer_QUMARK)
                else raise NameError.new( "Error: undefined variable _integer_QUMARK", "_integer_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKnumber_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKnumber_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKnumber_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKnumber_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_number_QUMARK') then
                  trampCall(@_number_QUMARK)
                else raise NameError.new( "Error: undefined variable _number_QUMARK", "_number_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:300"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKstring_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKstring_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKstring_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKstring_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_string_QUMARK') then
                  trampCall(@_string_QUMARK)
                else raise NameError.new( "Error: undefined variable _string_QUMARK", "_string_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:300"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand_MIMARK1_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand_MIMARK1'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand_MIMARK1_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand_MIMARK1 = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_macroexpand_MIMARK1') then
                  trampCall(@_macroexpand_MIMARK1)
                else raise NameError.new( "Error: undefined variable _macroexpand_MIMARK1", "_macroexpand_MIMARK1" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:176"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKto_s_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKto_s'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKto_s_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKto_s = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_to_s') then
                  trampCall(@_to_s)
                else raise NameError.new( "Error: undefined variable _to_s", "_to_s" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKs_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKs'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKs_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKs = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_to_MIMARKs') then
                  trampCall(@_to_MIMARKs)
                else raise NameError.new( "Error: undefined variable _to_MIMARKs", "_to_MIMARKs" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:772"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKto_i_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKto_i'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKto_i_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKto_i = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_to_i') then
                  trampCall(@_to_i)
                else raise NameError.new( "Error: undefined variable _to_i", "_to_i" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKi_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKi'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKi_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKi = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_to_MIMARKi') then
                  trampCall(@_to_MIMARKi)
                else raise NameError.new( "Error: undefined variable _to_MIMARKi", "_to_MIMARKi" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKnil_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKnil_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKnil_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKnil_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_nil_QUMARK') then
                  trampCall(@_nil_QUMARK)
                else raise NameError.new( "Error: undefined variable _nil_QUMARK", "_nil_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKto_list_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKto_list'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKto_list_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKto_list = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_to_list') then
                  trampCall(@_to_list)
                else raise NameError.new( "Error: undefined variable _to_list", "_to_list" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKlist_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKlist'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKlist_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKlist = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_to_MIMARKlist') then
                  trampCall(@_to_MIMARKlist)
                else raise NameError.new( "Error: undefined variable _to_MIMARKlist", "_to_MIMARKlist" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1013"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKto_arr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKto_arr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKto_arr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKto_arr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_to_arr') then
                  trampCall(@_to_arr)
                else raise NameError.new( "Error: undefined variable _to_arr", "_to_arr" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKarr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKarr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKarr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKarr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_to_MIMARKarr') then
                  trampCall(@_to_MIMARKarr)
                else raise NameError.new( "Error: undefined variable _to_MIMARKarr", "_to_MIMARKarr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:129"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKintern_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKintern'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKintern_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKintern = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_intern') then
                  trampCall(@_intern)
                else raise NameError.new( "Error: undefined variable _intern", "_intern" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKsymbol_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKsymbol'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKsymbol_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKsymbol = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_string_MIMARK_GTMARKsymbol') then
                  trampCall(@_string_MIMARK_GTMARKsymbol)
                else raise NameError.new( "Error: undefined variable _string_MIMARK_GTMARKsymbol", "_string_MIMARK_GTMARKsymbol" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1405"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_MIMARK_GTMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_MIMARK_GTMARKstring'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_MIMARK_GTMARKstring_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_MIMARK_GTMARKstring = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_symbol_MIMARK_GTMARKstring') then
                  trampCall(@_symbol_MIMARK_GTMARKstring)
                else raise NameError.new( "Error: undefined variable _symbol_MIMARK_GTMARKstring", "_symbol_MIMARK_GTMARKstring" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1418"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKjoin_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKjoin'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKjoin_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKjoin = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_string_MIMARKjoin') then
                  trampCall(@_string_MIMARKjoin)
                else raise NameError.new( "Error: undefined variable _string_MIMARKjoin", "_string_MIMARKjoin" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1202"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKrequire_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKrequire'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKrequire_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKrequire = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_require') then
                  trampCall(@_require)
                else raise NameError.new( "Error: undefined variable _require", "_require" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKread_MIMARKfrom_MIMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKread_MIMARKfrom_MIMARKstring'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKread_MIMARKfrom_MIMARKstring_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKread_MIMARKfrom_MIMARKstring = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_read_MIMARKfrom_MIMARKstring') then
                  trampCall(@_read_MIMARKfrom_MIMARKstring)
                else raise NameError.new( "Error: undefined variable _read_MIMARKfrom_MIMARKstring", "_read_MIMARKfrom_MIMARKstring" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKread_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKread'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKread_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKread = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_read') then
                  trampCall(@_read)
                else raise NameError.new( "Error: undefined variable _read", "_read" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKapply1_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKapply1'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKapply1_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKapply1 = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_apply1') then
                  trampCall(@_apply1)
                else raise NameError.new( "Error: undefined variable _apply1", "_apply1" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:264"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKvariables_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKvariables'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKvariables_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKvariables = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_global_MIMARKvariables') then
                  trampCall(@_global_MIMARKvariables)
                else raise NameError.new( "Error: undefined variable _global_MIMARKvariables", "_global_MIMARKvariables" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1424"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvalues_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvalues'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvalues_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvalues = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_make_MIMARKvalues') then
                  trampCall(@_make_MIMARKvalues)
                else raise NameError.new( "Error: undefined variable _make_MIMARKvalues", "_make_MIMARKvalues" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:717"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_values_QUMARK') then
                  trampCall(@_values_QUMARK)
                else raise NameError.new( "Error: undefined variable _values_QUMARK", "_values_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:722"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_MIMARKvalues_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_MIMARKvalues'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_MIMARKvalues_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_MIMARKvalues = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_values_MIMARKvalues') then
                  trampCall(@_values_MIMARKvalues)
                else raise NameError.new( "Error: undefined variable _values_MIMARKvalues", "_values_MIMARKvalues" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:723"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKkeyword_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKkeyword'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKkeyword_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKkeyword = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_make_MIMARKkeyword') then
                  trampCall(@_make_MIMARKkeyword)
                else raise NameError.new( "Error: undefined variable _make_MIMARKkeyword", "_make_MIMARKkeyword" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_MIMARK_GTMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_MIMARK_GTMARKstring'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_MIMARK_GTMARKstring_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_MIMARK_GTMARKstring = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_keyword_MIMARK_GTMARKstring') then
                  trampCall(@_keyword_MIMARK_GTMARKstring)
                else raise NameError.new( "Error: undefined variable _keyword_MIMARK_GTMARKstring", "_keyword_MIMARK_GTMARKstring" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKget_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKget'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKget_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKget = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKget') then
                  trampCall(@_hash_MIMARKtable_MIMARKget)
                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKget", "_hash_MIMARKtable_MIMARKget" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:860"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKput_EXMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKput_EXMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKput_EXMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKput_EXMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKput_EXMARK') then
                  trampCall(@_hash_MIMARKtable_MIMARKput_EXMARK)
                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKput_EXMARK", "_hash_MIMARKtable_MIMARKput_EXMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:835"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKexist_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKexist_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKexist_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKexist_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKexist_QUMARK') then
                  trampCall(@_hash_MIMARKtable_MIMARKexist_QUMARK)
                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKexist_QUMARK", "_hash_MIMARKtable_MIMARKexist_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKraise_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKraise'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKraise_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKraise = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_raise') then
                  trampCall(@_raise)
                else raise NameError.new( "Error: undefined variable _raise", "_raise" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:780"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKset_EXMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKset_EXMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKset_EXMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKset_EXMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_vector_MIMARKset_EXMARK') then
                  trampCall(@_vector_MIMARKset_EXMARK)
                else raise NameError.new( "Error: undefined variable _vector_MIMARKset_EXMARK", "_vector_MIMARKset_EXMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:913"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKquote_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKquote'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKquote_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKquote = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_quote') then
                  trampCall(@_quote)
                else raise NameError.new( "Error: undefined variable _quote", "_quote" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1312"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_MIMARKquote_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_MIMARKquote'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_MIMARKquote_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_MIMARKquote = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_syntax_MIMARKquote') then
                  trampCall(@_syntax_MIMARKquote)
                else raise NameError.new( "Error: undefined variable _syntax_MIMARKquote", "_syntax_MIMARKquote" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1314"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKif_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKif'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKif_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKif = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_if') then
                  trampCall(@_if)
                else raise NameError.new( "Error: undefined variable _if", "_if" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1384"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKbegin_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKbegin'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKbegin_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKbegin = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_begin') then
                  trampCall(@_begin)
                else raise NameError.new( "Error: undefined variable _begin", "_begin" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1410"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKlambda_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKlambda'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKlambda_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKlambda = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_lambda') then
                  trampCall(@_lambda)
                else raise NameError.new( "Error: undefined variable _lambda", "_lambda" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1414"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmacro_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmacro'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmacro_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmacro = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_macro') then
                  trampCall(@_macro)
                else raise NameError.new( "Error: undefined variable _macro", "_macro" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1423"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKlet_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKlet'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKlet_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKlet = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_let') then
                  trampCall(@_let)
                else raise NameError.new( "Error: undefined variable _let", "_let" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1415"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKletrec_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKletrec'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKletrec_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKletrec = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_letrec') then
                  trampCall(@_letrec)
                else raise NameError.new( "Error: undefined variable _letrec", "_letrec" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1342"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKdefine'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKdefine = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_define') then
                  trampCall(@_define)
                else raise NameError.new( "Error: undefined variable _define", "_define" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1422"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKset_EXMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKset_EXMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKset_EXMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKset_EXMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_set_EXMARK') then
                  trampCall(@_set_EXMARK)
                else raise NameError.new( "Error: undefined variable _set_EXMARK", "_set_EXMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1373"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKerror_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKerror'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKerror_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKerror = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_error') then
                  trampCall(@_error)
                else raise NameError.new( "Error: undefined variable _error", "_error" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1028"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKsyntax_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKsyntax'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKsyntax_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKsyntax = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_define_MIMARKsyntax') then
                  trampCall(@_define_MIMARKsyntax)
                else raise NameError.new( "Error: undefined variable _define_MIMARKsyntax", "_define_MIMARKsyntax" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1346"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_debug_MIMARKprint') then
                  trampCall(@_debug_MIMARKprint)
                else raise NameError.new( "Error: undefined variable _debug_MIMARKprint", "_debug_MIMARKprint" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:946"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcaar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcaar'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcaar_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcaar = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_caar') then
                  trampCall(@_caar)
                else raise NameError.new( "Error: undefined variable _caar", "_caar" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:504"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcadr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcadr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcadr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcadr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cadr') then
                  trampCall(@_cadr)
                else raise NameError.new( "Error: undefined variable _cadr", "_cadr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:758"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcdar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcdar'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcdar_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcdar = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cdar') then
                  trampCall(@_cdar)
                else raise NameError.new( "Error: undefined variable _cdar", "_cdar" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:505"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcddr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcddr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcddr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcddr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cddr') then
                  trampCall(@_cddr)
                else raise NameError.new( "Error: undefined variable _cddr", "_cddr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1345"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcaaar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcaaar'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcaaar_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcaaar = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_caaar') then
                  trampCall(@_caaar)
                else raise NameError.new( "Error: undefined variable _caaar", "_caaar" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:87"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcaadr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcaadr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcaadr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcaadr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_caadr') then
                  trampCall(@_caadr)
                else raise NameError.new( "Error: undefined variable _caadr", "_caadr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:88"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcadar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcadar'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcadar_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcadar = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cadar') then
                  trampCall(@_cadar)
                else raise NameError.new( "Error: undefined variable _cadar", "_cadar" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:89"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcaddr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcaddr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcaddr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcaddr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_caddr') then
                  trampCall(@_caddr)
                else raise NameError.new( "Error: undefined variable _caddr", "_caddr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:566"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcdaar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcdaar'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcdaar_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcdaar = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cdaar') then
                  trampCall(@_cdaar)
                else raise NameError.new( "Error: undefined variable _cdaar", "_cdaar" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:91"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcdadr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcdadr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcdadr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcdadr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cdadr') then
                  trampCall(@_cdadr)
                else raise NameError.new( "Error: undefined variable _cdadr", "_cdadr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:92"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcddar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcddar'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcddar_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcddar = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cddar') then
                  trampCall(@_cddar)
                else raise NameError.new( "Error: undefined variable _cddar", "_cddar" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:93"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcdddr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcdddr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcdddr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcdddr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cdddr') then
                  trampCall(@_cdddr)
                else raise NameError.new( "Error: undefined variable _cdddr", "_cdddr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:94"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcaaaar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcaaaar'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcaaaar_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcaaaar = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_caaaar') then
                  trampCall(@_caaaar)
                else raise NameError.new( "Error: undefined variable _caaaar", "_caaaar" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:95"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcaaadr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcaaadr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcaaadr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcaaadr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_caaadr') then
                  trampCall(@_caaadr)
                else raise NameError.new( "Error: undefined variable _caaadr", "_caaadr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:96"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcaadar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcaadar'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcaadar_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcaadar = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_caadar') then
                  trampCall(@_caadar)
                else raise NameError.new( "Error: undefined variable _caadar", "_caadar" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:97"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcaaddr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcaaddr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcaaddr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcaaddr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_caaddr') then
                  trampCall(@_caaddr)
                else raise NameError.new( "Error: undefined variable _caaddr", "_caaddr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:98"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcadaar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcadaar'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcadaar_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcadaar = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cadaar') then
                  trampCall(@_cadaar)
                else raise NameError.new( "Error: undefined variable _cadaar", "_cadaar" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:99"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcadadr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcadadr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcadadr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcadadr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cadadr') then
                  trampCall(@_cadadr)
                else raise NameError.new( "Error: undefined variable _cadadr", "_cadadr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:100"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcaddar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcaddar'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcaddar_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcaddar = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_caddar') then
                  trampCall(@_caddar)
                else raise NameError.new( "Error: undefined variable _caddar", "_caddar" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:101"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcadddr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcadddr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcadddr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcadddr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cadddr') then
                  trampCall(@_cadddr)
                else raise NameError.new( "Error: undefined variable _cadddr", "_cadddr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:102"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcdaaar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcdaaar'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcdaaar_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcdaaar = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cdaaar') then
                  trampCall(@_cdaaar)
                else raise NameError.new( "Error: undefined variable _cdaaar", "_cdaaar" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:103"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcdaadr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcdaadr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcdaadr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcdaadr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cdaadr') then
                  trampCall(@_cdaadr)
                else raise NameError.new( "Error: undefined variable _cdaadr", "_cdaadr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:104"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcdadar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcdadar'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcdadar_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcdadar = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cdadar') then
                  trampCall(@_cdadar)
                else raise NameError.new( "Error: undefined variable _cdadar", "_cdadar" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:105"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcdaddr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcdaddr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcdaddr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcdaddr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cdaddr') then
                  trampCall(@_cdaddr)
                else raise NameError.new( "Error: undefined variable _cdaddr", "_cdaddr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:106"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcddaar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcddaar'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcddaar_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcddaar = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cddaar') then
                  trampCall(@_cddaar)
                else raise NameError.new( "Error: undefined variable _cddaar", "_cddaar" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:107"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcddadr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcddadr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcddadr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcddadr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cddadr') then
                  trampCall(@_cddadr)
                else raise NameError.new( "Error: undefined variable _cddadr", "_cddadr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:108"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcdddar_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcdddar'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcdddar_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcdddar = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cdddar') then
                  trampCall(@_cdddar)
                else raise NameError.new( "Error: undefined variable _cdddar", "_cdddar" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:109"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcddddr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcddddr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcddddr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcddddr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cddddr') then
                  trampCall(@_cddddr)
                else raise NameError.new( "Error: undefined variable _cddddr", "_cddddr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:110"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKiota_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKiota'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKiota_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKiota = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_iota') then
                  trampCall(@_iota)
                else raise NameError.new( "Error: undefined variable _iota", "_iota" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:116"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKappend_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKappend'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKappend_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKappend = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_append') then
                  trampCall(@_append)
                else raise NameError.new( "Error: undefined variable _append", "_append" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1252"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKvector_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKvector'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKvector_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKvector = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_vector') then
                  trampCall(@_vector)
                else raise NameError.new( "Error: undefined variable _vector", "_vector" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:906"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKlist_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKlist_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKlist_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKlist_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_list_QUMARK') then
                  trampCall(@_list_QUMARK)
                else raise NameError.new( "Error: undefined variable _list_QUMARK", "_list_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1359"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKeven_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKeven_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKeven_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKeven_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_even_QUMARK') then
                  trampCall(@_even_QUMARK)
                else raise NameError.new( "Error: undefined variable _even_QUMARK", "_even_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:131"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKodd_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKodd_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKodd_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKodd_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_odd_QUMARK') then
                  trampCall(@_odd_QUMARK)
                else raise NameError.new( "Error: undefined variable _odd_QUMARK", "_odd_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:132"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKzero_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKzero_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKzero_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKzero_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_zero_QUMARK') then
                  trampCall(@_zero_QUMARK)
                else raise NameError.new( "Error: undefined variable _zero_QUMARK", "_zero_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:306"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKpositive_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKpositive_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKpositive_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKpositive_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_positive_QUMARK') then
                  trampCall(@_positive_QUMARK)
                else raise NameError.new( "Error: undefined variable _positive_QUMARK", "_positive_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:134"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKnegative_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKnegative_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKnegative_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKnegative_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_negative_QUMARK') then
                  trampCall(@_negative_QUMARK)
                else raise NameError.new( "Error: undefined variable _negative_QUMARK", "_negative_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:135"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKabs_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKabs'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKabs_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKabs = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_abs') then
                  trampCall(@_abs)
                else raise NameError.new( "Error: undefined variable _abs", "_abs" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:136"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmax_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmax'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmax_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmax = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_max') then
                  trampCall(@_max)
                else raise NameError.new( "Error: undefined variable _max", "_max" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:137"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmin_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmin'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmin_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmin = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_min') then
                  trampCall(@_min)
                else raise NameError.new( "Error: undefined variable _min", "_min" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:139"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKsucc_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKsucc'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKsucc_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKsucc = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_succ') then
                  trampCall(@_succ)
                else raise NameError.new( "Error: undefined variable _succ", "_succ" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:913"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKpred_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKpred'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKpred_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKpred = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_pred') then
                  trampCall(@_pred)
                else raise NameError.new( "Error: undefined variable _pred", "_pred" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKnth_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKnth'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKnth_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKnth = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_nth') then
                  trampCall(@_nth)
                else raise NameError.new( "Error: undefined variable _nth", "_nth" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1054"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKfirst_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKfirst'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKfirst_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKfirst = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_first') then
                  trampCall(@_first)
                else raise NameError.new( "Error: undefined variable _first", "_first" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1262"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKsecond_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKsecond'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKsecond_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKsecond = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_second') then
                  trampCall(@_second)
                else raise NameError.new( "Error: undefined variable _second", "_second" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1415"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKthird_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKthird'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKthird_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKthird = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_third') then
                  trampCall(@_third)
                else raise NameError.new( "Error: undefined variable _third", "_third" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1416"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKfourth_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKfourth'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKfourth_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKfourth = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_fourth') then
                  trampCall(@_fourth)
                else raise NameError.new( "Error: undefined variable _fourth", "_fourth" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1337"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKfifth_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKfifth'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKfifth_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKfifth = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_fifth') then
                  trampCall(@_fifth)
                else raise NameError.new( "Error: undefined variable _fifth", "_fifth" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:158"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKsixth_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKsixth'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKsixth_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKsixth = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_sixth') then
                  trampCall(@_sixth)
                else raise NameError.new( "Error: undefined variable _sixth", "_sixth" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:159"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKseventh_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKseventh'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKseventh_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKseventh = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_seventh') then
                  trampCall(@_seventh)
                else raise NameError.new( "Error: undefined variable _seventh", "_seventh" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:160"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKeighth_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKeighth'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKeighth_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKeighth = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_eighth') then
                  trampCall(@_eighth)
                else raise NameError.new( "Error: undefined variable _eighth", "_eighth" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:161"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKninth_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKninth'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKninth_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKninth = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_ninth') then
                  trampCall(@_ninth)
                else raise NameError.new( "Error: undefined variable _ninth", "_ninth" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:162"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKtenth_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKtenth'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKtenth_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKtenth = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_tenth') then
                  trampCall(@_tenth)
                else raise NameError.new( "Error: undefined variable _tenth", "_tenth" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:163"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKx_MIMARK_GTMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKx_MIMARK_GTMARKstring'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKx_MIMARK_GTMARKstring_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKx_MIMARK_GTMARKstring = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_x_MIMARK_GTMARKstring') then
                  trampCall(@_x_MIMARK_GTMARKstring)
                else raise NameError.new( "Error: undefined variable _x_MIMARK_GTMARKstring", "_x_MIMARK_GTMARKstring" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:166"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKnumber_MIMARK_GTMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKnumber_MIMARK_GTMARKstring'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKnumber_MIMARK_GTMARKstring_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKnumber_MIMARK_GTMARKstring = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_number_MIMARK_GTMARKstring') then
                  trampCall(@_number_MIMARK_GTMARKstring)
                else raise NameError.new( "Error: undefined variable _number_MIMARK_GTMARKstring", "_number_MIMARK_GTMARKstring" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:166"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKappend_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKappend'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKappend_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKappend = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_string_MIMARKappend') then
                  trampCall(@_string_MIMARKappend)
                else raise NameError.new( "Error: undefined variable _string_MIMARKappend", "_string_MIMARKappend" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:167"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_macroexpand') then
                  trampCall(@_macroexpand)
                else raise NameError.new( "Error: undefined variable _macroexpand", "_macroexpand" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:178"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKfeedto_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKfeedto'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKfeedto_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKfeedto = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_feedto') then
                  trampCall(@_feedto)
                else raise NameError.new( "Error: undefined variable _feedto", "_feedto" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:199"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcond_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcond'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcond_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcond = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cond') then
                  trampCall(@_cond)
                else raise NameError.new( "Error: undefined variable _cond", "_cond" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1304"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKlet1_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKlet1'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKlet1_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKlet1 = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_let1') then
                  trampCall(@_let1)
                else raise NameError.new( "Error: undefined variable _let1", "_let1" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1356"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKor_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKor'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKor_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKor = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_or') then
                  trampCall(@_or)
                else raise NameError.new( "Error: undefined variable _or", "_or" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1287"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKand_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKand'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKand_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKand = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_and') then
                  trampCall(@_and)
                else raise NameError.new( "Error: undefined variable _and", "_and" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1359"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKapply_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKapply'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKapply_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKapply = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_apply') then
                  trampCall(@_apply)
                else raise NameError.new( "Error: undefined variable _apply", "_apply" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:906"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKquasiquote_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKquasiquote'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKquasiquote_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKquasiquote = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_quasiquote') then
                  trampCall(@_quasiquote)
                else raise NameError.new( "Error: undefined variable _quasiquote", "_quasiquote" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:305"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKunquote_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKunquote'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKunquote_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKunquote = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_unquote') then
                  trampCall(@_unquote)
                else raise NameError.new( "Error: undefined variable _unquote", "_unquote" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:327"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKunquote_MIMARKsplicing_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKunquote_MIMARKsplicing'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKunquote_MIMARKsplicing_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKunquote_MIMARKsplicing = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_unquote_MIMARKsplicing') then
                  trampCall(@_unquote_MIMARKsplicing)
                else raise NameError.new( "Error: undefined variable _unquote_MIMARKsplicing", "_unquote_MIMARKsplicing" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:332"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKwhen_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKwhen'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKwhen_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKwhen = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_when') then
                  trampCall(@_when)
                else raise NameError.new( "Error: undefined variable _when", "_when" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1212"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKunless_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKunless'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKunless_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKunless = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_unless') then
                  trampCall(@_unless)
                else raise NameError.new( "Error: undefined variable _unless", "_unless" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:341"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKwhile_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKwhile'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKwhile_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKwhile = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_while') then
                  trampCall(@_while)
                else raise NameError.new( "Error: undefined variable _while", "_while" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:358"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKuntil_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKuntil'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKuntil_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKuntil = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_until') then
                  trampCall(@_until)
                else raise NameError.new( "Error: undefined variable _until", "_until" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:356"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKif_MIMARKlet1_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKif_MIMARKlet1'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKif_MIMARKlet1_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKif_MIMARKlet1 = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_if_MIMARKlet1') then
                  trampCall(@_if_MIMARKlet1)
                else raise NameError.new( "Error: undefined variable _if_MIMARKlet1", "_if_MIMARKlet1" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:381"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKerrorf_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKerrorf'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKerrorf_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKerrorf = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_errorf') then
                  trampCall(@_errorf)
                else raise NameError.new( "Error: undefined variable _errorf", "_errorf" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1213"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptional_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptional'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptional_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptional = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_get_MIMARKoptional') then
                  trampCall(@_get_MIMARKoptional)
                else raise NameError.new( "Error: undefined variable _get_MIMARKoptional", "_get_MIMARKoptional" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1134"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcheck_MIMARKarg_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcheck_MIMARKarg'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcheck_MIMARKarg_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcheck_MIMARKarg = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_check_MIMARKarg') then
                  trampCall(@_check_MIMARKarg)
                else raise NameError.new( "Error: undefined variable _check_MIMARKarg", "_check_MIMARKarg" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:408"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKdo_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKdo'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKdo_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKdo = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_do') then
                  trampCall(@_do)
                else raise NameError.new( "Error: undefined variable _do", "_do" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:419"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKmember_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKmember'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKmember_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKmember = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_generic_MIMARKmember') then
                  trampCall(@_generic_MIMARKmember)
                else raise NameError.new( "Error: undefined variable _generic_MIMARKmember", "_generic_MIMARKmember" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:459"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmemq_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmemq'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmemq_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmemq = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_memq') then
                  trampCall(@_memq)
                else raise NameError.new( "Error: undefined variable _memq", "_memq" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1257"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmemv_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmemv'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmemv_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmemv = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_memv') then
                  trampCall(@_memv)
                else raise NameError.new( "Error: undefined variable _memv", "_memv" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:456"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmember_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmember'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmember_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmember = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_member') then
                  trampCall(@_member)
                else raise NameError.new( "Error: undefined variable _member", "_member" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:458"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKassoc_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKassoc'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKassoc_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKassoc = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_generic_MIMARKassoc') then
                  trampCall(@_generic_MIMARKassoc)
                else raise NameError.new( "Error: undefined variable _generic_MIMARKassoc", "_generic_MIMARKassoc" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:473"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKassq_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKassq'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKassq_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKassq = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_assq') then
                  trampCall(@_assq)
                else raise NameError.new( "Error: undefined variable _assq", "_assq" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:478"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKassv_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKassv'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKassv_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKassv = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_assv') then
                  trampCall(@_assv)
                else raise NameError.new( "Error: undefined variable _assv", "_assv" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:481"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKassoc_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKassoc'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKassoc_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKassoc = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_assoc') then
                  trampCall(@_assoc)
                else raise NameError.new( "Error: undefined variable _assoc", "_assoc" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:484"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKacons_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKacons'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKacons_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKacons = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_acons') then
                  trampCall(@_acons)
                else raise NameError.new( "Error: undefined variable _acons", "_acons" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:475"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKassq_MIMARKref_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKassq_MIMARKref'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKassq_MIMARKref_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKassq_MIMARKref = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_assq_MIMARKref') then
                  trampCall(@_assq_MIMARKref)
                else raise NameError.new( "Error: undefined variable _assq_MIMARKref", "_assq_MIMARKref" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1383"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKassv_MIMARKref_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKassv_MIMARKref'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKassv_MIMARKref_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKassv_MIMARKref = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_assv_MIMARKref') then
                  trampCall(@_assv_MIMARKref)
                else raise NameError.new( "Error: undefined variable _assv_MIMARKref", "_assv_MIMARKref" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1169"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKassoc_MIMARKref_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKassoc_MIMARKref'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKassoc_MIMARKref_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKassoc_MIMARKref = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_assoc_MIMARKref') then
                  trampCall(@_assoc_MIMARKref)
                else raise NameError.new( "Error: undefined variable _assoc_MIMARKref", "_assoc_MIMARKref" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:483"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKfold_MIMARKright_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKfold_MIMARKright'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKfold_MIMARKright_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKfold_MIMARKright = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_fold_MIMARKright') then
                  trampCall(@_fold_MIMARKright)
                else raise NameError.new( "Error: undefined variable _fold_MIMARKright", "_fold_MIMARKright" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:496"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_unzip1_MIMARKwith_MIMARKcdr') then
                  trampCall(@_unzip1_MIMARKwith_MIMARKcdr)
                else raise NameError.new( "Error: undefined variable _unzip1_MIMARKwith_MIMARKcdr", "_unzip1_MIMARKwith_MIMARKcdr" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:596"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr_MIMARKiterative_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr_MIMARKiterative'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr_MIMARKiterative_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr_MIMARKiterative = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative') then
                  trampCall(@_unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative)
                else raise NameError.new( "Error: undefined variable _unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative", "_unzip1_MIMARKwith_MIMARKcdr_MIMARKiterative" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:506"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKfind_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKfind'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKfind_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKfind = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_find') then
                  trampCall(@_find)
                else raise NameError.new( "Error: undefined variable _find", "_find" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1124"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKany_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKany'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKany_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKany = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_any') then
                  trampCall(@_any)
                else raise NameError.new( "Error: undefined variable _any", "_any" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:636"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmap_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmap'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmap_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmap = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_map') then
                  trampCall(@_map)
                else raise NameError.new( "Error: undefined variable _map", "_map" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1413"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKfor_MIMARKeach_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKfor_MIMARKeach'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKfor_MIMARKeach_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKfor_MIMARKeach = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_for_MIMARKeach') then
                  trampCall(@_for_MIMARKeach)
                else raise NameError.new( "Error: undefined variable _for_MIMARKeach", "_for_MIMARKeach" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1237"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKfilter_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKfilter'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKfilter_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKfilter = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_filter') then
                  trampCall(@_filter)
                else raise NameError.new( "Error: undefined variable _filter", "_filter" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:640"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKfilter_MIMARKmap_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKfilter_MIMARKmap'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKfilter_MIMARKmap_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKfilter_MIMARKmap = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_filter_MIMARKmap') then
                  trampCall(@_filter_MIMARKmap)
                else raise NameError.new( "Error: undefined variable _filter_MIMARKmap", "_filter_MIMARKmap" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:641"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcase_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcase'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcase_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcase = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_case') then
                  trampCall(@_case)
                else raise NameError.new( "Error: undefined variable _case", "_case" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1401"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKlet_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKlet_ASMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKlet_ASMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKlet_ASMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_let_ASMARK') then
                  trampCall(@_let_ASMARK)
                else raise NameError.new( "Error: undefined variable _let_ASMARK", "_let_ASMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1382"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKbegin0_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKbegin0'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKbegin0_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKbegin0 = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_begin0') then
                  trampCall(@_begin0)
                else raise NameError.new( "Error: undefined variable _begin0", "_begin0" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:698"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKvalues'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKvalues = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_values') then
                  trampCall(@_values)
                else raise NameError.new( "Error: undefined variable _values", "_values" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1172"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcall_MIMARKwith_MIMARKvalues_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcall_MIMARKwith_MIMARKvalues'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcall_MIMARKwith_MIMARKvalues_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcall_MIMARKwith_MIMARKvalues = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_call_MIMARKwith_MIMARKvalues') then
                  trampCall(@_call_MIMARKwith_MIMARKvalues)
                else raise NameError.new( "Error: undefined variable _call_MIMARKwith_MIMARKvalues", "_call_MIMARKwith_MIMARKvalues" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:729"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKreceive_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKreceive'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKreceive_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKreceive = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_receive') then
                  trampCall(@_receive)
                else raise NameError.new( "Error: undefined variable _receive", "_receive" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1179"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKkeyword_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKkeyword'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKkeyword_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKkeyword = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_get_MIMARKkeyword') then
                  trampCall(@_get_MIMARKkeyword)
                else raise NameError.new( "Error: undefined variable _get_MIMARKkeyword", "_get_MIMARKkeyword" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:737"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKdot_MIMARKoperator_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKdot_MIMARKoperator'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKdot_MIMARKoperator_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKdot_MIMARKoperator = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_dot_MIMARKoperator') then
                  trampCall(@_dot_MIMARKoperator)
                else raise NameError.new( "Error: undefined variable _dot_MIMARKoperator", "_dot_MIMARKoperator" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:764"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKwith_MIMARKopen_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKwith_MIMARKopen'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKwith_MIMARKopen_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKwith_MIMARKopen = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_with_MIMARKopen') then
                  trampCall(@_with_MIMARKopen)
                else raise NameError.new( "Error: undefined variable _with_MIMARKopen", "_with_MIMARKopen" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1219"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKlast_MIMARKpair_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKlast_MIMARKpair'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKlast_MIMARKpair_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKlast_MIMARKpair = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_last_MIMARKpair') then
                  trampCall(@_last_MIMARKpair)
                else raise NameError.new( "Error: undefined variable _last_MIMARKpair", "_last_MIMARKpair" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:797"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcons_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcons_ASMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcons_ASMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcons_ASMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_cons_ASMARK') then
                  trampCall(@_cons_ASMARK)
                else raise NameError.new( "Error: undefined variable _cons_ASMARK", "_cons_ASMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:805"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKlist_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKlist_ASMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKlist_ASMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKlist_ASMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_list_ASMARK') then
                  trampCall(@_list_ASMARK)
                else raise NameError.new( "Error: undefined variable _list_ASMARK", "_list_ASMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:805"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKhash_MIMARKtable_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKhash_MIMARKtable'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKhash_MIMARKtable_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKhash_MIMARKtable = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_make_MIMARKhash_MIMARKtable') then
                  trampCall(@_make_MIMARKhash_MIMARKtable)
                else raise NameError.new( "Error: undefined variable _make_MIMARKhash_MIMARKtable", "_make_MIMARKhash_MIMARKtable" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:821"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_hash_MIMARKtable_QUMARK') then
                  trampCall(@_hash_MIMARKtable_QUMARK)
                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_QUMARK", "_hash_MIMARKtable_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:814"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKnum_MIMARKentries_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKnum_MIMARKentries'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKnum_MIMARKentries_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKnum_MIMARKentries = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKnum_MIMARKentries') then
                  trampCall(@_hash_MIMARKtable_MIMARKnum_MIMARKentries)
                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKnum_MIMARKentries", "_hash_MIMARKtable_MIMARKnum_MIMARKentries" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:817"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_hash_MIMARKtable') then
                  trampCall(@_hash_MIMARKtable)
                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable", "_hash_MIMARKtable" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:866"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKclear_EXMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKclear_EXMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKclear_EXMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKclear_EXMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKclear_EXMARK') then
                  trampCall(@_hash_MIMARKtable_MIMARKclear_EXMARK)
                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKclear_EXMARK", "_hash_MIMARKtable_MIMARKclear_EXMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:828"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKdelete_EXMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKdelete_EXMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKdelete_EXMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKdelete_EXMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKdelete_EXMARK') then
                  trampCall(@_hash_MIMARKtable_MIMARKdelete_EXMARK)
                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKdelete_EXMARK", "_hash_MIMARKtable_MIMARKdelete_EXMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:831"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKpush_EXMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKpush_EXMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKpush_EXMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKpush_EXMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKpush_EXMARK') then
                  trampCall(@_hash_MIMARKtable_MIMARKpush_EXMARK)
                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKpush_EXMARK", "_hash_MIMARKtable_MIMARKpush_EXMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:834"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKkeys_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKkeys'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKkeys_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKkeys = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKkeys') then
                  trampCall(@_hash_MIMARKtable_MIMARKkeys)
                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKkeys", "_hash_MIMARKtable_MIMARKkeys" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:857"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKvalues_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKvalues'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKvalues_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKvalues = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKvalues') then
                  trampCall(@_hash_MIMARKtable_MIMARKvalues)
                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKvalues", "_hash_MIMARKtable_MIMARKvalues" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:843"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKmap_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKmap'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKmap_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKmap = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKmap') then
                  trampCall(@_hash_MIMARKtable_MIMARKmap)
                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKmap", "_hash_MIMARKtable_MIMARKmap" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:852"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKfor_MIMARKeach_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKfor_MIMARKeach'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKfor_MIMARKeach_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKfor_MIMARKeach = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARKfor_MIMARKeach') then
                  trampCall(@_hash_MIMARKtable_MIMARKfor_MIMARKeach)
                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARKfor_MIMARKeach", "_hash_MIMARKtable_MIMARKfor_MIMARKeach" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:852"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARK_GTMARKalist_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARK_GTMARKalist'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARK_GTMARKalist_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARK_GTMARKalist = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_hash_MIMARKtable_MIMARK_GTMARKalist') then
                  trampCall(@_hash_MIMARKtable_MIMARK_GTMARKalist)
                else raise NameError.new( "Error: undefined variable _hash_MIMARKtable_MIMARK_GTMARKalist", "_hash_MIMARKtable_MIMARK_GTMARKalist" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:854"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKalist_MIMARK_GTMARKhash_MIMARKtable_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKalist_MIMARK_GTMARKhash_MIMARKtable'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKalist_MIMARK_GTMARKhash_MIMARKtable_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKalist_MIMARK_GTMARKhash_MIMARKtable = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_alist_MIMARK_GTMARKhash_MIMARKtable') then
                  trampCall(@_alist_MIMARK_GTMARKhash_MIMARKtable)
                else raise NameError.new( "Error: undefined variable _alist_MIMARK_GTMARKhash_MIMARKtable", "_alist_MIMARK_GTMARKhash_MIMARKtable" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:863"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKvector_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKvector_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKvector_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKvector_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_vector_QUMARK') then
                  trampCall(@_vector_QUMARK)
                else raise NameError.new( "Error: undefined variable _vector_QUMARK", "_vector_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:897"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvector_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvector'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvector_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvector = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_make_MIMARKvector') then
                  trampCall(@_make_MIMARKvector)
                else raise NameError.new( "Error: undefined variable _make_MIMARKvector", "_make_MIMARKvector" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:875"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKlength_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKlength'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKlength_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKlength = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_vector_MIMARKlength') then
                  trampCall(@_vector_MIMARKlength)
                else raise NameError.new( "Error: undefined variable _vector_MIMARKlength", "_vector_MIMARKlength" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:916"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKcopy_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKcopy'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKcopy_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKcopy = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_vector_MIMARKcopy') then
                  trampCall(@_vector_MIMARKcopy)
                else raise NameError.new( "Error: undefined variable _vector_MIMARKcopy", "_vector_MIMARKcopy" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:883"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKref_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKref'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKref_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKref = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_vector_MIMARKref') then
                  trampCall(@_vector_MIMARKref)
                else raise NameError.new( "Error: undefined variable _vector_MIMARKref", "_vector_MIMARKref" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:919"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKequal_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKequal_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKequal_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKequal_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_vector_MIMARKequal_QUMARK') then
                  trampCall(@_vector_MIMARKequal_QUMARK)
                else raise NameError.new( "Error: undefined variable _vector_MIMARKequal_QUMARK", "_vector_MIMARKequal_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:896"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKlist_MIMARK_GTMARKvector_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKlist_MIMARK_GTMARKvector'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKlist_MIMARK_GTMARKvector_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKlist_MIMARK_GTMARKvector = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_list_MIMARK_GTMARKvector') then
                  trampCall(@_list_MIMARK_GTMARKvector)
                else raise NameError.new( "Error: undefined variable _list_MIMARK_GTMARKvector", "_list_MIMARK_GTMARKvector" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:905"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKfill_EXMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKfill_EXMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKfill_EXMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKfill_EXMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_vector_MIMARKfill_EXMARK') then
                  trampCall(@_vector_MIMARKfill_EXMARK)
                else raise NameError.new( "Error: undefined variable _vector_MIMARKfill_EXMARK", "_vector_MIMARKfill_EXMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:908"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARK_GTMARKlist_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARK_GTMARKlist'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARK_GTMARKlist_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARK_GTMARKlist = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_vector_MIMARK_GTMARKlist') then
                  trampCall(@_vector_MIMARK_GTMARKlist)
                else raise NameError.new( "Error: undefined variable _vector_MIMARK_GTMARKlist", "_vector_MIMARK_GTMARKlist" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:915"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKlength_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKlength'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKlength_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKlength = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_debug_MIMARKprint_MIMARKlength') then
                  trampCall(@_debug_MIMARKprint_MIMARKlength)
                else raise NameError.new( "Error: undefined variable _debug_MIMARKprint_MIMARKlength", "_debug_MIMARKprint_MIMARKlength" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:927"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKoutput_MIMARKfunc_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKoutput_MIMARKfunc'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKoutput_MIMARKfunc_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKoutput_MIMARKfunc = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_debug_MIMARKprint_MIMARKoutput_MIMARKfunc') then
                  trampCall(@_debug_MIMARKprint_MIMARKoutput_MIMARKfunc)
                else raise NameError.new( "Error: undefined variable _debug_MIMARKprint_MIMARKoutput_MIMARKfunc", "_debug_MIMARKprint_MIMARKoutput_MIMARKfunc" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:952"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKlimit_MIMARKlength_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKlimit_MIMARKlength'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKlimit_MIMARKlength_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKlimit_MIMARKlength = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_debug_MIMARKlimit_MIMARKlength') then
                  trampCall(@_debug_MIMARKlimit_MIMARKlength)
                else raise NameError.new( "Error: undefined variable _debug_MIMARKlimit_MIMARKlength", "_debug_MIMARKlimit_MIMARKlength" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:952"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_pretty_MIMARKprint') then
                  trampCall(@_pretty_MIMARKprint)
                else raise NameError.new( "Error: undefined variable _pretty_MIMARKprint", "_pretty_MIMARKprint" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:993"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint_MIMARKto_MIMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint_MIMARKto_MIMARKstring'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint_MIMARKto_MIMARKstring_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint_MIMARKto_MIMARKstring = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_pretty_MIMARKprint_MIMARKto_MIMARKstring') then
                  trampCall(@_pretty_MIMARKprint_MIMARKto_MIMARKstring)
                else raise NameError.new( "Error: undefined variable _pretty_MIMARKprint_MIMARKto_MIMARKstring", "_pretty_MIMARKprint_MIMARKto_MIMARKstring" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1152"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKsort_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKsort'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKsort_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKsort = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_sort') then
                  trampCall(@_sort)
                else raise NameError.new( "Error: undefined variable _sort", "_sort" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1000"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKsort_MIMARKby_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKsort_MIMARKby'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKsort_MIMARKby_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKsort_MIMARKby = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_sort_MIMARKby') then
                  trampCall(@_sort_MIMARKby)
                else raise NameError.new( "Error: undefined variable _sort_MIMARKby", "_sort_MIMARKby" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1010"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKlength_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKlength'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKlength_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKlength = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_string_MIMARKlength') then
                  trampCall(@_string_MIMARKlength)
                else raise NameError.new( "Error: undefined variable _string_MIMARKlength", "_string_MIMARKlength" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1020"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKregexp_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKregexp'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKregexp_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKregexp = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_string_MIMARK_GTMARKregexp') then
                  trampCall(@_string_MIMARK_GTMARKregexp)
                else raise NameError.new( "Error: undefined variable _string_MIMARK_GTMARKregexp", "_string_MIMARK_GTMARKregexp" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1026"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKregexp_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKregexp_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKregexp_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKregexp_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_regexp_QUMARK') then
                  trampCall(@_regexp_QUMARK)
                else raise NameError.new( "Error: undefined variable _regexp_QUMARK", "_regexp_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1033"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKregexp_MIMARK_GTMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKregexp_MIMARK_GTMARKstring'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKregexp_MIMARK_GTMARKstring_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKregexp_MIMARK_GTMARKstring = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_regexp_MIMARK_GTMARKstring') then
                  trampCall(@_regexp_MIMARK_GTMARKstring)
                else raise NameError.new( "Error: undefined variable _regexp_MIMARK_GTMARKstring", "_regexp_MIMARK_GTMARKstring" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1036"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_rxmatch') then
                  trampCall(@_rxmatch)
                else raise NameError.new( "Error: undefined variable _rxmatch", "_rxmatch" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1086"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKstart_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKstart'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKstart_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKstart = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_rxmatch_MIMARKstart') then
                  trampCall(@_rxmatch_MIMARKstart)
                else raise NameError.new( "Error: undefined variable _rxmatch_MIMARKstart", "_rxmatch_MIMARKstart" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1044"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKend_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKend'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKend_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKend = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_rxmatch_MIMARKend') then
                  trampCall(@_rxmatch_MIMARKend)
                else raise NameError.new( "Error: undefined variable _rxmatch_MIMARKend", "_rxmatch_MIMARKend" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1048"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKsubstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKsubstring'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKsubstring_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKsubstring = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_rxmatch_MIMARKsubstring') then
                  trampCall(@_rxmatch_MIMARKsubstring)
                else raise NameError.new( "Error: undefined variable _rxmatch_MIMARKsubstring", "_rxmatch_MIMARKsubstring" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1063"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKnum_MIMARKmatches_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKnum_MIMARKmatches'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKnum_MIMARKmatches_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKnum_MIMARKmatches = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_rxmatch_MIMARKnum_MIMARKmatches') then
                  trampCall(@_rxmatch_MIMARKnum_MIMARKmatches)
                else raise NameError.new( "Error: undefined variable _rxmatch_MIMARKnum_MIMARKmatches", "_rxmatch_MIMARKnum_MIMARKmatches" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1056"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARK_GTMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARK_GTMARKstring'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARK_GTMARKstring_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARK_GTMARKstring = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_rxmatch_MIMARK_GTMARKstring') then
                  trampCall(@_rxmatch_MIMARK_GTMARKstring)
                else raise NameError.new( "Error: undefined variable _rxmatch_MIMARK_GTMARKstring", "_rxmatch_MIMARK_GTMARKstring" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1059"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKexport_MIMARKto_MIMARKruby_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKexport_MIMARKto_MIMARKruby'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKexport_MIMARKto_MIMARKruby_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKexport_MIMARKto_MIMARKruby = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_export_MIMARKto_MIMARKruby') then
                  trampCall(@_export_MIMARKto_MIMARKruby)
                else raise NameError.new( "Error: undefined variable _export_MIMARKto_MIMARKruby", "_export_MIMARKto_MIMARKruby" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1072"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKload_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKload'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKload_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKload = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_load') then
                  trampCall(@_load)
                else raise NameError.new( "Error: undefined variable _load", "_load" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1216"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKadd_MIMARKload_MIMARKpath_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKadd_MIMARKload_MIMARKpath'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKadd_MIMARKload_MIMARKpath_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKadd_MIMARKload_MIMARKpath = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_add_MIMARKload_MIMARKpath') then
                  trampCall(@_add_MIMARKload_MIMARKpath)
                else raise NameError.new( "Error: undefined variable _add_MIMARKload_MIMARKpath", "_add_MIMARKload_MIMARKpath" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1096"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKuse_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKuse'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKuse_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKuse = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_use') then
                  trampCall(@_use)
                else raise NameError.new( "Error: undefined variable _use", "_use" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1104"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKexport_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKexport'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKexport_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKexport = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_export') then
                  trampCall(@_export)
                else raise NameError.new( "Error: undefined variable _export", "_export" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1114"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKdefined_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKdefined_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKdefined_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKdefined_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_global_MIMARKdefined_QUMARK') then
                  trampCall(@_global_MIMARKdefined_QUMARK)
                else raise NameError.new( "Error: undefined variable _global_MIMARKdefined_QUMARK", "_global_MIMARKdefined_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1170"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKdisasm_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKdisasm'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKdisasm_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKdisasm = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_disasm') then
                  trampCall(@_disasm)
                else raise NameError.new( "Error: undefined variable _disasm", "_disasm" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1133"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKcompiled_MIMARKcode_MIMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKcompiled_MIMARKcode_MIMARKstring'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKcompiled_MIMARKcode_MIMARKstring_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKcompiled_MIMARKcode_MIMARKstring = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_compiled_MIMARKcode_MIMARKstring') then
                  trampCall(@_compiled_MIMARKcode_MIMARKstring)
                else raise NameError.new( "Error: undefined variable _compiled_MIMARKcode_MIMARKstring", "_compiled_MIMARKcode_MIMARKstring" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1180"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKprint_MIMARKcompiled_MIMARKcode_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKprint_MIMARKcompiled_MIMARKcode'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKprint_MIMARKcompiled_MIMARKcode_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKprint_MIMARKcompiled_MIMARKcode = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_print_MIMARKcompiled_MIMARKcode') then
                  trampCall(@_print_MIMARKcompiled_MIMARKcode)
                else raise NameError.new( "Error: undefined variable _print_MIMARKcompiled_MIMARKcode", "_print_MIMARKcompiled_MIMARKcode" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1177"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKsetup_MIMARKtailcall_MIMARKmark_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKsetup_MIMARKtailcall_MIMARKmark'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKsetup_MIMARKtailcall_MIMARKmark_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKsetup_MIMARKtailcall_MIMARKmark = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_setup_MIMARKtailcall_MIMARKmark') then
                  trampCall(@_setup_MIMARKtailcall_MIMARKmark)
                else raise NameError.new( "Error: undefined variable _setup_MIMARKtailcall_MIMARKmark", "_setup_MIMARKtailcall_MIMARKmark" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1375"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKsyntactic_MIMARKclosure_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKsyntactic_MIMARKclosure'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKsyntactic_MIMARKclosure_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKsyntactic_MIMARKclosure = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_make_MIMARKsyntactic_MIMARKclosure') then
                  trampCall(@_make_MIMARKsyntactic_MIMARKclosure)
                else raise NameError.new( "Error: undefined variable _make_MIMARKsyntactic_MIMARKclosure", "_make_MIMARKsyntactic_MIMARKclosure" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1381"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_identifier_QUMARK') then
                  trampCall(@_identifier_QUMARK)
                else raise NameError.new( "Error: undefined variable _identifier_QUMARK", "_identifier_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1388"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_EQMARK_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_EQMARK_QUMARK'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_EQMARK_QUMARK_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_EQMARK_QUMARK = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_identifier_EQMARK_QUMARK') then
                  trampCall(@_identifier_EQMARK_QUMARK)
                else raise NameError.new( "Error: undefined variable _identifier_EQMARK_QUMARK", "_identifier_EQMARK_QUMARK" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1391"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKall_MIMARKrenamed_MIMARKsymbols_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKall_MIMARKrenamed_MIMARKsymbols'] = self.method( :__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKall_MIMARKrenamed_MIMARKsymbols_METHOD )
        @__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKall_MIMARKrenamed_MIMARKsymbols = 
        trampCall(
              begin
                if @global_lisp_binding.has_key?('_define_MIMARKall_MIMARKrenamed_MIMARKsymbols') then
                  trampCall(@_define_MIMARKall_MIMARKrenamed_MIMARKsymbols)
                else raise NameError.new( "Error: undefined variable _define_MIMARKall_MIMARKrenamed_MIMARKsymbols", "_define_MIMARKall_MIMARKrenamed_MIMARKsymbols" ) end
                rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1426"] + __e.backtrace ) ; raise __e
              end
        )
      end
      begin
          def self.__PAMARKmacro_MIMARKenv_MIMARKsnapshot_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
          @global_lisp_binding['__PAMARKmacro_MIMARKenv_MIMARKsnapshot'] = self.method( :__PAMARKmacro_MIMARKenv_MIMARKsnapshot_METHOD )
        @__PAMARKmacro_MIMARKenv_MIMARKsnapshot = 
        trampCall(
              trampCall( self._list_METHOD(  'list',
                  begin
                    if @global_lisp_binding.has_key?('_list') then
                      trampCall(@_list)
                    else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                    rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                  end                ,
              [
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "gensym"                        ,
                        "/nendo/macroenv/gensym"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKgensym') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKgensym)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKgensym", "__SLMARKnendo_SLMARKmacroenv_SLMARKgensym" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "load-compiled-code-from-string"                        ,
                        "/nendo/macroenv/load-compiled-code-from-string"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKload_MIMARKcompiled_MIMARKcode_MIMARKfrom_MIMARKstring') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKload_MIMARKcompiled_MIMARKcode_MIMARKfrom_MIMARKstring)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKload_MIMARKcompiled_MIMARKcode_MIMARKfrom_MIMARKstring", "__SLMARKnendo_SLMARKmacroenv_SLMARKload_MIMARKcompiled_MIMARKcode_MIMARKfrom_MIMARKstring" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "clean-compiled-code"                        ,
                        "/nendo/macroenv/clean-compiled-code"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKclean_MIMARKcompiled_MIMARKcode') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKclean_MIMARKcompiled_MIMARKcode)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKclean_MIMARKcompiled_MIMARKcode", "__SLMARKnendo_SLMARKmacroenv_SLMARKclean_MIMARKcompiled_MIMARKcode" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "get-compiled-code"                        ,
                        "/nendo/macroenv/get-compiled-code"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKcompiled_MIMARKcode') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKcompiled_MIMARKcode)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKcompiled_MIMARKcode", "__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKcompiled_MIMARKcode" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "eval"                        ,
                        "/nendo/macroenv/eval"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKeval') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKeval)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKeval", "__SLMARKnendo_SLMARKmacroenv_SLMARKeval" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "enable-idebug"                        ,
                        "/nendo/macroenv/enable-idebug"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKidebug') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKidebug)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKidebug", "__SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKidebug" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "disable-idebug"                        ,
                        "/nendo/macroenv/disable-idebug"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKidebug') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKidebug)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKidebug", "__SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKidebug" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "enable-trace"                        ,
                        "/nendo/macroenv/enable-trace"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKtrace') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKtrace)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKtrace", "__SLMARKnendo_SLMARKmacroenv_SLMARKenable_MIMARKtrace" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "disable-trace"                        ,
                        "/nendo/macroenv/disable-trace"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKtrace') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKtrace)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKtrace", "__SLMARKnendo_SLMARKmacroenv_SLMARKdisable_MIMARKtrace" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "set-optimize-level"                        ,
                        "/nendo/macroenv/set-optimize-level"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKoptimize_MIMARKlevel') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKoptimize_MIMARKlevel)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKoptimize_MIMARKlevel", "__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKoptimize_MIMARKlevel" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "get-optimize-level"                        ,
                        "/nendo/macroenv/get-optimize-level"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptimize_MIMARKlevel') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptimize_MIMARKlevel)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptimize_MIMARKlevel", "__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptimize_MIMARKlevel" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "get-source-info"                        ,
                        "/nendo/macroenv/get-source-info"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKsource_MIMARKinfo') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKsource_MIMARKinfo)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKsource_MIMARKinfo", "__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKsource_MIMARKinfo" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "equal?"                        ,
                        "/nendo/macroenv/equal?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKequal_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKequal_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKequal_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKequal_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "quotient"                        ,
                        "/nendo/macroenv/quotient"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKquotient') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKquotient)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKquotient", "__SLMARKnendo_SLMARKmacroenv_SLMARKquotient" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "remainder"                        ,
                        "/nendo/macroenv/remainder"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKremainder') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKremainder)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKremainder", "__SLMARKnendo_SLMARKmacroenv_SLMARKremainder" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "modulo"                        ,
                        "/nendo/macroenv/modulo"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmodulo') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmodulo)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmodulo", "__SLMARKnendo_SLMARKmacroenv_SLMARKmodulo" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "not"                        ,
                        "/nendo/macroenv/not"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKnot') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKnot)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKnot", "__SLMARKnendo_SLMARKmacroenv_SLMARKnot" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cons"                        ,
                        "/nendo/macroenv/cons"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcons') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcons)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcons", "__SLMARKnendo_SLMARKmacroenv_SLMARKcons" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "set-car!"                        ,
                        "/nendo/macroenv/set-car!"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcar_EXMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcar_EXMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcar_EXMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcar_EXMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "set-cdr!"                        ,
                        "/nendo/macroenv/set-cdr!"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcdr_EXMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcdr_EXMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcdr_EXMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKset_MIMARKcdr_EXMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "exit"                        ,
                        "/nendo/macroenv/exit"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKexit') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKexit)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKexit", "__SLMARKnendo_SLMARKmacroenv_SLMARKexit" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "print"                        ,
                        "/nendo/macroenv/print"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKprint') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKprint)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKprint", "__SLMARKnendo_SLMARKmacroenv_SLMARKprint" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "printf"                        ,
                        "/nendo/macroenv/printf"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKprintf') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKprintf)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKprintf", "__SLMARKnendo_SLMARKmacroenv_SLMARKprintf" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "sprintf"                        ,
                        "/nendo/macroenv/sprintf"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKsprintf') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKsprintf)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKsprintf", "__SLMARKnendo_SLMARKmacroenv_SLMARKsprintf" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "null?"                        ,
                        "/nendo/macroenv/null?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKnull_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKnull_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKnull_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKnull_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "length"                        ,
                        "/nendo/macroenv/length"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKlength') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKlength)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKlength", "__SLMARKnendo_SLMARKmacroenv_SLMARKlength" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "list"                        ,
                        "/nendo/macroenv/list"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKlist') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKlist)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKlist", "__SLMARKnendo_SLMARKmacroenv_SLMARKlist" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "reverse"                        ,
                        "/nendo/macroenv/reverse"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKreverse') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKreverse)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKreverse", "__SLMARKnendo_SLMARKmacroenv_SLMARKreverse" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "uniq"                        ,
                        "/nendo/macroenv/uniq"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKuniq') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKuniq)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKuniq", "__SLMARKnendo_SLMARKmacroenv_SLMARKuniq" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "range"                        ,
                        "/nendo/macroenv/range"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKrange') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKrange)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKrange", "__SLMARKnendo_SLMARKmacroenv_SLMARKrange" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "eq?"                        ,
                        "/nendo/macroenv/eq?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKeq_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKeq_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKeq_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKeq_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "gt?"                        ,
                        "/nendo/macroenv/gt?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKgt_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKgt_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKgt_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKgt_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "ge?"                        ,
                        "/nendo/macroenv/ge?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKge_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKge_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKge_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKge_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "lt?"                        ,
                        "/nendo/macroenv/lt?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKlt_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKlt_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKlt_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKlt_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "le?"                        ,
                        "/nendo/macroenv/le?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKle_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKle_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKle_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKle_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "eqv?"                        ,
                        "/nendo/macroenv/eqv?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKeqv_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKeqv_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKeqv_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKeqv_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "car"                        ,
                        "/nendo/macroenv/car"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcar') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcar)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcar", "__SLMARKnendo_SLMARKmacroenv_SLMARKcar" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cdr"                        ,
                        "/nendo/macroenv/cdr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcdr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcdr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcdr", "__SLMARKnendo_SLMARKmacroenv_SLMARKcdr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "write"                        ,
                        "/nendo/macroenv/write"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKwrite') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKwrite)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKwrite", "__SLMARKnendo_SLMARKmacroenv_SLMARKwrite" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "write-to-string"                        ,
                        "/nendo/macroenv/write-to-string"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKwrite_MIMARKto_MIMARKstring') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKwrite_MIMARKto_MIMARKstring)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKwrite_MIMARKto_MIMARKstring", "__SLMARKnendo_SLMARKmacroenv_SLMARKwrite_MIMARKto_MIMARKstring" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "display"                        ,
                        "/nendo/macroenv/display"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKdisplay') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKdisplay)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKdisplay", "__SLMARKnendo_SLMARKmacroenv_SLMARKdisplay" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "newline"                        ,
                        "/nendo/macroenv/newline"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKnewline') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKnewline)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKnewline", "__SLMARKnendo_SLMARKmacroenv_SLMARKnewline" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "procedure?"                        ,
                        "/nendo/macroenv/procedure?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKprocedure_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKprocedure_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKprocedure_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKprocedure_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "macro?"                        ,
                        "/nendo/macroenv/macro?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmacro_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmacro_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmacro_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKmacro_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "symbol?"                        ,
                        "/nendo/macroenv/symbol?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "keyword?"                        ,
                        "/nendo/macroenv/keyword?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "syntax?"                        ,
                        "/nendo/macroenv/syntax?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "core-syntax?"                        ,
                        "/nendo/macroenv/core-syntax?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcore_MIMARKsyntax_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcore_MIMARKsyntax_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcore_MIMARKsyntax_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKcore_MIMARKsyntax_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "pair?"                        ,
                        "/nendo/macroenv/pair?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKpair_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKpair_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKpair_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKpair_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "integer?"                        ,
                        "/nendo/macroenv/integer?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKinteger_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKinteger_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKinteger_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKinteger_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "number?"                        ,
                        "/nendo/macroenv/number?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKnumber_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKnumber_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKnumber_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKnumber_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "string?"                        ,
                        "/nendo/macroenv/string?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKstring_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKstring_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKstring_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKstring_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "macroexpand-1"                        ,
                        "/nendo/macroenv/macroexpand-1"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand_MIMARK1') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand_MIMARK1)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand_MIMARK1", "__SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand_MIMARK1" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "to_s"                        ,
                        "/nendo/macroenv/to_s"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKto_s') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKto_s)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKto_s", "__SLMARKnendo_SLMARKmacroenv_SLMARKto_s" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "to-s"                        ,
                        "/nendo/macroenv/to-s"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKs') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKs)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKs", "__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKs" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "to_i"                        ,
                        "/nendo/macroenv/to_i"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKto_i') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKto_i)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKto_i", "__SLMARKnendo_SLMARKmacroenv_SLMARKto_i" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "to-i"                        ,
                        "/nendo/macroenv/to-i"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKi') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKi)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKi", "__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKi" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "nil?"                        ,
                        "/nendo/macroenv/nil?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKnil_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKnil_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKnil_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKnil_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "to_list"                        ,
                        "/nendo/macroenv/to_list"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKto_list') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKto_list)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKto_list", "__SLMARKnendo_SLMARKmacroenv_SLMARKto_list" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "to-list"                        ,
                        "/nendo/macroenv/to-list"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKlist') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKlist)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKlist", "__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKlist" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "to_arr"                        ,
                        "/nendo/macroenv/to_arr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKto_arr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKto_arr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKto_arr", "__SLMARKnendo_SLMARKmacroenv_SLMARKto_arr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "to-arr"                        ,
                        "/nendo/macroenv/to-arr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKarr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKarr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKarr", "__SLMARKnendo_SLMARKmacroenv_SLMARKto_MIMARKarr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "intern"                        ,
                        "/nendo/macroenv/intern"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKintern') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKintern)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKintern", "__SLMARKnendo_SLMARKmacroenv_SLMARKintern" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "string->symbol"                        ,
                        "/nendo/macroenv/string->symbol"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKsymbol') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKsymbol)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKsymbol", "__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKsymbol" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "symbol->string"                        ,
                        "/nendo/macroenv/symbol->string"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_MIMARK_GTMARKstring') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_MIMARK_GTMARKstring)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_MIMARK_GTMARKstring", "__SLMARKnendo_SLMARKmacroenv_SLMARKsymbol_MIMARK_GTMARKstring" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "string-join"                        ,
                        "/nendo/macroenv/string-join"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKjoin') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKjoin)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKjoin", "__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKjoin" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "require"                        ,
                        "/nendo/macroenv/require"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKrequire') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKrequire)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKrequire", "__SLMARKnendo_SLMARKmacroenv_SLMARKrequire" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "read-from-string"                        ,
                        "/nendo/macroenv/read-from-string"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKread_MIMARKfrom_MIMARKstring') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKread_MIMARKfrom_MIMARKstring)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKread_MIMARKfrom_MIMARKstring", "__SLMARKnendo_SLMARKmacroenv_SLMARKread_MIMARKfrom_MIMARKstring" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "read"                        ,
                        "/nendo/macroenv/read"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKread') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKread)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKread", "__SLMARKnendo_SLMARKmacroenv_SLMARKread" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "apply1"                        ,
                        "/nendo/macroenv/apply1"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKapply1') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKapply1)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKapply1", "__SLMARKnendo_SLMARKmacroenv_SLMARKapply1" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "global-variables"                        ,
                        "/nendo/macroenv/global-variables"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKvariables') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKvariables)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKvariables", "__SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKvariables" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "make-values"                        ,
                        "/nendo/macroenv/make-values"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvalues') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvalues)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvalues", "__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvalues" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "values?"                        ,
                        "/nendo/macroenv/values?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKvalues_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "values-values"                        ,
                        "/nendo/macroenv/values-values"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_MIMARKvalues') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_MIMARKvalues)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKvalues_MIMARKvalues", "__SLMARKnendo_SLMARKmacroenv_SLMARKvalues_MIMARKvalues" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "make-keyword"                        ,
                        "/nendo/macroenv/make-keyword"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKkeyword') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKkeyword)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKkeyword", "__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKkeyword" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "keyword->string"                        ,
                        "/nendo/macroenv/keyword->string"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_MIMARK_GTMARKstring') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_MIMARK_GTMARKstring)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_MIMARK_GTMARKstring", "__SLMARKnendo_SLMARKmacroenv_SLMARKkeyword_MIMARK_GTMARKstring" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "hash-table-get"                        ,
                        "/nendo/macroenv/hash-table-get"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKget') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKget)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKget", "__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKget" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "hash-table-put!"                        ,
                        "/nendo/macroenv/hash-table-put!"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKput_EXMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKput_EXMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKput_EXMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKput_EXMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "hash-table-exist?"                        ,
                        "/nendo/macroenv/hash-table-exist?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKexist_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKexist_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKexist_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKexist_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "raise"                        ,
                        "/nendo/macroenv/raise"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKraise') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKraise)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKraise", "__SLMARKnendo_SLMARKmacroenv_SLMARKraise" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "vector-set!"                        ,
                        "/nendo/macroenv/vector-set!"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKset_EXMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKset_EXMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKset_EXMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKset_EXMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "quote"                        ,
                        "/nendo/macroenv/quote"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKquote') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKquote)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKquote", "__SLMARKnendo_SLMARKmacroenv_SLMARKquote" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1312"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "syntax-quote"                        ,
                        "/nendo/macroenv/syntax-quote"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_MIMARKquote') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_MIMARKquote)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_MIMARKquote", "__SLMARKnendo_SLMARKmacroenv_SLMARKsyntax_MIMARKquote" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1314"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "if"                        ,
                        "/nendo/macroenv/if"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKif') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKif)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKif", "__SLMARKnendo_SLMARKmacroenv_SLMARKif" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1327"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "begin"                        ,
                        "/nendo/macroenv/begin"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKbegin') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKbegin)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKbegin", "__SLMARKnendo_SLMARKmacroenv_SLMARKbegin" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1320"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "lambda"                        ,
                        "/nendo/macroenv/lambda"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKlambda') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKlambda)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKlambda", "__SLMARKnendo_SLMARKmacroenv_SLMARKlambda" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1323"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "macro"                        ,
                        "/nendo/macroenv/macro"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmacro') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmacro)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmacro", "__SLMARKnendo_SLMARKmacroenv_SLMARKmacro" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1316"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "let"                        ,
                        "/nendo/macroenv/let"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKlet') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKlet)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKlet", "__SLMARKnendo_SLMARKmacroenv_SLMARKlet" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1338"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "letrec"                        ,
                        "/nendo/macroenv/letrec"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKletrec') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKletrec)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKletrec", "__SLMARKnendo_SLMARKmacroenv_SLMARKletrec" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1342"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "define"                        ,
                        "/nendo/macroenv/define"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKdefine') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKdefine)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKdefine", "__SLMARKnendo_SLMARKmacroenv_SLMARKdefine" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1346"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "set!"                        ,
                        "/nendo/macroenv/set!"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKset_EXMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKset_EXMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKset_EXMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKset_EXMARK" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1355"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "error"                        ,
                        "/nendo/macroenv/error"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKerror') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKerror)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKerror", "__SLMARKnendo_SLMARKmacroenv_SLMARKerror" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "define-syntax"                        ,
                        "/nendo/macroenv/define-syntax"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKsyntax') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKsyntax)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKsyntax", "__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKsyntax" ) end
                            rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1346"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "debug-print"                        ,
                        "/nendo/macroenv/debug-print"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint", "__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "caar"                        ,
                        "/nendo/macroenv/caar"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcaar') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcaar)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcaar", "__SLMARKnendo_SLMARKmacroenv_SLMARKcaar" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cadr"                        ,
                        "/nendo/macroenv/cadr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcadr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcadr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcadr", "__SLMARKnendo_SLMARKmacroenv_SLMARKcadr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cdar"                        ,
                        "/nendo/macroenv/cdar"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcdar') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcdar)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcdar", "__SLMARKnendo_SLMARKmacroenv_SLMARKcdar" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cddr"                        ,
                        "/nendo/macroenv/cddr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcddr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcddr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcddr", "__SLMARKnendo_SLMARKmacroenv_SLMARKcddr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "caaar"                        ,
                        "/nendo/macroenv/caaar"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcaaar') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcaaar)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcaaar", "__SLMARKnendo_SLMARKmacroenv_SLMARKcaaar" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "caadr"                        ,
                        "/nendo/macroenv/caadr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcaadr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcaadr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcaadr", "__SLMARKnendo_SLMARKmacroenv_SLMARKcaadr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cadar"                        ,
                        "/nendo/macroenv/cadar"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcadar') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcadar)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcadar", "__SLMARKnendo_SLMARKmacroenv_SLMARKcadar" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "caddr"                        ,
                        "/nendo/macroenv/caddr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcaddr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcaddr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcaddr", "__SLMARKnendo_SLMARKmacroenv_SLMARKcaddr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cdaar"                        ,
                        "/nendo/macroenv/cdaar"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcdaar') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcdaar)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcdaar", "__SLMARKnendo_SLMARKmacroenv_SLMARKcdaar" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cdadr"                        ,
                        "/nendo/macroenv/cdadr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcdadr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcdadr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcdadr", "__SLMARKnendo_SLMARKmacroenv_SLMARKcdadr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cddar"                        ,
                        "/nendo/macroenv/cddar"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcddar') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcddar)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcddar", "__SLMARKnendo_SLMARKmacroenv_SLMARKcddar" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cdddr"                        ,
                        "/nendo/macroenv/cdddr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcdddr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcdddr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcdddr", "__SLMARKnendo_SLMARKmacroenv_SLMARKcdddr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "caaaar"                        ,
                        "/nendo/macroenv/caaaar"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcaaaar') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcaaaar)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcaaaar", "__SLMARKnendo_SLMARKmacroenv_SLMARKcaaaar" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "caaadr"                        ,
                        "/nendo/macroenv/caaadr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcaaadr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcaaadr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcaaadr", "__SLMARKnendo_SLMARKmacroenv_SLMARKcaaadr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "caadar"                        ,
                        "/nendo/macroenv/caadar"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcaadar') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcaadar)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcaadar", "__SLMARKnendo_SLMARKmacroenv_SLMARKcaadar" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "caaddr"                        ,
                        "/nendo/macroenv/caaddr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcaaddr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcaaddr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcaaddr", "__SLMARKnendo_SLMARKmacroenv_SLMARKcaaddr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cadaar"                        ,
                        "/nendo/macroenv/cadaar"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcadaar') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcadaar)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcadaar", "__SLMARKnendo_SLMARKmacroenv_SLMARKcadaar" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cadadr"                        ,
                        "/nendo/macroenv/cadadr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcadadr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcadadr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcadadr", "__SLMARKnendo_SLMARKmacroenv_SLMARKcadadr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "caddar"                        ,
                        "/nendo/macroenv/caddar"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcaddar') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcaddar)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcaddar", "__SLMARKnendo_SLMARKmacroenv_SLMARKcaddar" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cadddr"                        ,
                        "/nendo/macroenv/cadddr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcadddr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcadddr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcadddr", "__SLMARKnendo_SLMARKmacroenv_SLMARKcadddr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cdaaar"                        ,
                        "/nendo/macroenv/cdaaar"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcdaaar') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcdaaar)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcdaaar", "__SLMARKnendo_SLMARKmacroenv_SLMARKcdaaar" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cdaadr"                        ,
                        "/nendo/macroenv/cdaadr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcdaadr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcdaadr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcdaadr", "__SLMARKnendo_SLMARKmacroenv_SLMARKcdaadr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cdadar"                        ,
                        "/nendo/macroenv/cdadar"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcdadar') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcdadar)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcdadar", "__SLMARKnendo_SLMARKmacroenv_SLMARKcdadar" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cdaddr"                        ,
                        "/nendo/macroenv/cdaddr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcdaddr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcdaddr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcdaddr", "__SLMARKnendo_SLMARKmacroenv_SLMARKcdaddr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cddaar"                        ,
                        "/nendo/macroenv/cddaar"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcddaar') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcddaar)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcddaar", "__SLMARKnendo_SLMARKmacroenv_SLMARKcddaar" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cddadr"                        ,
                        "/nendo/macroenv/cddadr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcddadr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcddadr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcddadr", "__SLMARKnendo_SLMARKmacroenv_SLMARKcddadr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cdddar"                        ,
                        "/nendo/macroenv/cdddar"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcdddar') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcdddar)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcdddar", "__SLMARKnendo_SLMARKmacroenv_SLMARKcdddar" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cddddr"                        ,
                        "/nendo/macroenv/cddddr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcddddr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcddddr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcddddr", "__SLMARKnendo_SLMARKmacroenv_SLMARKcddddr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "iota"                        ,
                        "/nendo/macroenv/iota"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKiota') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKiota)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKiota", "__SLMARKnendo_SLMARKmacroenv_SLMARKiota" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "append"                        ,
                        "/nendo/macroenv/append"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKappend') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKappend)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKappend", "__SLMARKnendo_SLMARKmacroenv_SLMARKappend" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "vector"                        ,
                        "/nendo/macroenv/vector"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKvector') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKvector)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKvector", "__SLMARKnendo_SLMARKmacroenv_SLMARKvector" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "list?"                        ,
                        "/nendo/macroenv/list?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKlist_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKlist_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKlist_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKlist_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "even?"                        ,
                        "/nendo/macroenv/even?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKeven_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKeven_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKeven_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKeven_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "odd?"                        ,
                        "/nendo/macroenv/odd?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKodd_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKodd_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKodd_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKodd_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "zero?"                        ,
                        "/nendo/macroenv/zero?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKzero_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKzero_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKzero_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKzero_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "positive?"                        ,
                        "/nendo/macroenv/positive?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKpositive_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKpositive_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKpositive_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKpositive_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "negative?"                        ,
                        "/nendo/macroenv/negative?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKnegative_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKnegative_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKnegative_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKnegative_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "abs"                        ,
                        "/nendo/macroenv/abs"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKabs') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKabs)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKabs", "__SLMARKnendo_SLMARKmacroenv_SLMARKabs" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "max"                        ,
                        "/nendo/macroenv/max"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmax') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmax)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmax", "__SLMARKnendo_SLMARKmacroenv_SLMARKmax" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "min"                        ,
                        "/nendo/macroenv/min"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmin') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmin)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmin", "__SLMARKnendo_SLMARKmacroenv_SLMARKmin" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "succ"                        ,
                        "/nendo/macroenv/succ"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKsucc') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKsucc)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKsucc", "__SLMARKnendo_SLMARKmacroenv_SLMARKsucc" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "pred"                        ,
                        "/nendo/macroenv/pred"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKpred') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKpred)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKpred", "__SLMARKnendo_SLMARKmacroenv_SLMARKpred" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "nth"                        ,
                        "/nendo/macroenv/nth"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKnth') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKnth)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKnth", "__SLMARKnendo_SLMARKmacroenv_SLMARKnth" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "first"                        ,
                        "/nendo/macroenv/first"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKfirst') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKfirst)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKfirst", "__SLMARKnendo_SLMARKmacroenv_SLMARKfirst" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "second"                        ,
                        "/nendo/macroenv/second"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKsecond') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKsecond)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKsecond", "__SLMARKnendo_SLMARKmacroenv_SLMARKsecond" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "third"                        ,
                        "/nendo/macroenv/third"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKthird') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKthird)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKthird", "__SLMARKnendo_SLMARKmacroenv_SLMARKthird" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "fourth"                        ,
                        "/nendo/macroenv/fourth"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKfourth') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKfourth)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKfourth", "__SLMARKnendo_SLMARKmacroenv_SLMARKfourth" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "fifth"                        ,
                        "/nendo/macroenv/fifth"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKfifth') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKfifth)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKfifth", "__SLMARKnendo_SLMARKmacroenv_SLMARKfifth" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "sixth"                        ,
                        "/nendo/macroenv/sixth"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKsixth') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKsixth)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKsixth", "__SLMARKnendo_SLMARKmacroenv_SLMARKsixth" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "seventh"                        ,
                        "/nendo/macroenv/seventh"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKseventh') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKseventh)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKseventh", "__SLMARKnendo_SLMARKmacroenv_SLMARKseventh" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "eighth"                        ,
                        "/nendo/macroenv/eighth"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKeighth') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKeighth)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKeighth", "__SLMARKnendo_SLMARKmacroenv_SLMARKeighth" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "ninth"                        ,
                        "/nendo/macroenv/ninth"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKninth') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKninth)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKninth", "__SLMARKnendo_SLMARKmacroenv_SLMARKninth" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "tenth"                        ,
                        "/nendo/macroenv/tenth"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKtenth') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKtenth)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKtenth", "__SLMARKnendo_SLMARKmacroenv_SLMARKtenth" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "x->string"                        ,
                        "/nendo/macroenv/x->string"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKx_MIMARK_GTMARKstring') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKx_MIMARK_GTMARKstring)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKx_MIMARK_GTMARKstring", "__SLMARKnendo_SLMARKmacroenv_SLMARKx_MIMARK_GTMARKstring" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "number->string"                        ,
                        "/nendo/macroenv/number->string"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKnumber_MIMARK_GTMARKstring') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKnumber_MIMARK_GTMARKstring)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKnumber_MIMARK_GTMARKstring", "__SLMARKnendo_SLMARKmacroenv_SLMARKnumber_MIMARK_GTMARKstring" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "string-append"                        ,
                        "/nendo/macroenv/string-append"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKappend') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKappend)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKappend", "__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKappend" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "macroexpand"                        ,
                        "/nendo/macroenv/macroexpand"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand", "__SLMARKnendo_SLMARKmacroenv_SLMARKmacroexpand" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "feedto"                        ,
                        "/nendo/macroenv/feedto"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKfeedto') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKfeedto)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKfeedto", "__SLMARKnendo_SLMARKmacroenv_SLMARKfeedto" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cond"                        ,
                        "/nendo/macroenv/cond"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcond') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcond)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcond", "__SLMARKnendo_SLMARKmacroenv_SLMARKcond" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "let1"                        ,
                        "/nendo/macroenv/let1"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKlet1') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKlet1)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKlet1", "__SLMARKnendo_SLMARKmacroenv_SLMARKlet1" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "or"                        ,
                        "/nendo/macroenv/or"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKor') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKor)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKor", "__SLMARKnendo_SLMARKmacroenv_SLMARKor" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "and"                        ,
                        "/nendo/macroenv/and"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKand') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKand)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKand", "__SLMARKnendo_SLMARKmacroenv_SLMARKand" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "apply"                        ,
                        "/nendo/macroenv/apply"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKapply') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKapply)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKapply", "__SLMARKnendo_SLMARKmacroenv_SLMARKapply" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "quasiquote"                        ,
                        "/nendo/macroenv/quasiquote"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKquasiquote') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKquasiquote)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKquasiquote", "__SLMARKnendo_SLMARKmacroenv_SLMARKquasiquote" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "unquote"                        ,
                        "/nendo/macroenv/unquote"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKunquote') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKunquote)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKunquote", "__SLMARKnendo_SLMARKmacroenv_SLMARKunquote" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "unquote-splicing"                        ,
                        "/nendo/macroenv/unquote-splicing"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKunquote_MIMARKsplicing') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKunquote_MIMARKsplicing)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKunquote_MIMARKsplicing", "__SLMARKnendo_SLMARKmacroenv_SLMARKunquote_MIMARKsplicing" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "when"                        ,
                        "/nendo/macroenv/when"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKwhen') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKwhen)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKwhen", "__SLMARKnendo_SLMARKmacroenv_SLMARKwhen" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "unless"                        ,
                        "/nendo/macroenv/unless"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKunless') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKunless)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKunless", "__SLMARKnendo_SLMARKmacroenv_SLMARKunless" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "while"                        ,
                        "/nendo/macroenv/while"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKwhile') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKwhile)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKwhile", "__SLMARKnendo_SLMARKmacroenv_SLMARKwhile" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "until"                        ,
                        "/nendo/macroenv/until"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKuntil') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKuntil)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKuntil", "__SLMARKnendo_SLMARKmacroenv_SLMARKuntil" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "if-let1"                        ,
                        "/nendo/macroenv/if-let1"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKif_MIMARKlet1') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKif_MIMARKlet1)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKif_MIMARKlet1", "__SLMARKnendo_SLMARKmacroenv_SLMARKif_MIMARKlet1" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "errorf"                        ,
                        "/nendo/macroenv/errorf"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKerrorf') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKerrorf)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKerrorf", "__SLMARKnendo_SLMARKmacroenv_SLMARKerrorf" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "get-optional"                        ,
                        "/nendo/macroenv/get-optional"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptional') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptional)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptional", "__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKoptional" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "check-arg"                        ,
                        "/nendo/macroenv/check-arg"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcheck_MIMARKarg') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcheck_MIMARKarg)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcheck_MIMARKarg", "__SLMARKnendo_SLMARKmacroenv_SLMARKcheck_MIMARKarg" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "do"                        ,
                        "/nendo/macroenv/do"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKdo') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKdo)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKdo", "__SLMARKnendo_SLMARKmacroenv_SLMARKdo" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "generic-member"                        ,
                        "/nendo/macroenv/generic-member"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKmember') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKmember)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKmember", "__SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKmember" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "memq"                        ,
                        "/nendo/macroenv/memq"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmemq') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmemq)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmemq", "__SLMARKnendo_SLMARKmacroenv_SLMARKmemq" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "memv"                        ,
                        "/nendo/macroenv/memv"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmemv') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmemv)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmemv", "__SLMARKnendo_SLMARKmacroenv_SLMARKmemv" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "member"                        ,
                        "/nendo/macroenv/member"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmember') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmember)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmember", "__SLMARKnendo_SLMARKmacroenv_SLMARKmember" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "generic-assoc"                        ,
                        "/nendo/macroenv/generic-assoc"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKassoc') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKassoc)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKassoc", "__SLMARKnendo_SLMARKmacroenv_SLMARKgeneric_MIMARKassoc" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "assq"                        ,
                        "/nendo/macroenv/assq"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKassq') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKassq)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKassq", "__SLMARKnendo_SLMARKmacroenv_SLMARKassq" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "assv"                        ,
                        "/nendo/macroenv/assv"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKassv') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKassv)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKassv", "__SLMARKnendo_SLMARKmacroenv_SLMARKassv" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "assoc"                        ,
                        "/nendo/macroenv/assoc"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKassoc') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKassoc)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKassoc", "__SLMARKnendo_SLMARKmacroenv_SLMARKassoc" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "acons"                        ,
                        "/nendo/macroenv/acons"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKacons') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKacons)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKacons", "__SLMARKnendo_SLMARKmacroenv_SLMARKacons" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "assq-ref"                        ,
                        "/nendo/macroenv/assq-ref"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKassq_MIMARKref') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKassq_MIMARKref)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKassq_MIMARKref", "__SLMARKnendo_SLMARKmacroenv_SLMARKassq_MIMARKref" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "assv-ref"                        ,
                        "/nendo/macroenv/assv-ref"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKassv_MIMARKref') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKassv_MIMARKref)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKassv_MIMARKref", "__SLMARKnendo_SLMARKmacroenv_SLMARKassv_MIMARKref" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "assoc-ref"                        ,
                        "/nendo/macroenv/assoc-ref"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKassoc_MIMARKref') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKassoc_MIMARKref)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKassoc_MIMARKref", "__SLMARKnendo_SLMARKmacroenv_SLMARKassoc_MIMARKref" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "fold-right"                        ,
                        "/nendo/macroenv/fold-right"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKfold_MIMARKright') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKfold_MIMARKright)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKfold_MIMARKright", "__SLMARKnendo_SLMARKmacroenv_SLMARKfold_MIMARKright" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "unzip1-with-cdr"                        ,
                        "/nendo/macroenv/unzip1-with-cdr"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr", "__SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "unzip1-with-cdr-iterative"                        ,
                        "/nendo/macroenv/unzip1-with-cdr-iterative"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr_MIMARKiterative') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr_MIMARKiterative)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr_MIMARKiterative", "__SLMARKnendo_SLMARKmacroenv_SLMARKunzip1_MIMARKwith_MIMARKcdr_MIMARKiterative" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "find"                        ,
                        "/nendo/macroenv/find"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKfind') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKfind)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKfind", "__SLMARKnendo_SLMARKmacroenv_SLMARKfind" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "any"                        ,
                        "/nendo/macroenv/any"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKany') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKany)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKany", "__SLMARKnendo_SLMARKmacroenv_SLMARKany" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "map"                        ,
                        "/nendo/macroenv/map"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmap') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmap)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmap", "__SLMARKnendo_SLMARKmacroenv_SLMARKmap" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "for-each"                        ,
                        "/nendo/macroenv/for-each"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKfor_MIMARKeach') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKfor_MIMARKeach)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKfor_MIMARKeach", "__SLMARKnendo_SLMARKmacroenv_SLMARKfor_MIMARKeach" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "filter"                        ,
                        "/nendo/macroenv/filter"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKfilter') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKfilter)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKfilter", "__SLMARKnendo_SLMARKmacroenv_SLMARKfilter" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "filter-map"                        ,
                        "/nendo/macroenv/filter-map"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKfilter_MIMARKmap') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKfilter_MIMARKmap)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKfilter_MIMARKmap", "__SLMARKnendo_SLMARKmacroenv_SLMARKfilter_MIMARKmap" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "case"                        ,
                        "/nendo/macroenv/case"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcase') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcase)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcase", "__SLMARKnendo_SLMARKmacroenv_SLMARKcase" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "let*"                        ,
                        "/nendo/macroenv/let*"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKlet_ASMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKlet_ASMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKlet_ASMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKlet_ASMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "begin0"                        ,
                        "/nendo/macroenv/begin0"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKbegin0') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKbegin0)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKbegin0", "__SLMARKnendo_SLMARKmacroenv_SLMARKbegin0" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "values"                        ,
                        "/nendo/macroenv/values"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKvalues') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKvalues)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKvalues", "__SLMARKnendo_SLMARKmacroenv_SLMARKvalues" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "call-with-values"                        ,
                        "/nendo/macroenv/call-with-values"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcall_MIMARKwith_MIMARKvalues') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcall_MIMARKwith_MIMARKvalues)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcall_MIMARKwith_MIMARKvalues", "__SLMARKnendo_SLMARKmacroenv_SLMARKcall_MIMARKwith_MIMARKvalues" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "receive"                        ,
                        "/nendo/macroenv/receive"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKreceive') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKreceive)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKreceive", "__SLMARKnendo_SLMARKmacroenv_SLMARKreceive" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "get-keyword"                        ,
                        "/nendo/macroenv/get-keyword"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKkeyword') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKkeyword)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKkeyword", "__SLMARKnendo_SLMARKmacroenv_SLMARKget_MIMARKkeyword" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "dot-operator"                        ,
                        "/nendo/macroenv/dot-operator"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKdot_MIMARKoperator') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKdot_MIMARKoperator)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKdot_MIMARKoperator", "__SLMARKnendo_SLMARKmacroenv_SLMARKdot_MIMARKoperator" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "with-open"                        ,
                        "/nendo/macroenv/with-open"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKwith_MIMARKopen') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKwith_MIMARKopen)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKwith_MIMARKopen", "__SLMARKnendo_SLMARKmacroenv_SLMARKwith_MIMARKopen" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "last-pair"                        ,
                        "/nendo/macroenv/last-pair"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKlast_MIMARKpair') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKlast_MIMARKpair)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKlast_MIMARKpair", "__SLMARKnendo_SLMARKmacroenv_SLMARKlast_MIMARKpair" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "cons*"                        ,
                        "/nendo/macroenv/cons*"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcons_ASMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcons_ASMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcons_ASMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKcons_ASMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "list*"                        ,
                        "/nendo/macroenv/list*"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKlist_ASMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKlist_ASMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKlist_ASMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKlist_ASMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "make-hash-table"                        ,
                        "/nendo/macroenv/make-hash-table"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKhash_MIMARKtable') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKhash_MIMARKtable)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKhash_MIMARKtable", "__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKhash_MIMARKtable" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "hash-table?"                        ,
                        "/nendo/macroenv/hash-table?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "hash-table-num-entries"                        ,
                        "/nendo/macroenv/hash-table-num-entries"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKnum_MIMARKentries') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKnum_MIMARKentries)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKnum_MIMARKentries", "__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKnum_MIMARKentries" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "hash-table"                        ,
                        "/nendo/macroenv/hash-table"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable", "__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "hash-table-clear!"                        ,
                        "/nendo/macroenv/hash-table-clear!"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKclear_EXMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKclear_EXMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKclear_EXMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKclear_EXMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "hash-table-delete!"                        ,
                        "/nendo/macroenv/hash-table-delete!"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKdelete_EXMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKdelete_EXMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKdelete_EXMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKdelete_EXMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "hash-table-push!"                        ,
                        "/nendo/macroenv/hash-table-push!"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKpush_EXMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKpush_EXMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKpush_EXMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKpush_EXMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "hash-table-keys"                        ,
                        "/nendo/macroenv/hash-table-keys"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKkeys') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKkeys)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKkeys", "__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKkeys" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "hash-table-values"                        ,
                        "/nendo/macroenv/hash-table-values"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKvalues') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKvalues)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKvalues", "__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKvalues" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "hash-table-map"                        ,
                        "/nendo/macroenv/hash-table-map"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKmap') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKmap)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKmap", "__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKmap" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "hash-table-for-each"                        ,
                        "/nendo/macroenv/hash-table-for-each"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKfor_MIMARKeach') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKfor_MIMARKeach)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKfor_MIMARKeach", "__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARKfor_MIMARKeach" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "hash-table->alist"                        ,
                        "/nendo/macroenv/hash-table->alist"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARK_GTMARKalist') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARK_GTMARKalist)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARK_GTMARKalist", "__SLMARKnendo_SLMARKmacroenv_SLMARKhash_MIMARKtable_MIMARK_GTMARKalist" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "alist->hash-table"                        ,
                        "/nendo/macroenv/alist->hash-table"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKalist_MIMARK_GTMARKhash_MIMARKtable') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKalist_MIMARK_GTMARKhash_MIMARKtable)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKalist_MIMARK_GTMARKhash_MIMARKtable", "__SLMARKnendo_SLMARKmacroenv_SLMARKalist_MIMARK_GTMARKhash_MIMARKtable" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "vector?"                        ,
                        "/nendo/macroenv/vector?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKvector_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKvector_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKvector_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKvector_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "make-vector"                        ,
                        "/nendo/macroenv/make-vector"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvector') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvector)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvector", "__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKvector" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "vector-length"                        ,
                        "/nendo/macroenv/vector-length"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKlength') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKlength)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKlength", "__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKlength" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "vector-copy"                        ,
                        "/nendo/macroenv/vector-copy"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKcopy') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKcopy)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKcopy", "__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKcopy" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "vector-ref"                        ,
                        "/nendo/macroenv/vector-ref"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKref') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKref)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKref", "__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKref" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "vector-equal?"                        ,
                        "/nendo/macroenv/vector-equal?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKequal_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKequal_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKequal_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKequal_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "list->vector"                        ,
                        "/nendo/macroenv/list->vector"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKlist_MIMARK_GTMARKvector') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKlist_MIMARK_GTMARKvector)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKlist_MIMARK_GTMARKvector", "__SLMARKnendo_SLMARKmacroenv_SLMARKlist_MIMARK_GTMARKvector" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "vector-fill!"                        ,
                        "/nendo/macroenv/vector-fill!"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKfill_EXMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKfill_EXMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKfill_EXMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARKfill_EXMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "vector->list"                        ,
                        "/nendo/macroenv/vector->list"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARK_GTMARKlist') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARK_GTMARKlist)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARK_GTMARKlist", "__SLMARKnendo_SLMARKmacroenv_SLMARKvector_MIMARK_GTMARKlist" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "debug-print-length"                        ,
                        "/nendo/macroenv/debug-print-length"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKlength') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKlength)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKlength", "__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKlength" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "debug-print-output-func"                        ,
                        "/nendo/macroenv/debug-print-output-func"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKoutput_MIMARKfunc') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKoutput_MIMARKfunc)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKoutput_MIMARKfunc", "__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKprint_MIMARKoutput_MIMARKfunc" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "debug-limit-length"                        ,
                        "/nendo/macroenv/debug-limit-length"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKlimit_MIMARKlength') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKlimit_MIMARKlength)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKlimit_MIMARKlength", "__SLMARKnendo_SLMARKmacroenv_SLMARKdebug_MIMARKlimit_MIMARKlength" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "pretty-print"                        ,
                        "/nendo/macroenv/pretty-print"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint", "__SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "pretty-print-to-string"                        ,
                        "/nendo/macroenv/pretty-print-to-string"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint_MIMARKto_MIMARKstring') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint_MIMARKto_MIMARKstring)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint_MIMARKto_MIMARKstring", "__SLMARKnendo_SLMARKmacroenv_SLMARKpretty_MIMARKprint_MIMARKto_MIMARKstring" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "sort"                        ,
                        "/nendo/macroenv/sort"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKsort') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKsort)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKsort", "__SLMARKnendo_SLMARKmacroenv_SLMARKsort" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "sort-by"                        ,
                        "/nendo/macroenv/sort-by"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKsort_MIMARKby') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKsort_MIMARKby)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKsort_MIMARKby", "__SLMARKnendo_SLMARKmacroenv_SLMARKsort_MIMARKby" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "string-length"                        ,
                        "/nendo/macroenv/string-length"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKlength') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKlength)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKlength", "__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARKlength" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "string->regexp"                        ,
                        "/nendo/macroenv/string->regexp"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKregexp') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKregexp)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKregexp", "__SLMARKnendo_SLMARKmacroenv_SLMARKstring_MIMARK_GTMARKregexp" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "regexp?"                        ,
                        "/nendo/macroenv/regexp?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKregexp_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKregexp_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKregexp_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKregexp_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "regexp->string"                        ,
                        "/nendo/macroenv/regexp->string"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKregexp_MIMARK_GTMARKstring') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKregexp_MIMARK_GTMARKstring)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKregexp_MIMARK_GTMARKstring", "__SLMARKnendo_SLMARKmacroenv_SLMARKregexp_MIMARK_GTMARKstring" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "rxmatch"                        ,
                        "/nendo/macroenv/rxmatch"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch", "__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "rxmatch-start"                        ,
                        "/nendo/macroenv/rxmatch-start"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKstart') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKstart)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKstart", "__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKstart" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "rxmatch-end"                        ,
                        "/nendo/macroenv/rxmatch-end"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKend') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKend)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKend", "__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKend" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "rxmatch-substring"                        ,
                        "/nendo/macroenv/rxmatch-substring"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKsubstring') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKsubstring)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKsubstring", "__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKsubstring" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "rxmatch-num-matches"                        ,
                        "/nendo/macroenv/rxmatch-num-matches"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKnum_MIMARKmatches') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKnum_MIMARKmatches)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKnum_MIMARKmatches", "__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARKnum_MIMARKmatches" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "rxmatch->string"                        ,
                        "/nendo/macroenv/rxmatch->string"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARK_GTMARKstring') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARK_GTMARKstring)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARK_GTMARKstring", "__SLMARKnendo_SLMARKmacroenv_SLMARKrxmatch_MIMARK_GTMARKstring" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "export-to-ruby"                        ,
                        "/nendo/macroenv/export-to-ruby"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKexport_MIMARKto_MIMARKruby') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKexport_MIMARKto_MIMARKruby)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKexport_MIMARKto_MIMARKruby", "__SLMARKnendo_SLMARKmacroenv_SLMARKexport_MIMARKto_MIMARKruby" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "load"                        ,
                        "/nendo/macroenv/load"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKload') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKload)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKload", "__SLMARKnendo_SLMARKmacroenv_SLMARKload" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "add-load-path"                        ,
                        "/nendo/macroenv/add-load-path"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKadd_MIMARKload_MIMARKpath') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKadd_MIMARKload_MIMARKpath)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKadd_MIMARKload_MIMARKpath", "__SLMARKnendo_SLMARKmacroenv_SLMARKadd_MIMARKload_MIMARKpath" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "use"                        ,
                        "/nendo/macroenv/use"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKuse') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKuse)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKuse", "__SLMARKnendo_SLMARKmacroenv_SLMARKuse" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "export"                        ,
                        "/nendo/macroenv/export"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKexport') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKexport)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKexport", "__SLMARKnendo_SLMARKmacroenv_SLMARKexport" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "global-defined?"                        ,
                        "/nendo/macroenv/global-defined?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKdefined_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKdefined_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKdefined_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKglobal_MIMARKdefined_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "disasm"                        ,
                        "/nendo/macroenv/disasm"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKdisasm') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKdisasm)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKdisasm", "__SLMARKnendo_SLMARKmacroenv_SLMARKdisasm" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "compiled-code-string"                        ,
                        "/nendo/macroenv/compiled-code-string"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKcompiled_MIMARKcode_MIMARKstring') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKcompiled_MIMARKcode_MIMARKstring)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKcompiled_MIMARKcode_MIMARKstring", "__SLMARKnendo_SLMARKmacroenv_SLMARKcompiled_MIMARKcode_MIMARKstring" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "print-compiled-code"                        ,
                        "/nendo/macroenv/print-compiled-code"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKprint_MIMARKcompiled_MIMARKcode') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKprint_MIMARKcompiled_MIMARKcode)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKprint_MIMARKcompiled_MIMARKcode", "__SLMARKnendo_SLMARKmacroenv_SLMARKprint_MIMARKcompiled_MIMARKcode" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "setup-tailcall-mark"                        ,
                        "/nendo/macroenv/setup-tailcall-mark"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKsetup_MIMARKtailcall_MIMARKmark') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKsetup_MIMARKtailcall_MIMARKmark)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKsetup_MIMARKtailcall_MIMARKmark", "__SLMARKnendo_SLMARKmacroenv_SLMARKsetup_MIMARKtailcall_MIMARKmark" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "make-syntactic-closure"                        ,
                        "/nendo/macroenv/make-syntactic-closure"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKsyntactic_MIMARKclosure') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKsyntactic_MIMARKclosure)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKsyntactic_MIMARKclosure", "__SLMARKnendo_SLMARKmacroenv_SLMARKmake_MIMARKsyntactic_MIMARKclosure" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "identifier?"                        ,
                        "/nendo/macroenv/identifier?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "identifier=?"                        ,
                        "/nendo/macroenv/identifier=?"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_EQMARK_QUMARK') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_EQMARK_QUMARK)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_EQMARK_QUMARK", "__SLMARKnendo_SLMARKmacroenv_SLMARKidentifier_EQMARK_QUMARK" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))                  ,
                    trampCall( self._list_METHOD(  'list',
                        begin
                          if @global_lisp_binding.has_key?('_list') then
                            trampCall(@_list)
                          else raise NameError.new( "Error: undefined variable _list", "_list" ) end
                          rescue => __e ; __e.set_backtrace( ["./lib/init.nnd:1417"] + __e.backtrace ) ; raise __e
                        end                      ,
                    [
                        "define-all-renamed-symbols"                        ,
                        "/nendo/macroenv/define-all-renamed-symbols"                        ,
                          begin
                            if @global_lisp_binding.has_key?('__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKall_MIMARKrenamed_MIMARKsymbols') then
                              trampCall(@__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKall_MIMARKrenamed_MIMARKsymbols)
                            else raise NameError.new( "Error: undefined variable __SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKall_MIMARKrenamed_MIMARKsymbols", "__SLMARKnendo_SLMARKmacroenv_SLMARKdefine_MIMARKall_MIMARKrenamed_MIMARKsymbols" ) end
                            rescue => __e ; __e.set_backtrace( [":1"] + __e.backtrace ) ; raise __e
                          end
                    ]
                                 ))
              ]
                           ))
        )
      end
  end
 )


# -------------------------------------------------------
# [EOF]
# -------------------------------------------------------
