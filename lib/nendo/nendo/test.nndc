#
#    This file is nendo's compiled library file. 
#    generated  "nendo -c src" command. 
# 

trampCall( 
  begin #execFunc
      def self._test_MIMARKerror_QUMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_test_MIMARKerror_QUMARK', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_test_MIMARKerror_QUMARK'] = self.method( :_test_MIMARKerror_QUMARK_METHOD )
    @_test_MIMARKerror_QUMARK = 
    trampCall(
          Proc.new { |_obj| 
              trampCall(_obj).is_a?(
                    trampCall(Nendo::NendoTestError)
                )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._test_MIMARKerror_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_test_MIMARKerror', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_test_MIMARKerror'] = self.method( :_test_MIMARKerror_METHOD )
    @_test_MIMARKerror = 
    trampCall(
          Proc.new { |*__rest__| _maybe_MIMARKclass = __rest__[0] ;  
              begin #makeLet
                ___lambda = lambda { |_cl,_err| 
                    if ( 
                      trampCall(_cl)
                     ) then
                          begin #execFunc
                            
                            _err.type = 
                            trampCall(
                                  trampCall(_cl)
                            )
                          end
                    end
                    trampCall(_err)
                } ; ___lambda.call(
                      begin #makeLet
                        ___lambda = lambda { |___gensym__5d616449e4cd5ff7562e60dbfcf1c628e32cc41d_30178| 
                            if ( 
                                _null_QUMARK(
                                    trampCall(___gensym__5d616449e4cd5ff7562e60dbfcf1c628e32cc41d_30178)
                                )
                             ) then
                              false
                            else
                                  delayCall( '_car',  'car',
                                      trampCall(@_car)                                    ,
                                  [
                                        trampCall(___gensym__5d616449e4cd5ff7562e60dbfcf1c628e32cc41d_30178)
                                  ]
                                               )
                            end
                        } ; ___lambda.call(
                              trampCall(_maybe_MIMARKclass)
                                   )
                      end                    ,
                      trampCall(Nendo::NendoTestError).new(
                        )
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._test_MIMARKcheck_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_test_MIMARKcheck', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_test_MIMARKcheck'] = self.method( :_test_MIMARKcheck_METHOD )
    @_test_MIMARKcheck = 
    trampCall(
          Proc.new { |_expected,_result| 
              if ( 
                  trampCall( self._test_MIMARKerror_QUMARK_METHOD(  'test-error?',
                      trampCall(@_test_MIMARKerror_QUMARK)                    ,
                  [
                        trampCall(_expected)
                  ]
                               ))
               ) then
                    if ( 
                        _not(
                              _eq_QUMARK(
                                false                                ,
                                    trampCall( self._test_MIMARKerror_QUMARK_METHOD(  'test-error?',
                                        trampCall(@_test_MIMARKerror_QUMARK)                                      ,
                                    [
                                          trampCall(_result)
                                    ]
                                                 ))
                              )
                        )
                     ) then
                        begin #makeLet
                          ___lambda = lambda { |_ex,_ey| 
                              if ( 
                                  _not(
                                        _eq_QUMARK(
                                          false                                          ,
                                            trampCall(_ex)
                                        )
                                  )
                               ) then
                                    delayCall( '_eq_QUMARK',  'eq?',
                                        trampCall(@_eq_QUMARK)                                      ,
                                    [
                                          trampCall(_ex)                                        ,
                                          trampCall(_ey)
                                    ]
                                                 )
                              else
                                false
                              end
                          } ; ___lambda.call(
                                trampCall(_expected).type(
                                  )                              ,
                                trampCall(_result).type(
                                  )
                                     )
                        end
                    else
                      false
                    end
              else
                  if ( 
                  true
                   ) then
                          delayCall( '_equal_QUMARK',  'equal?',
                              trampCall(@_equal_QUMARK)                            ,
                          [
                                trampCall(_expected)                              ,
                                trampCall(_result)
                          ]
                                       )
                  else
                      Cell.new()
                  end
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self.__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK'] = self.method( :__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK_METHOD )
    @__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK = 
    trampCall(
        "test.record"
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self.__ASMARKtest_MIMARKoutput_MIMARKfile_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '__ASMARKtest_MIMARKoutput_MIMARKfile_ASMARK', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['__ASMARKtest_MIMARKoutput_MIMARKfile_ASMARK'] = self.method( :__ASMARKtest_MIMARKoutput_MIMARKfile_ASMARK_METHOD )
    @__ASMARKtest_MIMARKoutput_MIMARKfile_ASMARK = 
    trampCall(
          trampCall(STDOUT)
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self.__ASMARKdiscrepancy_MIMARKlist_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '__ASMARKdiscrepancy_MIMARKlist_ASMARK', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['__ASMARKdiscrepancy_MIMARKlist_ASMARK'] = self.method( :__ASMARKdiscrepancy_MIMARKlist_ASMARK_METHOD )
    @__ASMARKdiscrepancy_MIMARKlist_ASMARK = 
    trampCall(
        Cell.new()
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._test_MIMARKrecord_MIMARKfile_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_test_MIMARKrecord_MIMARKfile', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_test_MIMARKrecord_MIMARKfile'] = self.method( :_test_MIMARKrecord_MIMARKfile_METHOD )
    @_test_MIMARKrecord_MIMARKfile = 
    trampCall(
          Proc.new { |_file| 
              begin #execFunc
                  def self.__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
                  @global_lisp_binding['__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK'] = self.method( :__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK_METHOD )
                @__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK = 
                trampCall(
                      trampCall(_file)
                )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._test_MIMARKoutput_MIMARKfile_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_test_MIMARKoutput_MIMARKfile', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_test_MIMARKoutput_MIMARKfile'] = self.method( :_test_MIMARKoutput_MIMARKfile_METHOD )
    @_test_MIMARKoutput_MIMARKfile = 
    trampCall(
          Proc.new { |_file| 
              begin #execFunc
                  def self.__ASMARKtest_MIMARKoutput_MIMARKfile_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '__ASMARKtest_MIMARKoutput_MIMARKfile_ASMARK', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
                  @global_lisp_binding['__ASMARKtest_MIMARKoutput_MIMARKfile_ASMARK'] = self.method( :__ASMARKtest_MIMARKoutput_MIMARKfile_ASMARK_METHOD )
                @__ASMARKtest_MIMARKoutput_MIMARKfile_ASMARK = 
                trampCall(
                      trampCall(_file)
                )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self.__ASMARKtest_MIMARKcounts_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '__ASMARKtest_MIMARKcounts_ASMARK', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['__ASMARKtest_MIMARKcounts_ASMARK'] = self.method( :__ASMARKtest_MIMARKcounts_ASMARK_METHOD )
    @__ASMARKtest_MIMARKcounts_ASMARK = 
    trampCall(
            trampCall( self._vector_METHOD(  'vector',
                trampCall(@_vector)              ,
            [
                0                ,
                0                ,
                0                ,
                0
            ]
                         ))
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._test_MIMARKcount_PLMARK_PLMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_test_MIMARKcount_PLMARK_PLMARK', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_test_MIMARKcount_PLMARK_PLMARK'] = self.method( :_test_MIMARKcount_PLMARK_PLMARK_METHOD )
    @_test_MIMARKcount_PLMARK_PLMARK = 
    trampCall(
          Proc.new { || 
                delayCall( '_vector_MIMARKset_EXMARK',  'vector-set!',
                    trampCall(@_vector_MIMARKset_EXMARK)                  ,
                [
                      trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                    ,
                    0                    ,
                        ( 
                            trampCall( self._vector_MIMARKref_METHOD(  'vector-ref',
                                trampCall(@_vector_MIMARKref)                              ,
                            [
                                  trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                                ,
                                0
                            ]
                                         ))                        +
                        1
                         ) 
                ]
                             )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._test_MIMARKpass_PLMARK_PLMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_test_MIMARKpass_PLMARK_PLMARK', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_test_MIMARKpass_PLMARK_PLMARK'] = self.method( :_test_MIMARKpass_PLMARK_PLMARK_METHOD )
    @_test_MIMARKpass_PLMARK_PLMARK = 
    trampCall(
          Proc.new { || 
                delayCall( '_vector_MIMARKset_EXMARK',  'vector-set!',
                    trampCall(@_vector_MIMARKset_EXMARK)                  ,
                [
                      trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                    ,
                    1                    ,
                        ( 
                            trampCall( self._vector_MIMARKref_METHOD(  'vector-ref',
                                trampCall(@_vector_MIMARKref)                              ,
                            [
                                  trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                                ,
                                1
                            ]
                                         ))                        +
                        1
                         ) 
                ]
                             )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._test_MIMARKfail_PLMARK_PLMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_test_MIMARKfail_PLMARK_PLMARK', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_test_MIMARKfail_PLMARK_PLMARK'] = self.method( :_test_MIMARKfail_PLMARK_PLMARK_METHOD )
    @_test_MIMARKfail_PLMARK_PLMARK = 
    trampCall(
          Proc.new { || 
                delayCall( '_vector_MIMARKset_EXMARK',  'vector-set!',
                    trampCall(@_vector_MIMARKset_EXMARK)                  ,
                [
                      trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                    ,
                    2                    ,
                        ( 
                            trampCall( self._vector_MIMARKref_METHOD(  'vector-ref',
                                trampCall(@_vector_MIMARKref)                              ,
                            [
                                  trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                                ,
                                2
                            ]
                                         ))                        +
                        1
                         ) 
                ]
                             )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._test_MIMARKabort_PLMARK_PLMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_test_MIMARKabort_PLMARK_PLMARK', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_test_MIMARKabort_PLMARK_PLMARK'] = self.method( :_test_MIMARKabort_PLMARK_PLMARK_METHOD )
    @_test_MIMARKabort_PLMARK_PLMARK = 
    trampCall(
          Proc.new { || 
                delayCall( '_vector_MIMARKset_EXMARK',  'vector-set!',
                    trampCall(@_vector_MIMARKset_EXMARK)                  ,
                [
                      trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                    ,
                    3                    ,
                        ( 
                            trampCall( self._vector_MIMARKref_METHOD(  'vector-ref',
                                trampCall(@_vector_MIMARKref)                              ,
                            [
                                  trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                                ,
                                3
                            ]
                                         ))                        +
                        1
                         ) 
                ]
                             )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._format_MIMARKsummary_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_format_MIMARKsummary', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_format_MIMARKsummary'] = self.method( :_format_MIMARKsummary_METHOD )
    @_format_MIMARKsummary = 
    trampCall(
          Proc.new { || 
                delayCall( '_sprintf',  'sprintf',
                    trampCall(@_sprintf)                  ,
                [
                    "Total: %5d tests, %5d passed, %5d failed, %5d aborted.
"                    ,
                        trampCall( self._vector_MIMARKref_METHOD(  'vector-ref',
                            trampCall(@_vector_MIMARKref)                          ,
                        [
                              trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                            ,
                            0
                        ]
                                     ))                    ,
                        trampCall( self._vector_MIMARKref_METHOD(  'vector-ref',
                            trampCall(@_vector_MIMARKref)                          ,
                        [
                              trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                            ,
                            1
                        ]
                                     ))                    ,
                        trampCall( self._vector_MIMARKref_METHOD(  'vector-ref',
                            trampCall(@_vector_MIMARKref)                          ,
                        [
                              trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                            ,
                            2
                        ]
                                     ))                    ,
                        trampCall( self._vector_MIMARKref_METHOD(  'vector-ref',
                            trampCall(@_vector_MIMARKref)                          ,
                        [
                              trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                            ,
                            3
                        ]
                                     ))
                ]
                             )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._read_MIMARKsummary_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_read_MIMARKsummary', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_read_MIMARKsummary'] = self.method( :_read_MIMARKsummary_METHOD )
    @_read_MIMARKsummary = 
    trampCall(
          Proc.new { || 
              if ( 
                if ( 
                    _not(
                          _eq_QUMARK(
                            false                            ,
                                _string_QUMARK(
                                    trampCall(@__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK)
                                )
                          )
                    )
                 ) then
                    trampCall(File).exist?(
                          trampCall(@__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK)
                      )
                else
                  false
                end
               ) then
                      trampCall( self._with_MIMARKopen_METHOD(  'with-open',
                          trampCall(@_with_MIMARKopen)                        ,
                      [
                            trampCall(@__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK)                          ,
                            Proc.new { |_f| 
                                begin #makeLet
                                  ___lambda = lambda { |_m| 
                                      if ( 
                                        trampCall(_m)
                                       ) then
                                              trampCall( self._for_MIMARKeach_METHOD(  'for-each',
                                                  trampCall(@_for_MIMARKeach)                                                ,
                                              [
                                                    Proc.new { |_i| 
                                                          trampCall( self._vector_MIMARKset_EXMARK_METHOD(  'vector-set!',
                                                              trampCall(@_vector_MIMARKset_EXMARK)                                                            ,
                                                          [
                                                                trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                                                              ,
                                                                trampCall(_i)                                                              ,
                                                                  _to_MIMARKi(
                                                                        trampCall( self._rxmatch_MIMARKsubstring_METHOD(  'rxmatch-substring',
                                                                            trampCall(@_rxmatch_MIMARKsubstring)                                                                          ,
                                                                        [
                                                                              trampCall(_m)                                                                            ,
                                                                                ( 
                                                                                  trampCall(_i)                                                                                +
                                                                                1
                                                                                 ) 
                                                                        ]
                                                                                     ))
                                                                  )
                                                          ]
                                                                       ))
                                                    }                                                  ,
                                                  Cell.new(0,Cell.new(1,Cell.new(2,Cell.new(3))))
                                              ]
                                                           ))
                                      end
                                  } ; ___lambda.call(
                                          trampCall( self._rxmatch_METHOD(  'rxmatch',
                                              trampCall(@_rxmatch)                                            ,
                                          [
                                              Regexp.new( "Total:\\s+(\\d+)\\s+tests,\\s+(\\d+)\\s+passed,\\s+(\\d+)\\s+failed,\\s+(\\d+)\\s+aborted")                                              ,
                                                trampCall(_f).readline.chomp(
                                                  )
                                          ]
                                                       ))
                                             )
                                end
                            }
                      ]
                                   ))
              end
              begin #makeLet
                ___lambda = lambda { |_orig_MIMARKabort| 
                      trampCall( self._vector_MIMARKset_EXMARK_METHOD(  'vector-set!',
                          trampCall(@_vector_MIMARKset_EXMARK)                        ,
                      [
                            trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                          ,
                          3                          ,
                              ( 
                                trampCall(_orig_MIMARKabort)                              +
                              1
                               ) 
                      ]
                                   ))
                      trampCall( self._write_MIMARKsummary_METHOD(  'write-summary',
                          trampCall(@_write_MIMARKsummary)                        ,
                      [
                      ]
                                   ))
                      delayCall( '_vector_MIMARKset_EXMARK',  'vector-set!',
                          trampCall(@_vector_MIMARKset_EXMARK)                        ,
                      [
                            trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                          ,
                          3                          ,
                            trampCall(_orig_MIMARKabort)
                      ]
                                   )
                } ; ___lambda.call(
                        trampCall( self._vector_MIMARKref_METHOD(  'vector-ref',
                            trampCall(@_vector_MIMARKref)                          ,
                        [
                              trampCall(@__ASMARKtest_MIMARKcounts_ASMARK)                            ,
                            3
                        ]
                                     ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._write_MIMARKsummary_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_write_MIMARKsummary', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_write_MIMARKsummary'] = self.method( :_write_MIMARKsummary_METHOD )
    @_write_MIMARKsummary = 
    trampCall(
          Proc.new { || 
              if ( 
                  _string_QUMARK(
                      trampCall(@__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK)
                  )
               ) then
                      delayCall( '_with_MIMARKopen',  'with-open',
                          trampCall(@_with_MIMARKopen)                        ,
                      [
                            trampCall(@__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK)                          ,
                            Proc.new { |_f| 
                                trampCall(_f).printf(
                                    "%s"                                    ,
                                        trampCall( self._format_MIMARKsummary_METHOD(  'format-summary',
                                            trampCall(@_format_MIMARKsummary)                                          ,
                                        [
                                        ]
                                                     ))
                                  )
                            }                          ,
                          "w"
                      ]
                                   )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._prim_MIMARKtest_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_prim_MIMARKtest', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_prim_MIMARKtest'] = self.method( :_prim_MIMARKtest_METHOD )
    @_prim_MIMARKtest = 
    trampCall(
          Proc.new { |_msg,_expect,_thunk,*__rest__| _compare = __rest__[0] ;  
              begin #makeLet
                ___lambda = lambda { |_cmp,_f| 
                    trampCall(_f).printf(
                        "test %s, expects %s ==> "                        ,
                          trampCall(_msg)                        ,
                            _write_MIMARKto_MIMARKstring(
                                trampCall(_expect)
                            )
                      )
                    trampCall(_f).flush(
                      )
                      trampCall( self._test_MIMARKcount_PLMARK_PLMARK_METHOD(  'test-count++',
                          trampCall(@_test_MIMARKcount_PLMARK_PLMARK)                        ,
                      [
                      ]
                                   ))
                    begin #makeLet
                      ___lambda = lambda { |_r| 
                          begin #makeLet
                            ___lambda = lambda { |_ret| 
                                if ( 
                                  trampCall(_ret)
                                 ) then
                                    begin  #makeBegin
                                        trampCall(_f).printf(
                                            "ok
"
                                          )
                                          trampCall( self._test_MIMARKpass_PLMARK_PLMARK_METHOD(  'test-pass++',
                                              trampCall(@_test_MIMARKpass_PLMARK_PLMARK)                                            ,
                                          [
                                          ]
                                                       ))
                                    end
                                else
                                    if ( 
                                    true
                                     ) then
                                        begin  #makeBegin
                                            trampCall(_f).printf(
                                                "ERROR: GOT %s
"                                                ,
                                                    _write_MIMARKto_MIMARKstring(
                                                        trampCall(_r)
                                                    )
                                              )
                                            begin #execFunc
                                                def self.__ASMARKdiscrepancy_MIMARKlist_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '__ASMARKdiscrepancy_MIMARKlist_ASMARK', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
                                                @global_lisp_binding['__ASMARKdiscrepancy_MIMARKlist_ASMARK'] = self.method( :__ASMARKdiscrepancy_MIMARKlist_ASMARK_METHOD )
                                              @__ASMARKdiscrepancy_MIMARKlist_ASMARK = 
                                              trampCall(
                                                      _cons(
                                                            trampCall( self._list_METHOD(  'list',
                                                                trampCall(@_list)                                                              ,
                                                            [
                                                                  trampCall(_msg)                                                                ,
                                                                  trampCall(_expect)                                                                ,
                                                                  trampCall(_r)
                                                            ]
                                                                         ))                                                        ,
                                                          trampCall(@__ASMARKdiscrepancy_MIMARKlist_ASMARK)
                                                      )
                                              )
                                            end
                                              trampCall( self._test_MIMARKfail_PLMARK_PLMARK_METHOD(  'test-fail++',
                                                  trampCall(@_test_MIMARKfail_PLMARK_PLMARK)                                                ,
                                              [
                                              ]
                                                           ))
                                        end
                                    else
                                        Cell.new()
                                    end
                                end
                                trampCall(_f).flush(
                                  )
                                trampCall(_ret)
                            } ; ___lambda.call(
                                    trampCall( callProcedure(  '_cmp',  'cmp',
                                        trampCall(_cmp)                                      ,
                                    [
                                          trampCall(_expect)                                        ,
                                          trampCall(_r)
                                    ]
                                                 ))
                                       )
                          end
                      } ; ___lambda.call(
                              trampCall( callProcedure(  '_thunk',  'thunk',
                                  trampCall(_thunk)                                ,
                              [
                              ]
                                           ))
                                 )
                    end
                } ; ___lambda.call(
                      if ( 
                          _pair_QUMARK(
                              trampCall(_compare)
                          )
                       ) then
                            delayCall( '_car',  'car',
                                trampCall(@_car)                              ,
                            [
                                  trampCall(_compare)
                            ]
                                         )
                      else
                          trampCall(@_test_MIMARKcheck)
                      end                    ,
                      trampCall(@__ASMARKtest_MIMARKoutput_MIMARKfile_ASMARK)
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._test_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_test', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_test'] = self.method( :_test_METHOD )
    @_test = 
    trampCall(
          Proc.new { |_msg,_expect,_thunk,*__rest__| _compare = __rest__[0] ;  
                delayCall( '_apply',  'apply',
                    trampCall(@_apply)                  ,
                [
                      trampCall(@_prim_MIMARKtest)                    ,
                      trampCall(_msg)                    ,
                      trampCall(_expect)                    ,
                      Proc.new { || 
                          begin #makeGuard
                                trampCall( callProcedure(  '_thunk',  'thunk',
                                    trampCall(_thunk)                                  ,
                                [
                                ]
                                             ))
                          rescue => _exc
                              if ( 
                              true
                               ) then
                                    trampCall(Nendo::NendoTestError).new(
                                          trampCall(_exc).class(
                                            )
                                      )
                              else
                                  if ( 
                                  true
                                   ) then
                                          trampCall( self.__PAMARKraise_METHOD(  '%raise',
                                              trampCall(@__PAMARKraise)                                            ,
                                          [
                                                trampCall(_exc)                                              ,
                                                  trampCall( self._sprintf_METHOD(  'sprintf',
                                                      trampCall(@_sprintf)                                                    ,
                                                  [
                                                      "%s:%s raised %s"                                                      ,
                                                          trampCall( self.__ASMARKFILE_ASMARK_METHOD(  '*FILE*',
                                                              trampCall(@__ASMARKFILE_ASMARK)                                                            ,
                                                          [
                                                          ]
                                                                       ))                                                      ,
                                                          trampCall( self.__ASMARKLINE_ASMARK_METHOD(  '*LINE*',
                                                              trampCall(@__ASMARKLINE_ASMARK)                                                            ,
                                                          [
                                                          ]
                                                                       ))                                                      ,
                                                        trampCall(_exc)
                                                  ]
                                                               ))                                              ,
                                                  trampCall( self._sprintf_METHOD(  'sprintf',
                                                      trampCall(@_sprintf)                                                    ,
                                                  [
                                                      "%s:%s raised %s"                                                      ,
                                                          trampCall( self.__ASMARKFILE_ASMARK_METHOD(  '*FILE*',
                                                              trampCall(@__ASMARKFILE_ASMARK)                                                            ,
                                                          [
                                                          ]
                                                                       ))                                                      ,
                                                          trampCall( self.__ASMARKLINE_ASMARK_METHOD(  '*LINE*',
                                                              trampCall(@__ASMARKLINE_ASMARK)                                                            ,
                                                          [
                                                          ]
                                                                       ))                                                      ,
                                                        trampCall(_exc)
                                                  ]
                                                               ))
                                          ]
                                                       ))
                                  else
                                      Cell.new()
                                  end
                              end
                          end
                      }                    ,
                      trampCall(_compare)
                ]
                             )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._test_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_test_ASMARK', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_test_ASMARK'] = self.method( :_test_ASMARK_METHOD )
    @_test_ASMARK = 
    trampCall(
          LispMacro.new { |_msg,_expect,_form,*__rest__| _compare = __rest__[0] ;  
                _cons(
                  :"test"                  ,
                      _cons(
                          trampCall(_msg)                        ,
                            _cons(
                                trampCall(_expect)                              ,
                                  _cons(
                                        _cons(
                                          :"lambda"                                          ,
                                              _cons(
                                                Cell.new()                                                ,
                                                    _cons(
                                                        trampCall(_form)                                                      ,
                                                      Cell.new()
                                                    )
                                              )
                                        )                                    ,
                                      trampCall(_compare)
                                  )
                            )
                      )
                )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._make_MIMARKpadding_MIMARKstring_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_make_MIMARKpadding_MIMARKstring', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_make_MIMARKpadding_MIMARKstring'] = self.method( :_make_MIMARKpadding_MIMARKstring_METHOD )
    @_make_MIMARKpadding_MIMARKstring = 
    trampCall(
          Proc.new { |_num,_char| 
                delayCall( '_string_MIMARKjoin',  'string-join',
                    trampCall(@_string_MIMARKjoin)                  ,
                [
                        trampCall( self._map_METHOD(  'map',
                            trampCall(@_map)                          ,
                        [
                              Proc.new { |_x| 
                                  trampCall(_char)
                              }                            ,
                                trampCall( self._range_METHOD(  'range',
                                    trampCall(@_range)                                  ,
                                [
                                      trampCall(_num)
                                ]
                                             ))
                        ]
                                     ))
                ]
                             )
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._test_MIMARKsection_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_test_MIMARKsection', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_test_MIMARKsection'] = self.method( :_test_MIMARKsection_METHOD )
    @_test_MIMARKsection = 
    trampCall(
          Proc.new { |_msg| 
              begin #makeLet
                ___lambda = lambda { |_f,_msglen| 
                    trampCall(_f).printf(
                        "<%s>%s
"                        ,
                          trampCall(_msg)                        ,
                            trampCall( self._make_MIMARKpadding_MIMARKstring_METHOD(  'make-padding-string',
                                trampCall(@_make_MIMARKpadding_MIMARKstring)                              ,
                            [
                                    trampCall( self._max_METHOD(  'max',
                                        trampCall(@_max)                                      ,
                                    [
                                        5                                        ,
                                            ( 
                                            77                                            -
                                              trampCall(_msglen)
                                             ) 
                                    ]
                                                 ))                                ,
                                "-"
                            ]
                                         ))
                      )
                    trampCall(_msg)
                } ; ___lambda.call(
                      trampCall(@__ASMARKtest_MIMARKoutput_MIMARKfile_ASMARK)                    ,
                        trampCall( self._string_MIMARKlength_METHOD(  'string-length',
                            trampCall(@_string_MIMARKlength)                          ,
                        [
                              trampCall(_msg)
                        ]
                                     ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._test_MIMARKstart_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_test_MIMARKstart', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_test_MIMARKstart'] = self.method( :_test_MIMARKstart_METHOD )
    @_test_MIMARKstart = 
    trampCall(
          Proc.new { |_msg| 
              begin #makeLet
                ___lambda = lambda { |_s| 
                    begin #makeLet
                      ___lambda = lambda { |_pad| 
                          begin #makeLet
                            ___lambda = lambda { |_f| 
                                trampCall(_f).printf(
                                    "%s%s"                                    ,
                                      trampCall(_s)                                    ,
                                      trampCall(_pad)
                                  )
                                trampCall(_f).flush(
                                  )
                                  trampCall( self._read_MIMARKsummary_METHOD(  'read-summary',
                                      trampCall(@_read_MIMARKsummary)                                    ,
                                  [
                                  ]
                                               ))
                                trampCall(_f).printf(
                                    "
"
                                  )
                                begin #execFunc
                                    def self.__ASMARKdiscrepancy_MIMARKlist_ASMARK_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '__ASMARKdiscrepancy_MIMARKlist_ASMARK', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
                                    @global_lisp_binding['__ASMARKdiscrepancy_MIMARKlist_ASMARK'] = self.method( :__ASMARKdiscrepancy_MIMARKlist_ASMARK_METHOD )
                                  @__ASMARKdiscrepancy_MIMARKlist_ASMARK = 
                                  trampCall(
                                      Cell.new()
                                  )
                                end
                                begin #makeLet
                                  ___lambda = lambda { |_msglen| 
                                      trampCall(_f).printf(
                                          "Testing %s %s
"                                          ,
                                            trampCall(_msg)                                          ,
                                              trampCall( self._make_MIMARKpadding_MIMARKstring_METHOD(  'make-padding-string',
                                                  trampCall(@_make_MIMARKpadding_MIMARKstring)                                                ,
                                              [
                                                      trampCall( self._max_METHOD(  'max',
                                                          trampCall(@_max)                                                        ,
                                                      [
                                                          5                                                          ,
                                                              ( 
                                                              70                                                              -
                                                                trampCall(_msglen)
                                                               ) 
                                                      ]
                                                                   ))                                                  ,
                                                  "-"
                                              ]
                                                           ))
                                        )
                                      trampCall(_f).flush(
                                        )
                                  } ; ___lambda.call(
                                          trampCall( self._string_MIMARKlength_METHOD(  'string-length',
                                              trampCall(@_string_MIMARKlength)                                            ,
                                          [
                                                trampCall(_msg)
                                          ]
                                                       ))
                                             )
                                end
                                trampCall(_msg)
                            } ; ___lambda.call(
                                  trampCall(@__ASMARKtest_MIMARKoutput_MIMARKfile_ASMARK)
                                       )
                          end
                      } ; ___lambda.call(
                              trampCall( self._make_MIMARKpadding_MIMARKstring_METHOD(  'make-padding-string',
                                  trampCall(@_make_MIMARKpadding_MIMARKstring)                                ,
                              [
                                      trampCall( self._max_METHOD(  'max',
                                          trampCall(@_max)                                        ,
                                      [
                                          3                                          ,
                                              ( 
                                              65                                              -
                                                  trampCall( self._string_MIMARKlength_METHOD(  'string-length',
                                                      trampCall(@_string_MIMARKlength)                                                    ,
                                                  [
                                                        trampCall(_s)
                                                  ]
                                                               ))
                                               ) 
                                      ]
                                                   ))                                  ,
                                  " "
                              ]
                                           ))
                                 )
                    end
                } ; ___lambda.call(
                        trampCall( self._sprintf_METHOD(  'sprintf',
                            trampCall(@_sprintf)                          ,
                        [
                            "Testing %s ... "                            ,
                              trampCall(_msg)
                        ]
                                     ))
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._test_MIMARKend_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_test_MIMARKend', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_test_MIMARKend'] = self.method( :_test_MIMARKend_METHOD )
    @_test_MIMARKend = 
    trampCall(
          Proc.new { || 
              begin #makeLet
                ___lambda = lambda { |_f| 
                    if ( 
                        _null_QUMARK(
                            trampCall(@__ASMARKdiscrepancy_MIMARKlist_ASMARK)
                        )
                     ) then
                        trampCall(_f).printf(
                            "passed.
"
                          )
                    else
                        begin  #makeBegin
                            trampCall(_f).printf(
                                "failed.
discrepancies found.  Errors are:
"
                              )
                              trampCall( self._for_MIMARKeach_METHOD(  'for-each',
                                  trampCall(@_for_MIMARKeach)                                ,
                              [
                                    Proc.new { |_r| 
                                        trampCall(_f).printf(
                                            "test %s: expects %s => got %s
"                                            ,
                                                trampCall( self._first_METHOD(  'first',
                                                    trampCall(@_first)                                                  ,
                                                [
                                                      trampCall(_r)
                                                ]
                                                             ))                                            ,
                                                _write_MIMARKto_MIMARKstring(
                                                      trampCall( self._second_METHOD(  'second',
                                                          trampCall(@_second)                                                        ,
                                                      [
                                                            trampCall(_r)
                                                      ]
                                                                   ))
                                                )                                            ,
                                                _write_MIMARKto_MIMARKstring(
                                                      trampCall( self._third_METHOD(  'third',
                                                          trampCall(@_third)                                                        ,
                                                      [
                                                            trampCall(_r)
                                                      ]
                                                                   ))
                                                )
                                          )
                                    }                                  ,
                                      _reverse(
                                          trampCall(@__ASMARKdiscrepancy_MIMARKlist_ASMARK)
                                      )
                              ]
                                           ))
                        end
                    end
                    if ( 
                      trampCall(@__ASMARKtest_MIMARKrecord_MIMARKfile_ASMARK)
                     ) then
                            trampCall( self._write_MIMARKsummary_METHOD(  'write-summary',
                                trampCall(@_write_MIMARKsummary)                              ,
                            [
                            ]
                                         ))
                    end
                      delayCall( '_length',  'length',
                          trampCall(@_length)                        ,
                      [
                            trampCall(@__ASMARKdiscrepancy_MIMARKlist_ASMARK)
                      ]
                                   )
                } ; ___lambda.call(
                      trampCall(@__ASMARKtest_MIMARKoutput_MIMARKfile_ASMARK)
                           )
              end
          }
    )
  end
 )
#--------------------

trampCall( 
  begin #execFunc
      def self._test_MIMARKmodule_METHOD( origname, pred, args )   lispMethodEntry( origname, true ) ;   ret = callProcedure( '_test_MIMARKmodule', origname, pred, args ) ;  lispMethodExit( origname,  true ) ;   return ret end 
      @global_lisp_binding['_test_MIMARKmodule'] = self.method( :_test_MIMARKmodule_METHOD )
    @_test_MIMARKmodule = 
    trampCall(
          Proc.new { |_module_MIMARKname| 
              trampCall(_module_MIMARKname)
          }
    )
  end
 )


# -------------------------------------------------------
# [EOF]
# -------------------------------------------------------
