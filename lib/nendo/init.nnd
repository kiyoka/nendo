;;-*- mode: nendo; syntax: scheme -*-;;
;;;
;;; init.nnd - Nendo's init file.
;;;  
;;;   Copyright (c) 2009-2011  Kiyoka Nishiyama  <kiyoka@sumibi.org>
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  
;;;  $Id: 
;;;

;; ----------------------------------------
;; define
;; ----------------------------------------
(define %expand-define-form-lambda
  (lambda (arg body-list)
    ;; (define (func arg...) body)
    (if (pair? (cdr arg))
        (if (pair? (car (cdr arg)))
            (error "Error: define syntax error.")))
    (cons 'define
          (cons (car arg)
                (list
                 (cons 'lambda
                       (cons  (cdr arg)
                              body-list)))))))

(define define
  (macro (arg . body)
    (if (not (pair? arg))
        ;; (define var body)
        (cons 'define
              (cons arg
                    body))
        (%expand-define-form-lambda arg body))))

(define %expand-define-form
  (lambda (arg-and-body)
    (%let ((arg  (car arg-and-body))
           (body (cdr arg-and-body)))
      ;; (define (func arg...) body)
      (if (not (pair? arg))
          ;; (define var body)
          (cons 'define
                (cons arg
                      body))
          (%expand-define-form-lambda arg body)))))

;; debug-print macro is predefined as NOP.
;; for self debugging of init.nnd.
(define debug-print
  (macro (_form sourcefile lineno sourcesexp)
    _form))

;; ----------------------------------------
;; car and cdr functions
;; ----------------------------------------
(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))


;; ----------------------------------------
;; List Utility functions
;; ----------------------------------------
(define iota range)

(define (append a b)
  (letrec ((append-reverse
            (lambda (a b)
              (if (pair? a)
                  (append-reverse (cdr a) (cons (car a) b))
                  b))))
    (append-reverse (reverse a) b)))

;; ----------------------------------------
;; Utility functions
;; ----------------------------------------
(define (vector . lst)  (to-arr lst))
(define list? %list?)
(define (even? n) (= (% n 2) 0))
(define (odd? n) (not (= (% n 2) 0)))
(define (zero? n) (= n 0))
(define (positive? n) (> n 0))
(define (negative? n) (< n 0))
(define (abs n) (if (>= n 0) n (- n)))
(define (max . lst)
     (fold-right (lambda (a b) (if (> a b) a b)) (car lst) (cdr lst)))
(define (min . lst)
     (fold-right (lambda (a b) (if (< a b) a b)) (car lst) (cdr lst)))
(define (succ x) (+ x 1))
(define (pred x) (- x 1))
(define (nth n lst)
  (letrec ((nth-iter
            (lambda (n index lst)
              (if (null? lst)
                  '()
                  (if (not (pair? lst))
                      (error "Error: nth got improper list.")
                      (if (eqv? n index)
                          (car lst)
                          (nth-iter n (+ index 1) (cdr lst))))))))
    (nth-iter n 0 lst)))
(define (first lst)    (nth  0 lst))
(define (second lst)   (nth  1 lst))
(define (third lst)    (nth  2 lst))
(define (fourth lst)   (nth  3 lst))
(define (fifth lst)    (nth  4 lst))
(define (sixth lst)    (nth  5 lst))
(define (seventh lst)  (nth  6 lst))
(define (eighth lst)   (nth  7 lst))
(define (ninth lst)    (nth  8 lst))
(define (tenth lst)    (nth  9 lst))

(define (x->string object)   (to-s object))
(define (number->string num) (x->string num))
(define string-append
  (lambda str-lst
    (string-join str-lst "")))

(define (string=? a b)
  (eq? a b))

;; ----------------------------------------
;; basic forms
;; ----------------------------------------
(define (macroexpand sexp)
  (%let ((newsexp (macroexpand-1 sexp)))
     (if (not (equal? sexp newsexp))
         (macroexpand newsexp)
         (strip-let-syntax-keyword
          (strip-syntax-quote
           newsexp)))))
         

(define (feedto)
  (error "=> (feedto) appeared outside cond or case."))

(define cond
  (macro lst
    (letrec ((case-block
              (lambda (elem . elseblock)
                (%let ((condition (if (eq? 'else (car elem))
                                      true
                                      (car elem)))
                      (body      (if (null? (cdr elem))
                                     '(#t)
                                     (cdr elem)))
                      (tmpsym    (gensym)))
                  ;;(display "CONDITION") (print condition)
                  ;;(display "BODY")      (print body)
                  ;;(display "TMPSYM")    (print tmpsym)
                  (append
                   (if (eq? 'feedto (car body))
                       (cons 'if
                             (list
                              (list 'set! tmpsym condition)
                              (list (cadr body) tmpsym)))
                       (cons 'if
                             (list
                              condition
                              (cons 'begin body))))
                   (if (< 0 (length elseblock))
                       elseblock
                       '())))))
             (cond-iter
              (lambda (lst)
                (if (eq? 0 (length lst))
                    '()
                    (if (eq? 1 (length lst))
                        (case-block (car lst) '())
                        (case-block (car lst)
                                    (cond-iter (cdr lst))))))))
      (cond-iter lst))))

(define let1
  (macro (var expr . body)
    (append
     (list '%let (list (list var expr)))
     body)))

(define or
  (macro lst
    (letrec ((or-iter
              (lambda (lst)
                (cond
                 ((eq? 0 (length lst))
                  false)
                 ((eq? 1 (length lst))
                  (let1 sym (gensym)
                    (list 'let1 sym (car lst)
                          (list 'if sym sym false))))
                 (else
                  (let1 sym (gensym)
                    (list 'let1 sym (car lst)
                          (list 'if sym sym (or-iter (cdr lst))))))))))
      (or-iter lst))))

(define and
  (macro lst
    (letrec ((and-iter
              (lambda (lst)
                (cond
                 ((eq? 0 (length lst))
                  true)
                 ((eq? 1 (length lst))
                  (car lst))
                 (else
                  (list 'if (list 'not (list 'eq? 'false (car lst)))
                        (and-iter (cdr lst))
                        'false))))))
      (and-iter lst))))


(define (apply proc . args)
  (if (null? args)
      (proc)
      ((lambda (lol)
         (apply1 proc (append (reverse (cdr lol)) (car lol))))
       (reverse args))))

;; The following quasiquote macro is due to Eric S. Tiedemann. ( Imported from TinyScheme )
;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
;;
;; Subsequently modified for initialize library for nendo: Kiyoka Nishiyama
(define quasiquote
 (macro (l)
   (letrec ((mcons
             (lambda (f l r)
               (if (and (pair? r)
                        (eq? (car r) 'quote)
                        (eq? (car (cdr r)) (cdr f))
                        (pair? l)
                        (eq? (car l) 'quote)
                        (eq? (car (cdr l)) (car f)))
                   (if (or (procedure? f) (number? f) (string? f))
                       f
                       (list 'quote f))
                   (if (eqv? l vector)
                       (apply l (eval r))
                       (list 'cons l r)
                       ))))

            (mappend
             (lambda (f l r)
               (if (or (null? (cdr f))
                       (and (pair? r)
                            (eq? (car r) 'quote)
                            (eq? (car (cdr r)) '())))
                   l
                   (list 'append l r))))
            (foo
             (lambda (level form)
               (cond ((not (pair? form))
                      (if (or (procedure? form) (number? form) (string? form))
                          form
                          (list 'quote form))
                      )
                     ((eq? 'quasiquote (car form))
                      (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
                     (else (if (zero? level)
                               (cond ((eq? (car form) 'unquote) (car (cdr form)))
                                     ((eq? (car form) 'unquote-splicing)
                                      (%raise RuntimeError (+ "Error: Unquote-splicing wasn't in a list: " (write-to-string form))
                                             (sprintf "%s:%s outside list." (*FILE*) (*LINE*))))
                                     ((and (pair? (car form))
                                           (eq? (car (car form)) 'unquote-splicing))
                                      (mappend form (car (cdr (car form)))
                                               (foo level (cdr form))))
                                     (else (mcons form (foo level (car form))
                                                  (foo level (cdr form)))))
                               (cond ((eq? (car form) 'unquote)
                                      (mcons form ''unquote (foo (- level 1)
                                                                 (cdr form))))
                                     ((eq? (car form) 'unquote-splicing)
                                      (mcons form ''unquote-splicing
                                             (foo (- level 1) (cdr form))))
                                     (else (mcons form (foo level (car form))
                                                  (foo level (cdr form)))))))))))
     (foo 0 l))))

(define unquote
  (macro (lst)
    (%raise RuntimeError "Error: unquote appeared outside quasiquote" (sprintf "%s:%s outside quasiquote" (*FILE*) (*LINE*)))))


(define unquote-splicing
  (macro (lst)
    (raise RuntimeError "Error: unquote-splicing appeared outside quasiquote" (sprintf "%s:%s outside quasiquote" (*FILE*) (*LINE*)))))


(define when
  (macro form
    `(if ,(car form) (begin ,@(cdr form)))))
  
(define unless
  (macro form
    `(if (not ,(car form)) (begin ,@(cdr form)))))

(define while
  (macro form
    (let1 sym (gensym)
      `(begin
	 (define ,sym
	   (lambda ()
	     (if ,(car form)
		 (begin ,@(cdr form)
			(,sym)))))
	 (,sym)))))

(define until
  (macro form
    `(while (not ,(car form))
       ,@(cdr form))))

;; named let supporting
(define let
  (macro lst
    ;; checking syntax
    (cond
     ((symbol? (car lst))
      ;; named let
      (when (or (< (length lst) 3)
                (not (list? (second lst))))
        (%raise SyntaxError
                (sprintf "named let requires (let name (bind-list) body ...) form  But got %s" (write-to-string (cons 'let lst)))
                (sprintf "%s:%s in named let form" (*FILE*) (*LINE*)))))
     (else
      (when (or (< (length lst) 2)
                (not (list? (first lst))))
        (%raise SyntaxError
                (sprintf "let requires (let (bind-list) body ...) form  But got %s" (write-to-string (cons 'let lst)))
                (sprintf "%s:%s in named let form" (*FILE*) (*LINE*))))))

    ;; expanding macro
    (if (symbol? (car lst))
        ;; named let
        `(letrec ((,(first lst)
                   (lambda ,(map
                             (lambda (x)
                               (first x))
                             (second lst))
                     ,@(cddr lst))))
           (,(first lst)
            ,@(map
               (lambda (x)
                 (second x))
               (second lst))))
           
        ;; trasform to internal let syntax (%let)
        `(%let ,@lst))))

        
(define if-let1
  (macro (var _expr _then . _else)
    `(let1 ,var ,_expr
       (if ,var ,_then ,@_else))))


(define push!
  (macro (_lst _val)
    `(set! ,_lst (append (list ,_val) ,_lst))))

;; ----------------------------------------
;; errorf
;; ----------------------------------------
(define errorf
  (macro (format . args)
    `(error
      (sprintf ,format ,@args))))


;; ----------------------------------------
;; optional argument parser
;; ----------------------------------------
(define get-optional
  (macro (restarg default)
    (let1 _restarg (gensym)
      `(let1 ,_restarg ,restarg
         (if (null? ,_restarg)
             ,default
             (car ,_restarg))))))

;; pending
(define check-arg
  (macro (a b . c)
    `(begin)))


;; ----------------------------------------
;; List utilities imported from TinyScheme
;; ----------------------------------------
;;
;; (do ((var init inc) ...) (endtest result ...) body ...)
;;
(define do
  (macro do-macro
    (apply (lambda (vars endtest . body)
             (let ((do-loop (gensym)))
               `(letrec ((,do-loop
                          (lambda ,(map (lambda (x)
                                          (if (pair? x) (car x) x))
                                        `,vars)
                            (if ,(car endtest)
                                (begin ,@(cdr endtest))
                                (begin
                                  ,@body
                                  (,do-loop
                                   ,@(map (lambda (x)
                                            (cond
                                             ((not (pair? x)) x)
                                             ((< (length x) 3) (car x))
                                             (else (car (cdr (cdr x))))))
                                          `,vars)))))))
                  (,do-loop
                   ,@(map (lambda (x)
                            (if (and (pair? x) (cdr x))
                                (car (cdr x))
                                '()))
                          `,vars)))))
           do-macro)))


;; generic-member 
(define (generic-member cmp obj lst)
  (cond
    ((null? lst) #f)
    ((not (pair? lst)) #f)
    ((cmp obj (car lst)) lst)
    (else (generic-member cmp obj (cdr lst)))))

(define (memq obj lst)
     (generic-member eq? obj lst))
(define (memv obj lst)
     (generic-member eqv? obj lst))
(define (member obj lst)
     (generic-member equal? obj lst))

;; generic-assoc
(define (generic-assoc cmp obj alst)
     (cond
          ((null? alst) false)
          ((cmp obj (caar alst)) (car alst))
          (else (generic-assoc cmp obj (cdr alst)))))

(define (assq obj alst)
     (generic-assoc eq? obj alst))
(define (assv obj alst)
     (generic-assoc eqv? obj alst))
(define (assoc obj alst)
     (generic-assoc equal? obj alst))

(define (acons x y z) (cons (cons x y) z))

(define (assq-ref obj alst)
  (cond  ((assq obj alst)  => cdr)
         (else                nil)))
(define (assv-ref obj alst)
  (cond  ((assv obj alst)  => cdr)
         (else                nil)))
(define (assoc-ref obj alst)
  (cond  ((assoc obj alst)  => cdr)
         (else                nil)))


;; ----------------------------------------
;; Higher-order functions
;; ----------------------------------------
;; List utilities imported from TinyScheme  by Kiyoka Nishiyama
;;  and Fixed bugs in `map' and `for-each'.
(define (fold-right f x lst)
     (if (null? lst)
          x
          (fold-right f (f x (car lst)) (cdr lst))))

(define (unzip1-with-cdr . lists)
  (unzip1-with-cdr-iterative lists '() '()))

(define (unzip1-with-cdr-iterative lists cars cdrs)
  (if (null? lists)
      (cons cars cdrs)
      (let ((car1 (caar lists))
	    (cdr1 (cdar lists)))
	(unzip1-with-cdr-iterative 
	 (cdr lists) 
	 (append cars (list car1))
	 (append cdrs (list cdr1))))))


(define (%map-original proc . lists)
  (letrec ((result '())
           (%map-arg1
            (lambda (proc lst)
              (if (null? lst)
                  #t
                  (begin
                    (set! result
                          (cons (proc (car lst))
                                result))
                    (%map-arg1 proc (cdr lst)))))))
    (cond
     ((null? lists)
      (apply proc))
     ((eq? 1 (length lists))
      (%map-arg1 proc (car lists)) ;; tail call optimization version
      (reverse result))
     (else
      (if (null? (car lists))
          '()
          (let1 unz (apply unzip1-with-cdr lists)
            (let ((cars (car unz))
                  (cdrs (cdr unz)))
              (cons (apply proc cars)
                    (if (null? cdrs)
                        '()
                        (apply %map-original (cons proc cdrs)))))))))))
(define %map %map-original)

(define (%internal-define-to-letrec _sym _src)
  (if (not (list? (cadr _src)))
      `(,_sym ,@_src)
      (%let ((body (cdr _src))
             (defs '())
             (rest '()))
        (if (not (list? (car body)))
            `(,_sym ,@_src)
            (begin
              (%map
               (lambda (x)
                 (if (and (pair? x)
                          (eq? 'define (car x)))
                     (set! defs (cons (%expand-define-form (cdr x)) defs))
                     (set! rest (cons x rest))))
               body)
              (%let ((defs (reverse defs))
                     (rest (reverse rest)))
                (if (< 0 (length defs))
                    `(,_sym
                      ,(car _src)
                      (letrec
                          ,(%map
                            (lambda (x)
                              (list
                               (cadr x)
                               (caddr x)))
                            defs)
                        ,@rest))
                    ;; found no `internal-define' syntax
                    `(,_sym ,@_src))))))))


(define (%for-each-original proc . lists)
  (define (%for-each-arg1 proc lst)
    (if (null? lst)
        #t
        (begin
          (proc (car lst))
          (%for-each-arg1 proc (cdr lst)))))
  (cond
   ((null? lists)
    (apply proc))
   ((eq? 1 (length lists))
    (%for-each-arg1 proc (car lists))) ;; tail call optimization version
   (else
    (if (null? (car lists))
        #t
        (let1 unz (apply unzip1-with-cdr lists)
          (let ((cars (car unz))
                (cdrs (cdr unz)))
            (apply proc cars)
            (if (null? cdrs)
                '()
                (apply %for-each-original (cons proc cdrs)))))))))
(define %for-each %for-each-original)

(define (%filter-original pred lst)
  (define result '())
  (define (%filter-arg1 proc lst)
    (if (null? lst)
        '()
        (let1 v (proc (car lst))
          (when v
            (set! result (cons (car lst) result)))
          (%filter-arg1 proc (cdr lst)))))

  (%filter-arg1 pred lst) ;; tail call optimization version
  (reverse result))
(define %filter %filter-original)

(define (%filter-map pred lst)
  (define result '())
  (define (%filter-map-arg1 proc lst)
    (if (null? lst)
        '()
        (let1 v (proc (car lst))
          (when v
            (set! result (cons v result)))
          (%filter-map-arg1 proc (cdr lst)))))

  (%filter-map-arg1 pred lst) ;; tail call optimization version
  (reverse result))


(define (find pred lst)
  (let1 result (%filter pred lst)
    (if (null? result)
        #f
        (car result))))

(define (any pred lst)
  (let1 result (%filter-map pred lst)
    (if (null? result)
        #f
        (car result))))

(define map         %map)
(define for-each    %for-each)
(define filter      %filter)
(define filter-map  %filter-map)


;; ----------------------------------------
;;  lambda & macro
;; ----------------------------------------
(define (%%optional-argument-check target arg-and-body)
  (let1 arg-list (if (list? arg-and-body)
                     (car arg-and-body)
                     '())
    (when (list? arg-list)
      (when (any (lambda (x) (keyword? x)) arg-list)
        (errorf "Error: %s can't handle keyword argument." target)))))

(define lambda
  (macro src
    (%%optional-argument-check 'lambda src)
    (%internal-define-to-letrec 'lambda src)))

(define macro
  (macro src
    (%%optional-argument-check 'macro src)
    (%internal-define-to-letrec 'macro src)))

;; ----------------------------------------
;; :optional argument feature for define  (The original is Gauche 0.9.1's feature)
;;  like  "(define (func a b : optional (c #f)) ... )"
;; ----------------------------------------
(define (%transform-optional-arguments arg body-list)
  (if-let1 rest-of-opts (memq :optional arg)
    (let([opts         '()]
         [rest-of-opts (cdr rest-of-opts)]
         [_rest        (gensym)])
      ;; arguemnt form check
      (for-each
       (lambda (x)
         (let1 syntax-is-ok  (if (pair? x)
                                 (= 2 (length x))
                                 #f)
           (unless syntax-is-ok
             (error "Error:  :optional format is illegal ... " arg))))
       rest-of-opts)
      (let loop ((arg arg))
        (if (eq? :optional (car arg))
            arg
            (begin
              (set! opts (cons (car arg) opts))
              (loop (cdr arg)))))
      (let1 new-arg (apply list* (append (reverse opts) (list _rest)))
        (list 'lambda
              new-arg
              `(let
                   ,rest-of-opts
                 ,@(map
                    (lambda (k n)
                      `(when (< ,n (length ,_rest))
                         (set! ,(car k) (nth ,n ,_rest))))
                    rest-of-opts
                    (range (length rest-of-opts)))
                 ,@body-list))))
    `(lambda ,arg ,@body-list)))

(define %expand-define-form-lambda
  (lambda (arg body-list)
    ;; (define (func arg...) body)
    (if (pair? (cdr arg))
        (if (pair? (car (cdr arg)))
            (error "Error: define syntax error.")))
    (cons 'define
          (list (car arg)
                (%transform-optional-arguments (cdr arg) body-list)))))



;; ----------------------------------------
;; other forms
;; ----------------------------------------
(define case
  (macro (cond-exp . body)
    (define (case-block val . elem)
      (let1 block (car elem)
        (let ((cond-vals (car block))
              (body      (cdr block)))
          (let1 v
              (if (eq? 'else cond-vals)
                  cond-vals
                  (cons 'or
                        (map
                         (lambda (x)
                           `(eqv? (quote ,x) ,val))
                         cond-vals)))
            `((,v
               ,@body))))))
  
    (define (case-iter val lst)
      (cond
       ((null? lst)
        '())
       ((eq? 1 (length lst))
        (case-block val (car lst)))
       (else
        (append (case-block val (car lst))
                (case-iter  val (cdr lst))))))

    (let1 sym (gensym)
      `(let1 ,sym ,cond-exp
         (cond
          ,@(case-iter sym body))))))


(define let*
  (macro (exps . body)
    (define (let*-expand rest body)
      (case (length rest)
        ((0)
         '())
        ((1)
         `(let (,(car rest))
            ,@body))
        (else
         `(let (,(car rest))
            ,(let*-expand (cdr rest) body)))))
    (let*-expand exps body)))


(define begin0
  (macro body
    (if (null? body)
        '(begin
           #f)
        (let1 result (gensym)
          `(receive ,result ,(car body)
             ,@(cdr body)
             (apply values ,result))))))


;; ----------------------------------------
;; values
;; ----------------------------------------
(define (values . args)
  (case (length args)
    ((1)
     (car args))
    (else
     (make-values args))))


(define (call-with-values producer consumer)
  (let ((v (producer)))
    (if (values? v)
        (apply consumer (values-values v))
        (consumer v))))

;; srfi-8
(define receive
  (macro (vars expr . body)
    `(call-with-values
         (lambda () ,expr)
       (lambda ,vars ,@body))))


;; ----------------------------------------
;; keyword
;; ----------------------------------------
(define (get-keyword key kv-list . fallback)
  (cond
   ((or (not (list? kv-list))  (>= 2 (length kv-list)))
    (if (null? fallback)
        (errorf "Error: imcomplete key list: %s\n" (write-to-string kv-list))
        (car fallback)))
   (else
    (let loop ((k (car kv-list))
               (v (cadr kv-list))
               (rest (cddr kv-list)))
      (if (eq? k key)
          v
          (case (length rest)
            ((0)
             (if (null? fallback)
                 (errorf "Error: value for key %s is not provided : %s\n" (write-to-string key) (write-to-string kv-list))
                 (car fallback)))
            ((1)
             (errorf "Error: incomplete key list: %s\n" (write-to-string kv-list)))
            (else
             (loop (car rest)
                   (cadr rest)
                   (cddr rest)))))))))

(define (keyword->symbol kw)
  (string->symbol
   (keyword->string kw)))
  

;; ----------------------------------------
;; for Ruby interop
;; ----------------------------------------
(define dot-operator
  (macro lst
    (define (generate-method-call-form lst)
      (let1 tmp (gensym)
        (if (symbol? (first lst))
            `(,(string->symbol (+ (to-s (first lst)) "." (to-s (second lst))))
              ,@(cddr lst))
            `(let ((,tmp ,(first lst)))
               (,(string->symbol (+ (to-s tmp) "." (to-s (second lst))))
                ,@(cddr lst))))))
    (cond
     ((> 2 (length lst))
      (%raise ArgumentError ". dot-operator requires 2+ arguments." (sprintf "%s:%s in dot-operator" (*FILE*) (*LINE*))))
     (else
      (if (symbol? (second lst))
          (generate-method-call-form lst)
          (%raise TypeError ". dot-operator requires method name as symbol." (sprintf "%s:%s in dot-operator" (*FILE*) (*LINE*))))))))


;; ----------------------------------------
;; List library functions
;; ----------------------------------------
(define (last-pair x)
    (if (pair? (cdr x))
        (last-pair (cdr x))
        x))


(define (cons* arg . args)
  (if (null? args)
      arg
      (cons arg (apply cons* args))))
(define list* cons*)


;; ----------------------------------------
;; hash-table library functions
;; ----------------------------------------
(define (make-hash-table . eq)
  (Hash.new))

(define (hash-table? h)
  (h.is_a? Hash))

(define (hash-table-num-entries h)
  (h.length))

(define (hash-table type . kv-list)
  (unless (or (eq? type eq?)
              (eq? type eqv?))
    (error "Error: hash-table got eq? or eqv? as type"))
  (let1 h (make-hash-table)
    (for-each
     (lambda (entry)
       (hash-table-put! h (car entry) (cdr  entry)))
     kv-list)
    h))

(define (hash-table-clear! h)
  (h.clear))

(define (hash-table-delete! h key)
  (h.delete key))

(define (hash-table-push! ht key value)
  (hash-table-put!
   ht
   key
   (cons value (hash-table-get ht key '()))))

(define (hash-table-keys h)
  (to-list (h.keys)))

(define (hash-table-values h)
  (to-list (h.values)))

(define (hash-table-map h pred)
  (let1 keys (hash-table-keys h)
    (map
     (lambda (key)
       (pred key (hash-table-get h key)))
     keys)))
(define hash-table-for-each hash-table-map)


;; ----------------------------------------
;; Vector Library
;; ----------------------------------------
(define (vector? v)
  (v.is_a? Array))

(define (make-vector k . rest)
  (if (null? rest)
      (Array.new k)
      (Array.new k (car rest))))

(define (vector-length v)
  (v.size))

(define (vector-copy v)
  (v.clone))

(define (vector-ref v index . fallback)
  (if (and (<= 0 index) (< index v.size))
      (v.fetch index)
      (if (null? fallback)
          (errorf "Error: vector-ref  index value is overflow: %s\n" index)
          (car fallback))))

;;
;; ported from tinyscheme-1.39 by Kiyoka Nishiyama
;;
(define (vector-equal? x y)
     (and (vector? x) (vector? y) (= (vector-length x) (vector-length y))
          (let ((n (vector-length x)))
               (let loop ((i 0))
                    (if (= i n)
                         #t
                         (and (equal? (vector-ref x i) (vector-ref y i))
                              (loop (succ i))))))))

(define (list->vector x)
     (apply vector x))

(define (vector-fill! v e)
     (let ((n (vector-length v)))
          (let loop ((i 0))
               (if (= i n)
                    v
                    (begin (vector-set! v i e) (loop (succ i)))))))

(define (vector->list v)
     (let loop ((n (pred (vector-length v))) (l '()))
          (if (= n -1)
               l
               (loop (pred n) (cons (vector-ref v n) l)))))


;; ----------------------------------------
;; Utility function for testing and debugging
;; ----------------------------------------
;; Gauche's #?= like debug print function
(define *debug-print-length* 63)
(define (debug-print-length . len)
  (let1 len (get-optional len 'none)
    (if (eq? len 'none)
        *debug-print-length*
        (set! *debug-print-length* len))))
(define (debug-print-output-func str)  ;; default output func
  (STDERR.print str))
(define (debug-limit-length x)
  (+
   (cond
    ((not *debug-print-length*)
     x)
    ((< *debug-print-length* x.length)
     (let1 n *debug-print-length*.to_s
       (sprintf (+ "%" n "." n "s ...") x)))
    (else
     x))
   "\n"))

(define debug-print
  (macro (_form sourcefile lineno sourcesexp)
    (let1 val (gensym)
      `(let ((,val nil))
         (debug-print-output-func (debug-limit-length (sprintf "#?=\"%s\":%s:%s" ,sourcefile ,lineno (write-to-string ,sourcesexp))))
         (set! ,val ,_form)
         (debug-print-output-func (debug-limit-length (+       "#?-    " (write-to-string ,val))))
         ,val))))


;;
;; imported from this URL ( written by bizen )
;;    http://practical-scheme.net/wiliki/wiliki.cgi?Gauche%3APrettyPrint
;; 
;; Subsequently modified for initialize library for nendo: Kiyoka Nishiyama
(define (pretty-print s . f)
  (define (do-indent f level)
    (for-each (lambda (x) (f.print " ")) (range level)))
  (define (pp-parenl f)
    (f.print "("))
  (define (pp-parenr f)
    (f.print ")"))
  (define (pp-atom f e prefix)
    (when prefix (f.print " "))
    (f.print (write-to-string e)))
  (define (pp-list f s level prefix)
    (and prefix (do-indent f level))
    (pp-parenl f)
    (let loop ((s s)
               (prefix #f))
      (if (null? s)
          (pp-parenr f)
          (let1 e (car s)
            (if (list? e)
                (begin (and prefix (f.print "\n"))
                       (pp-list f e (+ level 1) prefix))
                (pp-atom f e prefix))
            (loop (cdr s) #t)))))
  (let1 f (get-optional f STDOUT)
    (if (list? s)
        (pp-list f s 0 #f)
        (f.print (write-to-string s)))
    (f.print "\n")))


(define (pretty-print-to-string s)
  (let1 io (StringIO.new)
    (pretty-print s io)
    (io.rewind)
    (io.read)))

;; ----------------------------------------
;; sort library functions
;; ----------------------------------------
(define (sort lst . cmpfn)
  (if (null? lst)
      '()
      (let1 cmpfn (get-optional cmpfn #f)
        (to-list
         (if cmpfn
             (lst.to_arr.sort (&block (a b) (cmpfn a b)))
             (lst.to_arr.sort))))))


(define (sort-by lst keyfn)
  (if (null? lst)
      '()
      (to-list
       (lst.to_arr.sort_by (&block (item) (keyfn item))))))


;; ----------------------------------------
;; string library
;; ----------------------------------------
(define (string-length str) (str.size))


;; ----------------------------------------
;; regexp library functions
;; ----------------------------------------
(define (string->regexp str . casefold)
  (if (not (str.is_a? String))
      (error "Error: string->regexp requires a String argument.")
      (if (get-optional casefold #f)
          (Regexp.new str Regexp::IGNORECASE)
          (Regexp.new str))))

(define (regexp? obj)
  (obj.is_a? Regexp))

(define (regexp->string regexp)
  (regexp.source))

;; return:  Ruby's MatchData instance
(define (rxmatch regexp str)
  (let1 m (regexp.match str)
    (if m m #f)))

(define (rxmatch-start match . index)
  (let1 index (get-optional index 0)
    (match.begin index)))

(define (rxmatch-end match . index)
  (let1 index (get-optional index 0)
    (match.end index)))

(define (rxmatch-substring match . index)
  (let1 index (get-optional index 0)
    (nth index (match.to_a.to_list))))

(define (rxmatch-num-matches match)
  (match.size))

(define (rxmatch->string regexp str . index)
  (let1 index (get-optional index 0)
    (let1 m (rxmatch regexp str)
      (if m
          (rxmatch-substring m index)
          #f))))



;; ----------------------------------------
;; Ruby interop librarys
;; ----------------------------------------
;; export Nendo's function to the Ruby world
(define export-to-ruby
  (macro (funcname)
    `(%export-to-ruby ,funcname.to_s ,funcname)))

(define (load path)
  (if (rxmatch #/^([.]\/|[.][.]\/|\/)/ path)
      (%load path)
      (let1 lp (append (map (lambda (x) (+ x "/nendo")) *load-path*)
                       *load-path*)
        (let loop ((load-path lp))
          (cond ((null? load-path)
                 (errorf "Error: can't load file [%s]\n" path))
                (else
                 (let1 full-path (+ (car load-path) "/" path)
                   (cond
                    ((File.exist? full-path)
                     (if (rxmatch #/[.]nndc$/ full-path)
                         (%load-compiled-code full-path)
                         (%load               full-path)))
                    ((File.exist? (+ full-path ".nndc"))
                     (%load-compiled-code (+ full-path ".nndc")))
                    ((File.exist? (+ full-path ".nnd"))
                     (%load (+ full-path ".nnd")))
                    (else
                     (loop (cdr load-path)))))))))))

(define (add-load-path path . afterp)
  (set! *load-path*
        (if (get-optional afterp #f)
            (append *load-path* (list path))
            (cons path *load-path*)))
  *load-path*)

;; use macro like Gauche
(define use
  (macro (sym)
    (if (symbol? sym)
        (let*
            ((str      (symbol->string sym))
             (pathname (str.gsub "." "/")))
          `(load ,pathname))
        (errorf "Error: use macro requires a symbol argument."))))

;; exporting a symbol in the module. (I will implement in the future...)
(define export
  (macro (name)
    `(define ,name nil)))



;; ----------------------------------------
;; global variables bind checker
;; ----------------------------------------
(define (global-defined? sym)
  (find
   (lambda (x)
     (eq? sym x))
   (global-variables)))


;; ----------------------------------------
;; Nendo compiler utility
;; ----------------------------------------
(define (compiled-code-string compiled-code filename)
  (define (compiled-body-string string-list filename)
    (+
     (string-join
      string-list
      "\n#--------------------\n")
     (string-join
      `("\n\n"
        "# -------------------------------------------------------"
        "# [EOF]"
        "# -------------------------------------------------------")
      "\n")))
    
  (let ((str-list (assv-ref filename compiled-code))
        (script-flag  (and (global-defined? 'main)
                           (procedure? main))))
    (values
     script-flag
     (compiled-body-string str-list filename))))


(define (print-compiled-code src . rest)
  (define (print-to-file f)
    (receive (script-flag str)
        (compiled-code-string (get-compiled-code) src)
      (cond (script-flag
             (f.puts (string-join
                      `(
                        "#!/usr/local/bin/ruby"
                        "# -*- encoding: utf-8 -*-"
                        "#"
                        "#    This file is nendo's compiled script file. "
                        "#    generated  \"nendo -c src\" command. "
                        "#"
                        ""
                        "require 'rubygems'"
                        "require 'nendo'"
                        ""
                        "core = Nendo::Core.new()"
                        "core.loadInitFile()"
                        "core.setArgv( ARGV )"
                        "core.load_compiled_code_from_string( " ,(write-to-string str) " ) "
                        "core.evalStr( \"(if (and (global-defined? 'main) (procedure? main)) (main *argv*) #f) \" )"
                        "")
                      "\n")))
            (else
             (f.puts (+ (string-join
                         '(
                           "#"
                           "#    This file is nendo's compiled library file. "
                           "#    generated  \"nendo -c src\" command. "
                           "# ")
                         "\n")
                        "\n"
                        str))))))

  (when (not (File.exist? src))
    (errorf "Error: file [%s] not found." src)
    (exit 1))
  (clean-compiled-code)
  (load src)
  (if (null? rest)
      (print-to-file STDOUT)
      (with-open (car rest)
                 (lambda (f)
                   (print-to-file f))
                 "w")))


;; ----------------------------------------
;; compile phase ( it can be written in Nendo! )
;; ----------------------------------------
;;
;; example:
;;   %compile-phase-functions is ( func1 func2 func3 )
;; then this function evals.
;;   (func3 (func2 (func1 sexp)))
;;
(define (%compile-phase sexp)
  (cond
   ((list? sexp)
    (for-each
     (lambda (func)
       (set! sexp (func sexp)))
     %compile-phase-functions)
    sexp)
   (else
    sexp)))


;; ----------------------------------------
;; tail call optimization
;; ----------------------------------------
(define (%setup-%tailcall-mark sexp)
  (define (reserved? sym)
    (let* ([reserved-orig '(quote syntax-quote macro %syntax begin lambda if %let letrec define define-syntax %guard)]
           [reserved (append reserved-orig
                             (map
                              (lambda (orig)
                                (string->symbol (+ "/nendo/core/" (symbol->string orig))))
                              reserved-orig))])
      (memq sym reserved)))

  (define (setup-let-args args)
    (map
     (lambda (arg)
       (let ((name (first  arg))
             (body (second arg)))
         (list name
               (if (list? body)
                   (if (reserved? (car body))
                       (%setup-%tailcall-mark body)
                       body)
                   body))))
     args))

  (define (setup-proc sexp)
    (cond
     ((null? sexp)
      sexp)
     ((and (list? sexp)
           (< 0 (length sexp)))
      (if (reserved? (car sexp))
          (%setup-%tailcall-mark sexp)
          (if (pair? (car sexp))
              sexp ;; e.g.  ((lambda (x) ...)
              `(%tailcall ,sexp))))
     (else
      sexp)))

  (define (setup-proc-body sexp)
    (if (or (not (list? sexp))
            (null? sexp))
        sexp
        (let* ((r (reverse sexp))
               (last  (car r))
               (other (cdr r)))
          (if (not (pair? last))
              sexp
              (reverse
               (cons
                (if (reserved? (car last))
                    ;; recursive
                    (%setup-%tailcall-mark last)
                    ;; this is the tailcall!
                    `(%tailcall ,last))
                other))))))

  (cond
   ((not (pair? sexp))
    sexp)
   ((null? sexp)
    '())
   ((list? sexp)
    (let1 _car (car sexp)
      (case _car
        ((quote /nendo/core/quote)
         sexp)
        ((syntax-quote /nendo/core/syntax-quote)
         sexp)
        ((macro /nendo/core/macro)
         sexp)
        ((%syntax /nendo/core/%syntax)
         sexp)
        ((%guard /nendo/core/%guard)
         sexp)
        ((begin /nendo/core/begin)
         `(,_car
           ,@(setup-proc-body (cdr sexp))))
        ((lambda /nendo/core/lambda)
         `(,_car
              ,(second sexp)
            ,@(setup-proc-body (cddr sexp))))
        ((if /nendo/core/if)
         (case (length sexp)
           ((3)
            `(,_car
              ,(second sexp)
              ,(setup-proc     (third  sexp))))
           ((4)
            `(,_car
              ,(second sexp)
              ,(setup-proc     (third sexp))
              ,(setup-proc     (fourth sexp))))))
        ((%let /nendo/core/%let)
         `(,_car
           ,(setup-let-args (second sexp))
           ,@(setup-proc-body (cddr sexp))))
        ((letrec /nendo/core/letrec)
         `(,_car
           ,(setup-let-args (second sexp))
           ,@(setup-proc-body (cddr sexp))))
        ((define /nendo/core/define define-syntax /nendo/core/define-syntax)
         (let1 val (third sexp)
           `(,_car
              ,(second sexp)
              ,(if (and (list? val)
                        (not (null? val))
                        (reserved? (car val)))
                   (%setup-%tailcall-mark val)
                   val))))
        ((set! /nendo/core/set!)
         (let1 val (third sexp)
           `(,_car
             ,(second sexp)
             ,(if (and (list? val)
                       (not (null? val))
                       (reserved? (car val)))
                  (%setup-%tailcall-mark val)
                  val))))
        (else
         (if (symbol? (car sexp))
             `(%tailcall ,sexp)
             sexp)))))
   (else
    sexp)))



;; definition of 'compile-phase'
(set! %compile-phase-functions
      (list
       %setup-%tailcall-mark
       ))


;; explicit renameing macro transformer
;;   ported from chibi-scheme-0.3  by Kiyoka Nishiyama
;;
;;   URL: http://community.schemewiki.org/?syntactic-closures
;;
(define (identifier? x)
  (symbol? x))

(define (identifier=? use-env-x x use-env-y y)
  (eq? x y))

(define (identifier->symbol id)
  (when (not (symbol? id))
    (error "Error: identifier->symbol requires only symbol"))
  id)

;; readable code for nendo. (original code is chibi-scheme-0.3)
(define er-macro-transformer
  (lambda (f)
    (%syntax (expr use-env mac-env)
      (define (expander-main rename compare)
        (f expr rename compare))
      (define (_rename renames)
        (lambda (identifier)
          (let ([cell (assq identifier renames)])
            (if cell
                (cdr cell)
                ((lambda (name)
                   (set! renames (cons (cons identifier name) renames))
                   name)
                 (make-syntactic-closure mac-env '() identifier))))))
      (define (_compare x y)
        (identifier=? use-env x use-env y))
      
      (expander-main
       (_rename '())
       _compare))))


;; explicit renameing macro transformer
;;   ported from chibi-scheme-0.3  by Kiyoka Nishiyama
(define ... '...)
(define-syntax syntax-rules
  (er-macro-transformer
   (lambda (expr rename compare)
     (when (not (pair? (cdr expr)))
       (error "syntax-rules requires: (syntax-rules (ellipses...) ..patterns..) form (1). but got: " expr))
     (when (not (or (null? (cadr expr)) (list? (cadr expr))))
       (error "syntax-rules requires: (syntax-rules (ellipses...) ..patterns..) form (2). but got: " expr))
     (when (> 3 (length expr))
       (error "syntax-rules requires: (syntax-rules (ellipses...) ..patterns..) form (3). but got: " expr))
     (let ((ellipse-specified? (identifier? (cadr expr)))
           (count 0)
           (_er-macro-transformer (rename 'er-macro-transformer))
           (_lambda (rename 'lambda))      (_let (rename 'let))
           (_begin (rename 'begin))        (_if (rename 'if))
           (_and (rename 'and))            (_or (rename 'or))
           (_eq? (rename 'eq?))            (_equal? (rename 'equal?))
           (_car (rename 'car))            (_cdr (rename 'cdr))
           (_cons (rename 'cons))          (_pair? (rename 'pair?))
           (_null? (rename 'null?))        (_expr (rename 'expr))
           (_rename (rename 'rename))      (_compare (rename 'compare))
           (_quote (rename 'syntax-quote)) (_apply (rename 'apply))
           (_append (rename 'append))      (_map (rename 'map))
           (_vector? (rename 'vector?))    (_list? (rename 'list?))
           (_lp (rename 'lp))              (_reverse (rename 'reverse))
           (_len (rename'len))             (_length (rename 'length))
           (_- (rename '-))   (_>= (rename '>=))   (_error (rename 'error))
           (_ls (rename 'ls)) (_res (rename 'res)) (_i (rename 'i))
           (_vector->list (rename 'vector->list))
           (_list->vector (rename 'list->vector))
           (_list (rename 'list)))
       (define ellipse (rename (if ellipse-specified? (cadr expr) '...)))
       (define lits (if ellipse-specified? (caddr expr) (cadr expr)))
       (define forms (if ellipse-specified? (cdddr expr) (cddr expr)))
       (define (next-v)
         (set! count (+ count 1))
         (rename (string->symbol (string-append "v__" (number->string count)))))
       (define (expand-pattern pat tmpl)
         (let lp ((p (cdr pat))
                  (x (list _cdr _expr))
                  (dim 0)
                  (vars '())
                  (k (lambda (vars)
                       (or (expand-template tmpl vars)
                           (list _begin #f)))))
           (let ((v (next-v)))
             (list
              _let (list (list v x))
              (cond
               ((identifier? p)
                (if (find (lambda (l) (compare p l)) lits)
                    (list _and (list _compare v (list _quote p)) (k vars))
                    (list _let (list (list p v)) (k (cons (cons p dim) vars)))))
               ((ellipse? p)
                (cond
                 ((not (null? (cddr p)))
                  (cond
                   ((not (list? (cddr p)))
                    (error "dotted ellipse" p))
                   ((find (lambda (x) (and (identifier? x) (compare x ellipse)))
                         (cddr p))
                    (error "multiple ellipses" p))
                   (else
                    (let ((len (length (cdr (cdr p)))))
                      `(,_let ((,_len (,_length ,v)))
                         (,_and (,_>= ,_len ,len)
                                (,_let ,_lp ((,_ls ,v)
                                             (,_i (,_- ,_len ,len))
                                             (,_res (,_quote ())))
                                  (,_if (,_>= 0 ,_i)
                                      ,(lp `(,@(cdr (cdr p)) ,(car p) ,(car (cdr p)))
                                           `(,_append ,_ls (,_reverse ,_res))
                                           dim
                                           vars
                                           k)
                                      (,_lp (,_cdr ,_ls)
                                            (,_- ,_i 1)
                                            (,_cons (,_car ,_ls) ,_res))))))))))
                 ((identifier? (car p))
                  (list _and (list _list? v)
                        (list _let (list (list (car p) v))
                              (k (cons (cons (car p) (+ 1 dim)) vars)))))
                 (else
                  (let* ((w (next-v))
                         (new-vars (all-vars (car p) (+ dim 1)))
                         (ls-vars (map (lambda (x)
                                         (rename
                                          (string->symbol
                                           (string-append
                                            (symbol->string
                                             (identifier->symbol (car x)))
                                            "-ls"))))
                                       new-vars))
                         (once
                          (lp (car p) (list _car w) (+ dim 1) '()
                              (lambda (_)
                                (cons
                                 _lp
                                 (cons
                                  (list _cdr w)
                                  (map (lambda (x l)
                                         (list _cons (car x) l))
                                       new-vars
                                       ls-vars)))))))
                    (list
                     _let
                     _lp (cons (list w v)
                               (map (lambda (x) (list x '())) ls-vars))
                     (list _if (list _null? w)
                           (list _let (map (lambda (x l)
                                             (list (car x) (list _reverse l)))
                                           new-vars
                                           ls-vars)
                                 (k (append new-vars vars)))
                           (list _and (list _pair? w) once)))))))
               ((pair? p)
                (list _and (list _pair? v)
                      (lp (car p)
                          (list _car v)
                          dim
                          vars
                          (lambda (vars)
                            (lp (cdr p) (list _cdr v) dim vars k)))))
               ((vector? p)
                (list _and
                      (list _vector? v)
                      (lp (vector->list p) (list _vector->list v) dim vars k)))
               ((null? p) (list _and (list _null? v) (k vars)))
               (else (list _and (list _equal? v p) (k vars))))))))
       (define (ellipse-escape? x) (and (pair? x) (compare ellipse (car x))))
       (define (ellipse? x)
         (and (pair? x) (pair? (cdr x)) (compare ellipse (cadr x))))
       (define (ellipse-depth x)
         (if (ellipse? x)
             (+ 1 (ellipse-depth (cdr x)))
             0))
       (define (ellipse-tail x)
         (if (ellipse? x)
             (ellipse-tail (cdr x))
             (cdr x)))
       (define (all-vars x dim)
         (let lp ((x x) (dim dim) (vars '()))
           (cond ((identifier? x)
                  (if (find (lambda (lit) (compare x lit)) lits)
                      vars
                      (cons (cons x dim) vars)))
                 ((ellipse? x) (lp (car x) (+ dim 1) vars))
                 ((pair? x) (lp (car x) dim (lp (cdr x) dim vars)))
                 ((vector? x) (lp (vector->list x) dim vars))
                 (else vars))))
       (define (free-vars x vars dim)
         (let lp ((x x) (free '()))
           (cond
            ((identifier? x)
             (if (and (not (memq x free))
                      (cond ((assq x vars) => (lambda (cell) (>= (cdr cell) dim)))
                            (else #f)))
                 (cons x free)
                 free))
            ((pair? x) (lp (car x) (lp (cdr x) free)))
            ((vector? x) (lp (vector->list x) free))
            (else free))))
       (define (expand-template tmpl vars)
         (let lp ((t tmpl) (dim 0))
           (cond
            ((identifier? t)
             (cond
              ((find (lambda (v) (compare t (car v))) vars)
               => (lambda (cell)
                    (if (<= (cdr cell) dim)
                        t
                        (error "too few ...'s"))))
              (else
               (list _rename (list _quote t)))))
            ((pair? t)
             (cond
              ((ellipse-escape? t)
               (if (pair? (cdr t))
                   (if (pair? (cddr t)) (cddr t) (cadr t))
                   (cdr t)))
              ((ellipse? t)
               (let* ((depth (ellipse-depth t))
                      (ell-dim (+ dim depth))
                      (ell-vars (free-vars (car t) vars ell-dim)))
                 (if (null? ell-vars)
                     (error "too many ...'s")
                     (let* ((once (lp (car t) ell-dim))
                            (nest (if (and (null? (cdr ell-vars))
                                           (identifier? once)
                                           (eq? once (car vars)))
                                      once ;; shortcut
                                      (cons _map
                                            (cons (list _lambda ell-vars once)
                                                  ell-vars))))
                            (many (do ((d depth (- d 1))
                                       (many nest
                                             (list _apply _append many)))
                                      ((= d 1) many))))
                       (if (null? (ellipse-tail t))
                           many ;; shortcut
                           (list _append many (lp (ellipse-tail t) dim)))))))
              (else (list _cons (lp (car t) dim) (lp (cdr t) dim)))))
            ((vector? t) (list _list->vector (lp (vector->list t) dim)))
            ((null? t) (list _quote '()))
            (else t))))
       (list
        _er-macro-transformer
        (list _lambda (list _expr _rename _compare)
              (cons
               _or
               (append
                (map
                 (lambda (clause) (expand-pattern (car clause) (cadr clause)))
                 forms)
                (list (list _error "no expansion for"
                            (list (rename 'strip-syntactic-closures) _expr)))))))))))

(define-syntax %syntax-rules syntax-rules)


(use nendo.experimental)


;;[EOS]
