;;-*- mode: nendo; syntax: scheme -*-;;

;; ----------------------------------------
;; define
;; ----------------------------------------
(define define
      (macro (arg . body)
        (if (not (pair? arg))
            ;; (define var body)
            (cons 'define
                  (cons arg
                        body))
            ;; (define (func arg...) body)
            (begin
              (if (pair? (cdr arg))
                  (if (pair? (car (cdr arg)))
                      (error "Error: define syntax error.")))
              (cons 'define
                    (cons (car arg)
                          (list
                           (cons 'lambda
                                 (cons  (cdr arg)
                                        body)))))))))


;; ----------------------------------------
;; car and cdr functions
;; ----------------------------------------
(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))


;; ----------------------------------------
;; List Utility functions
;; ----------------------------------------
(define iota range)

(define (append a b)
  (letrec ((append-reverse
            (lambda (a b)
              (if (pair? a)
                  (append-reverse (cdr a) (cons (car a) b))
                  b))))
    (append-reverse (reverse a) b)))

;; ----------------------------------------
;; Utility functions
;; ----------------------------------------
(define (list? arg)
  (if (pair? arg)
      (list? (cdr arg))
      (null? arg)))
(define (even? n) (= (% n 2) 0))
(define (odd? n) (not (= (% n 2) 0)))
(define (zero? n) (= n 0))
(define (positive? n) (> n 0))
(define (negative? n) (< n 0))
(define (abs n) (if (>= n 0) n (- n)))
(define (max . lst)
     (foldr (lambda (a b) (if (> a b) a b)) (car lst) (cdr lst)))
(define (min . lst)
     (foldr (lambda (a b) (if (< a b) a b)) (car lst) (cdr lst)))
(define (succ x) (+ x 1))
(define (pred x) (- x 1))
(define (nth n lst)
  (letrec ((nth-iter
            (lambda (n index lst)
              (if (null? lst)
                  nil
                  (if (not (pair? lst))
                      (error "Error: nth got improper list.")
                      (if (eqv? n index)
                          (car lst)
                          (nth-iter n (+ index 1) (cdr lst))))))))
    (nth-iter n 0 lst)))
(define (first lst)    (nth  0 lst))
(define (second lst)   (nth  1 lst))
(define (third lst)    (nth  2 lst))
(define (fourth lst)   (nth  3 lst))
(define (fifth lst)    (nth  4 lst))
(define (sixth lst)    (nth  5 lst))
(define (seventh lst)  (nth  6 lst))
(define (eighth lst)   (nth  7 lst))
(define (ninth lst)    (nth  8 lst))
(define (tenth lst)    (nth  9 lst))

(define (x->string object) (to-s object))

;; ----------------------------------------
;; basic forms
;; ----------------------------------------
(define (macroexpand sexp)
  (let ((newsexp (macroexpand-1 sexp)))
    (if (not (equal? sexp newsexp))
        (macroexpand newsexp)
        newsexp)))

(define (feedto)
  (error "=> (feedto) appeared outside cond or case."))

(define cond
  (macro lst
    (letrec ((case-block
              (lambda (elem . elseblock)
                (let ((condition (if (eq? 'else (car elem))
                                     true
                                     (car elem)))
                      (body      (if (null? (cdr elem))
                                     '(#t)
                                     (cdr elem)))
                      (tmpsym    (gensym)))
                  ;;(display "CONDITION") (print condition)
                  ;;(display "BODY")      (print body)
                  ;;(display "TMPSYM")    (print tmpsym)
                  (append
                   (if (eq? 'feedto (car body))
                       (cons 'if
                             (list
                              (list 'set! tmpsym condition)
                              (list (cadr body) tmpsym)))
                       (cons 'if
                             (list
                              condition
                              (cons 'begin body))))
                   (if (< 0 (length elseblock))
                       elseblock
                       '())))))
             (cond-iter
              (lambda (lst)
                (if (eq? 0 (length lst))
                    '()
                    (if (eq? 1 (length lst))
                        (case-block (car lst) '())
                        (case-block (car lst)
                                    (cond-iter (cdr lst))))))))
      (cond-iter lst))))

(define let1
  (macro (var expr . body)
    (append
     (list 'let (list (list var expr)))
     body)))

(define or
  (macro lst
    (letrec ((or-iter
              (lambda (lst)
                (cond
                 ((eq? 0 (length lst))
                  false)
                 ((eq? 1 (length lst))
                  (let1 sym (gensym)
                    (list 'let1 sym (car lst)
                          (list 'if sym sym false))))
                 (else
                  (let1 sym (gensym)
                    (list 'let1 sym (car lst)
                          (list 'if sym sym (or-iter (cdr lst))))))))))
      (or-iter lst))))

(define and
  (macro lst
    (letrec ((and-iter
              (lambda (lst)
                (cond
                 ((eq? 0 (length lst))
                  true)
                 ((eq? 1 (length lst))
                  (car lst))
                 (else
                  (list 'if (list 'not (list 'eq? 'false (car lst)))
                        (and-iter (cdr lst))
                        'false))))))
      (and-iter lst))))


(define (apply proc . args)
  (if (null? args)
      (proc)
      ((lambda (lol)
         (apply1 proc (append (reverse (cdr lol)) (car lol))))
       (reverse args))))


;; The following quasiquote macro is due to Eric S. Tiedemann. ( Imported from TinyScheme )
;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
;;
;; Subsequently modified for initialize library for nendo: Kiyoka Nishiyama
(define quasiquote
 (macro (l)
   (letrec ((mcons
             (lambda (f l r)
               (if (and (pair? r)
                        (eq? (car r) 'quote)
                        (eq? (car (cdr r)) (cdr f))
                        (pair? l)
                        (eq? (car l) 'quote)
                        (eq? (car (cdr l)) (car f)))
                   (if (or (procedure? f) (number? f) (string? f))
                       f
                       (list 'quote f))
                   (list 'cons l r))))
            
            (mappend
             (lambda (f l r)
               (if (or (null? (cdr f))
                       (and (pair? r)
                            (eq? (car r) 'quote)
                            (eq? (car (cdr r)) '())))
                   l
                   (list 'append l r))))
            (foo
             (lambda (level form)
               (cond ((not (pair? form))
                      (if (or (procedure? form) (number? form) (string? form))
                          form
                          (list 'quote form))
                      )
                     ((eq? 'quasiquote (car form))
                      (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
                     (else (if (zero? level)
                               (cond ((eq? (car form) 'unquote) (car (cdr form)))
                                     ((eq? (car form) 'unquote-splicing)
                                      (error "Unquote-splicing wasn't in a list:"
                                             form))
                                     ((and (pair? (car form))
                                           (eq? (car (car form)) 'unquote-splicing))
                                      (mappend form (car (cdr (car form)))
                                               (foo level (cdr form))))
                                     (else (mcons form (foo level (car form))
                                                  (foo level (cdr form)))))
                               (cond ((eq? (car form) 'unquote)
                                      (mcons form ''unquote (foo (- level 1)
                                                                 (cdr form))))
                                     ((eq? (car form) 'unquote-splicing)
                                      (mcons form ''unquote-splicing
                                             (foo (- level 1) (cdr form))))
                                     (else (mcons form (foo level (car form))
                                                  (foo level (cdr form)))))))))))
     (foo 0 l))))

(define unquote
  (macro (lst)
    (error "unquote appeared outside quasiquote")))

(define unquote-splicing
  (macro (lst)
    (error "unquote-splicing appeared outside quasiquote")))


(define when
  (macro form
    `(if ,(car form) (begin ,@(cdr form)))))
  
(define unless
  (macro form
    `(if (not ,(car form)) (begin ,@(cdr form)))))

(define while
  (macro form
    (let1 sym (gensym)
      `(begin
	 (define ,sym
	   (lambda ()
	     (if ,(car form)
		 (begin ,@(cdr form)
			(,sym)))))
	 (,sym)))))

(define until
  (macro form
    `(while (not ,(car form))
       ,@(cdr form))))

;; named let supporting
(define let
  (macro lst
    (if (symbol? (car lst))
        ;; named let
        `(letrec ((,(first lst)
                   (lambda ,(map
                             (lambda (x)
                               (first x))
                             (second lst))
                     ,(third lst))))
           (,(first lst)
            ,@(map
               (lambda (x)
                 (second x))
               (second lst))))
           
        ;; don't touch
        `(let ,@lst))))

;; ----------------------------------------
;; errorf
;; ----------------------------------------
(define errorf
  (macro (format . args)
    `(error
      (sprintf ,format ,@args))))

;; ----------------------------------------
;; List utilities imported from TinyScheme
;; ----------------------------------------
;; generic-member 
(define (generic-member cmp obj lst)
  (cond
    ((null? lst) false)
    ((cmp obj (car lst)) lst)
    (else (generic-member cmp obj (cdr lst)))))

(define (memq obj lst)
     (generic-member eq? obj lst))
(define (memv obj lst)
     (generic-member eqv? obj lst))
(define (member obj lst)
     (generic-member equal? obj lst))

;; generic-assoc
(define (generic-assoc cmp obj alst)
     (cond
          ((null? alst) false)
          ((cmp obj (caar alst)) (car alst))
          (else (generic-assoc cmp obj (cdr alst)))))

(define (assq obj alst)
     (generic-assoc eq? obj alst))
(define (assv obj alst)
     (generic-assoc eqv? obj alst))
(define (assoc obj alst)
     (generic-assoc equal? obj alst))

(define (acons x y z) (cons (cons x y) z))

(define (assq-ref obj alst)
  (cond  ((assq obj alst)  => cdr)
         (else                nil)))
(define (assv-ref obj alst)
  (cond  ((assv obj alst)  => cdr)
         (else                nil)))
(define (assoc-ref obj alst)
  (cond  ((assoc obj alst)  => cdr)
         (else                nil)))


;; ----------------------------------------
;; Higher-order functions
;; ----------------------------------------
(define (map pred lst)
  (if (null? lst)
      '()
      (cons
       (pred (car lst))
       (map pred (cdr lst)))))
(define for-each map)

(define (filter pred lst)
  (if (null? lst)
      '()
      (if (pred (car lst))
          (cons
           (car lst)
           (filter pred (cdr lst)))
          (filter pred (cdr lst)))))


(define (filter-map pred lst)
  (if (null? lst)
      '()
      (let1 result (pred (car lst))
        (if result
            (cons
             result
             (filter-map pred (cdr lst)))
            (filter-map pred (cdr lst))))))


(define (find pred lst)
  (let1 result (filter pred lst)
    (if (null? result)
        #f
        (car result))))


(define lambda
  (macro src
    (if (not (list? (cadr src)))
        `(lambda ,@src)
        (let1 body (cdr src)
          (if (not (list? (car body)))
              `(lambda ,@src)
              (let ((defs
                      (filter
                       (lambda (x)
                         (and (eq? 'define (car x))
                              (symbol? (cadr x))))
                       body))
                    (rest
                     (filter
                      (lambda (x)
                        (not (and (eq? 'define (car x))
                                  (symbol? (cadr x)))))
                      body)))
                (if (< 0 (length defs))
                    `(lambda
                         ,(car src)
                       (letrec
                           ,(map
                             (lambda (x)
                               (list
                                (cadr x)
                                (caddr x)))
                             defs)
                         ,@rest))
                    ;; found no `internal-define' syntax
                    `(lambda ,@src))))))))


;; ----------------------------------------
;; other forms
;; ----------------------------------------
(define case
  (macro (cond-exp . body)
    (letrec ((case-block
              (lambda (val . elem)
                (let1 block (car elem)
                  (let ((cond-vals (car block))
                        (body      (cdr block)))
                    (let1 v
                        (if (eq? 'else cond-vals)
                            cond-vals
                            (cons 'or
                                  (map
                                   (lambda (x)
                                     `(eqv? ,x ,val))
                                   cond-vals)))
                      `((,v
                         ,@body)))))))
    
             (case-iter
              (lambda (val lst)
                (cond
                 ((eq? 0 (length lst))
                  '())
                 ((eq? 1 (length lst))
                  (case-block val (car lst)))
                 (else
                  (append (case-block val (car lst))
                          (case-iter  val (cdr lst))))))))

      (let1 sym (gensym)
        `(let1 ,sym ,cond-exp
           (cond
            ,@(case-iter sym body)))))))


(define let*
  (macro (exps . body)
    (letrec ((let*-expand
              (lambda (rest body)
                (case (length rest)
                  ((0)
                   '())
                  ((1)
                   `(let (,(car rest))
                      ,@body))
                  (else
                   `(let (,(car rest))
                      ,(let*-expand (cdr rest) body)))))))

      (let*-expand exps body))))


;; ----------------------------------------
;; values
;; ----------------------------------------
(define (values . args)
  (case (length args)
    ((1)
     (car args))
    (else
     (make-values args))))


(define (call-with-values producer consumer)
  (let ((v (producer)))
    (if (values? v)
        (apply consumer (values-values v))
        (consumer v))))

;; srfi-8
(define receive
  (macro (vars expr . body)
    `(call-with-values
         (lambda () ,expr)
       (lambda ,vars ,@body))))


;; ----------------------------------------
;; keyword
;; ----------------------------------------
(define (get-keyword key kv-list . fallback)
  (cond
   ((or (not (list? kv-list))  (>= 2 (length kv-list)))
    (if (null? fallback)
        (errorf "Error: imcomplete key list: %s\n" (write-to-string kv-list))
        (car fallback)))
   (else
    (let loop ((k (car kv-list))
               (v (cadr kv-list))
               (rest (cddr kv-list)))
      (if (eq? k key)
          v
          (case (length rest)
            ((0)
             (if (null? fallback)
                 (errorf "Error: value for key %s is not provided : %s\n" (write-to-string key) (write-to-string kv-list))
                 (car fallback)))
            ((1)
             (errorf "Error: incomplete key list: %s\n" (write-to-string kv-list)))
            (else
             (loop (car rest)
                   (cadr rest)
                   (cddr rest)))))))))

;; ----------------------------------------
;; for Ruby interop
;; ----------------------------------------
(define dot-operator
  (macro lst
    (letrec ((generate-method-call-form
              (lambda (lst)
                (let1 tmp (gensym)
                  (if (symbol? (first lst))
                      `(,(string->symbol (+ (to-s (first lst)) "." (to-s (second lst))))
                        ,@(cddr lst))
                      `(let ((,tmp ,(first lst)))
                         (,(string->symbol (+ (to-s tmp) "." (to-s (second lst))))
                          ,@(cddr lst))))))))
      (cond
       ((> 2 (length lst))
        (raise ArgumentError ". dot-operator requires 2+ arguments."))
       (else
        (if (symbol? (second lst))
            (generate-method-call-form lst)
            (raise TypeError ". dot-operator requires method name as symbol.")))))))


(define (with-open filename pred . lst)
  (let1 len (length lst)
    (let1 f (cond
             ((= 0 len)
              (.open filename))
             ((< 0 len)
              (.open filename (car lst)))
             (else
              (error "with-open requires 2 or 3 arguments.")))
      (let1 result (pred f)
        (f.close)
        result))))


;; ----------------------------------------
;; List library functions
;; ----------------------------------------
(define (last-pair x)
    (if (pair? (cdr x))
        (last-pair (cdr x))
        x))


(define (cons* arg . args)
  (if (null? args)
      arg
      (cons arg (apply list* args))))
(define list* cons*)


;; ----------------------------------------
;; hash-table library functions
;; ----------------------------------------
(define (make-hash-table)
  (Hash.new))

(define (hash-table? h)
  (h.is_a? Hash))

(define (hash-table-num-entries h)
  (h.length))

(define (hash-table . kv-list)
  (let1 h (make-hash-table)
    (for-each
     (lambda (entry)
       (if (pair? (cdr entry))
           (hash-table-put! h (car entry) (cadr entry))
           (hash-table-put! h (car entry) (cdr  entry))))
     kv-list)
    h))

(define (hash-table-exist? h key)
  (h.has_key? key))

(define (hash-table-clear! h)
  (h.clear))

(define (hash-table-delete! h key)
  (h.delete key))

(define (hash-table-keys h)
  (to-list (h.keys)))

(define (hash-table-values h)
  (to-list (h.values)))

(define (hash-table-map h pred)
  (let1 keys (hash-table-keys h)
    (map
     (lambda (key)
       (pred key (hash-table-get h key)))
     keys)))
(define hash-table-for-each hash-table-map)

(define (hash-table->alist h)
  (if (not (h.is_a? Hash))
      (raise TypeError "Error: hash-table->alist expects Hash instance.")
      (let1 keys (hash-table-keys h)
        (map
         (lambda (key)
           (cons key (hash-table-get h key)))
         keys))))

(define (alist->hash-table alist)
  (if (not (list? alist))
      (raise TypeError "Error: alist->hash-table expects alist.")
      (apply hash-table alist)))

;; ----------------------------------------
;; Ruby interop librarys
;; ----------------------------------------
;; I will implement in the future...
(define export
  (macro (name)
    `(define ,name nil)))

(define (load-library name)
  (let* ((home (get-nendo-home))
         (path (+ home "/" name)))
    (cond
     ((File.exist? (+ path ".nndc"))
      (load-compiled-code (+ path ".nndc")))
     ((File.exist? (+ path ".nnd"))
      (load (+ path ".nnd")))
     (else
      (errorf "Error: can't load library file [%s]\n" path )))))


;; ----------------------------------------
;; Utility function for testing and debugging
;; ----------------------------------------
;; Gauche's #?= like debug print function
(define debug-print-length 63)
(define (debug-print-output-func str)  ;; default output func
  (STDERR.print str))
(define (debug-limit-length x)
  (+
   (if (< debug-print-length x.length)
       (let1 n debug-print-length.to_s
         (sprintf (+ "%" n "." n "s ...") x))
       x)
   "\n"))

(define debug-print
  (macro (_form sourcefile lineno sourcesexp)
    (let1 val (gensym)
      `(let ((,val nil))
         (debug-print-output-func (debug-limit-length (sprintf "#?=\"%s\":%s:%s" ,sourcefile ,lineno (write-to-string ,sourcesexp))))
         (set! ,val ,_form)
         (debug-print-output-func (debug-limit-length (+       "#?-    " (write-to-string ,val))))
         ,val))))


;;
;; imported from this URL ( written by bizen )
;;    http://practical-scheme.net/wiliki/wiliki.cgi?Gauche%3APrettyPrint
;; 
;; Subsequently modified for initialize library for nendo: Kiyoka Nishiyama
(define (pretty-print s)
  (define (do-indent level)
    (for-each (lambda (x) (display " ")) (range level)))
  (define (pp-parenl)
    (display "("))
  (define (pp-parenr)
    (display ")"))
  (define (pp-atom e prefix)
    (when prefix (display " "))
    (write e))
  (define (pp-list s level prefix)
    (and prefix (do-indent level))
    (pp-parenl)
    (let loop ((s s)
               (prefix #f))
      (if (null? s)
          (pp-parenr)
          (let1 e (car s)
            (if (list? e)
                (begin (and prefix (newline))
                       (pp-list e (+ level 1) prefix))
                (pp-atom e prefix))
            (loop (cdr s) #t)))))
  (if (list? s)
      (pp-list s 0 #f)
      (write s))
  (newline))


;; ----------------------------------------
;; global variables
;; ----------------------------------------
(define *nendo-version*
  "0.3.1"  ;;NENDO-VERSION
  )
