;;-*- mode: scheme; syntax: scheme -*-;;

;; ----------------------------------------
;; define
;; ----------------------------------------
(set! define
      (macro (arg . body)
        (if (not (pair? arg))
            (cons 'set!
                  (cons arg
                        body))
            (cons 'set!
                  (cons (car arg)
                        (list
                         (cons 'lambda
                               (cons  (cdr arg)
                                      body))))))))

;; ----------------------------------------
;; car and cdr functions
;; ----------------------------------------
(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))


;; ----------------------------------------
;; List Utility functions
;; ----------------------------------------
(define iota range)

(define (append a b)
  (define (append-reverse a b)
    (if (pair? a)
        (append-reverse (cdr a) (cons (car a) b))
        b))
  (append-reverse (reverse a) b))

;; ----------------------------------------
;; Utility functions
;; ----------------------------------------
(define (even? n) (= (% n 2) 0))
(define (odd? n) (not (= (% n 2) 0)))
(define (zero? n) (= n 0))
(define (positive? n) (> n 0))
(define (negative? n) (< n 0))
(define (abs n) (if (>= n 0) n (- n)))
(define (max . lst)
     (foldr (lambda (a b) (if (> a b) a b)) (car lst) (cdr lst)))
(define (min . lst)
     (foldr (lambda (a b) (if (< a b) a b)) (car lst) (cdr lst)))
(define (succ x) (+ x 1))
(define (pred x) (- x 1))

;; ----------------------------------------
;; basic forms
;; ----------------------------------------
(define (macroexpand sexp)
  (let ((newsexp (macroexpand-1 sexp)))
    (if (not (equal? sexp newsexp))
        (macroexpand newsexp)
        newsexp)))

(define cond
  (macro lst
    (define (caseblock elem . elseblock)
      (let ((condition (car elem))
            (body      (cdr elem)))
        (append
         (list 'if
               (if (eq? 'else condition)
                   true
                   condition)
               (cons 'begin body))
         (if (< 0 (length elseblock))
             elseblock
             '()))))

    (define (cond-iter lst)
      (if (eq? 0 (length lst))
          '()
          (if (eq? 1 (length lst))
              (caseblock (car lst) '())
              (caseblock (car lst)
                         (cond-iter (cdr lst))))))

    (cond-iter lst)))

(define let1
  (macro (var expr body)
    (list 'let (list (list var expr)) body)))


(define or
  (macro lst
    (define (or-iter lst)
      (cond
       ((eq? 0 (length lst))
        false)
       ((eq? 1 (length lst))
        (let1 sym (gensym)
              (list 'let1 sym (car lst)
                    (list 'if sym sym false))))
       (else
        (let1 sym (gensym)
              (list 'let1 sym (car lst)
                    (list 'if sym sym (or-iter (cdr lst))))))))
    (or-iter lst)))

(define and
  (macro lst
    (define (and-iter lst)
      (cond
       ((eq? 0 (length lst))
        true)
       ((eq? 1 (length lst))
        (car lst))
       (else
        (list 'if (list 'not (list 'eq? 'false (car lst)))
              (and-iter (cdr lst))
              'false))))
    (and-iter lst)))

(define apply
  (macro (proc . args)
    (define (strip-quote lst)
      (if (eq? 'quote (car lst))
          (cadr lst)
          lst))
    (define (apply-iter lst)
      (cond
       ((eq? 0 (length lst))
        '())
       ((eq? 1 (length lst))
        (if (pair? (car lst))
            (strip-quote (car lst))
            (error "not a proper list")))
       (else
        (append (list (car lst)) (apply-iter (cdr lst))))))
    (append (list proc) (apply-iter args))))


;; The following quasiquote macro is due to Eric S. Tiedemann.
;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
;;
;; Subsequently modified for initialize library for nendo: Kiyoka Nishiyama
(define
 quasiquote
 (macro (l)
   (define (mcons f l r)
     (if (and (pair? r)
              (eq? (car r) 'quote)
              (eq? (car (cdr r)) (cdr f))
              (pair? l)
              (eq? (car l) 'quote)
              (eq? (car (cdr l)) (car f)))
         (if (or (procedure? f) (number? f) (string? f))
               f
               (list 'quote f))
         (list 'cons l r)))
   (define (mappend f l r)
     (if (or (null? (cdr f))
             (and (pair? r)
                  (eq? (car r) 'quote)
                  (eq? (car (cdr r)) '())))
         l
         (list 'append l r)))
   (define (foo level form)
     (cond ((not (pair? form))
               (if (or (procedure? form) (number? form) (string? form))
                    form
                    (list 'quote form))
               )
           ((eq? 'quasiquote (car form))
            (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
           (else (if (zero? level)
                   (cond ((eq? (car form) 'unquote) (car (cdr form)))
                         ((eq? (car form) 'unquote-splicing)
                          (error "Unquote-splicing wasn't in a list:"
                                 form))
                         ((and (pair? (car form))
                               (eq? (car (car form)) 'unquote-splicing))
                          (mappend form (car (cdr (car form)))
                                   (foo level (cdr form))))
                         (else (mcons form (foo level (car form))
                                         (foo level (cdr form)))))
                   (cond ((eq? (car form) 'unquote)
                          (mcons form ''unquote (foo (- level 1)
                                                     (cdr form))))
                         ((eq? (car form) 'unquote-splicing)
                          (mcons form ''unquote-splicing
                                      (foo (- level 1) (cdr form))))
                         (else (mcons form (foo level (car form))
                                         (foo level (cdr form)))))))))
   (foo 0 l)))


(define when
  (macro form
    `(if ,(car form) (begin ,@(cdr form)))))
  
(define unless
  (macro form
    `(if (not ,(car form)) (begin ,@(cdr form)))))


;; ----------------------------------------
;; Higher-order functions
;; ----------------------------------------
(define (map pred lst)
  (if (null? lst)
      '()
      (cons
       (pred (car lst))
       (map pred (cdr lst)))))
(define for-each map)

(define (filter pred lst)
  (if (null? lst)
      '()
      (let ((result  (pred (car lst))))
        (if result
            (cons
             result
             (filter pred (cdr lst)))
            (filter pred (cdr lst))))))



;; ----------------------------------------
;; List library functions
;; ----------------------------------------
(define (last-pair x)
    (if (pair? (cdr x))
        (last-pair (cdr x))
        x))


;; ----------------------------------------
;; Utility function for testing
;; ----------------------------------------
;; pass through the argument value as return value.
(define (pass x) x)

;; ruby's p like function.
(define (p x)
  (printf "%s\n" x)
  x)
