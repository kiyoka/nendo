;;-*- mode: scheme; syntax: scheme -*-;;

;; ----------------------------------------
;; car and cdr functions
;; ----------------------------------------
(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))


;; ----------------------------------------
;; List Utility functions
;; ----------------------------------------
(define iota range)

(define (append a b)
  (define (append_reverse a b)
    (if (pair? a)
        (append_reverse (cdr a) (cons (car a) b))
        b))
  (append_reverse (reverse a) b))

;; ----------------------------------------
;; basic forms
;; ----------------------------------------
(define (macroexpand sexp)
  (let ((newsexp (macroexpand1 sexp)))
    (if (not (equal? sexp newsexp))
        (macroexpand newsexp)
        newsexp)))

(define caseblock
  (lambda (elem . elseblock)
    (let ((condition (car elem))
          (body      (cdr elem)))
      (append
       (list 'if
             (if (eq? 'else condition)
                 true
                 condition)
             (cons 'begin body))
       (if (< 0 (length elseblock))
           elseblock
           '())))))

;;(caseblock '(true (print "1") (newline)) '())
;;(caseblock '(else (print "1") (newline)) '(if))

(define (cond_iter lst)
  (if (eq? 0 (length lst))
      '()
      (if (eq? 1 (length lst))
          (caseblock (car lst) '())
          (caseblock (car lst)
                     (cond_iter (cdr lst))))))

(define cond
  (macro lst
    (cond_iter lst)))



;; ----------------------------------------
;; Higher-order functions
;; ----------------------------------------
(define (map pred lst)
  (if (null? lst)
      '()
      (cons
       (pred (car lst))
       (map pred (cdr lst)))))
(define foreach map)

(define (filter pred lst)
  (if (null? lst)
      '()
      (let ((result  (pred (car lst))))
        (if result
            (cons
             result
             (filter pred (cdr lst)))
            (filter pred (cdr lst))))))


;; ----------------------------------------
;; Utility function for testing
;; ----------------------------------------
;; pass through the argument value as return value.
(define (pass x) x)

;; ruby's p like function.
(define (p x)
  (printf "%s\n" x)
  x)
