;;-*- mode: scheme; syntax: scheme -*-;;

;; ----------------------------------------
;; define
;; ----------------------------------------
(set! define
      (macro (arg . body)
        (if (not (pair? arg))
            (cons 'set!
                  (cons arg
                        body))
            (cons 'set!
                  (cons (car arg)
                        (list
                         (cons 'lambda
                               (cons  (cdr arg)
                                      body))))))))

;; ----------------------------------------
;; car and cdr functions
;; ----------------------------------------
(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))


;; ----------------------------------------
;; List Utility functions
;; ----------------------------------------
(define iota range)

(macroexpand1
 '(define (append_reverse a b)
    (if (pair? a)
        (append_reverse (cdr a) (cons (car a) b))
        b)))
 

(define (append a b)
  (define (append_reverse a b)
    (if (pair? a)
        (append_reverse (cdr a) (cons (car a) b))
        b))
  (append_reverse (reverse a) b))

;; ----------------------------------------
;; basic forms
;; ----------------------------------------
(define (macroexpand sexp)
  (let ((newsexp (macroexpand1 sexp)))
    (if (not (equal? sexp newsexp))
        (macroexpand newsexp)
        newsexp)))

(define cond
  (macro lst
    (define (caseblock elem . elseblock)
      (let ((condition (car elem))
            (body      (cdr elem)))
        (append
         (list 'if
               (if (eq? 'else condition)
                   true
                   condition)
               (cons 'begin body))
         (if (< 0 (length elseblock))
             elseblock
             '()))))

    (define (cond_iter lst)
      (if (eq? 0 (length lst))
          '()
          (if (eq? 1 (length lst))
              (caseblock (car lst) '())
              (caseblock (car lst)
                         (cond_iter (cdr lst))))))

    (cond_iter lst)))

(define let1
  (macro (var expr body)
    (list 'let (list (list var expr)) body)))


(define or
  (macro lst
    (define (or_iter lst)
      (cond
       ((eq? 0 (length lst))
        false)
       ((eq? 1 (length lst))
        (let1 sym (gensym)
              (list 'let1 sym (car lst)
                    (list 'if sym sym false))))
       (else
        (let1 sym (gensym)
              (list 'let1 sym (car lst)
                    (list 'if sym sym (or_iter (cdr lst))))))))
    (or_iter lst)))

(define and
  (macro lst
    (define (and_iter lst)
      (cond
       ((eq? 0 (length lst))
        true)
       ((eq? 1 (length lst))
        (car lst))
       (else
        (list 'if (list 'not (list 'eq? 'false (car lst)))
              (and_iter (cdr lst))
              'false))))
    (and_iter lst)))


;; ----------------------------------------
;; Higher-order functions
;; ----------------------------------------
(define (map pred lst)
  (if (null? lst)
      '()
      (cons
       (pred (car lst))
       (map pred (cdr lst)))))
(define foreach map)

(define (filter pred lst)
  (if (null? lst)
      '()
      (let ((result  (pred (car lst))))
        (if result
            (cons
             result
             (filter pred (cdr lst)))
            (filter pred (cdr lst))))))


;; ----------------------------------------
;; Utility function for testing
;; ----------------------------------------
;; pass through the argument value as return value.
(define (pass x) x)

;; ruby's p like function.
(define (p x)
  (printf "%s\n" x)
  x)
